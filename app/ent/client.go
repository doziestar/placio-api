// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"placio-app/ent/migrate"

	"placio-app/ent/accountsettings"
	"placio-app/ent/accountwallet"
	"placio-app/ent/amenity"
	"placio-app/ent/booking"
	"placio-app/ent/business"
	"placio-app/ent/businessfollowbusiness"
	"placio-app/ent/businessfollowevent"
	"placio-app/ent/businessfollowuser"
	"placio-app/ent/category"
	"placio-app/ent/categoryassignment"
	"placio-app/ent/chat"
	"placio-app/ent/comment"
	"placio-app/ent/customblock"
	"placio-app/ent/event"
	"placio-app/ent/eventorganizer"
	"placio-app/ent/faq"
	"placio-app/ent/featurerelease"
	"placio-app/ent/fitness"
	"placio-app/ent/help"
	"placio-app/ent/inventoryattribute"
	"placio-app/ent/inventorytype"
	"placio-app/ent/like"
	"placio-app/ent/media"
	"placio-app/ent/menu"
	"placio-app/ent/menuitem"
	"placio-app/ent/notification"
	"placio-app/ent/order"
	"placio-app/ent/orderitem"
	"placio-app/ent/payment"
	"placio-app/ent/permission"
	"placio-app/ent/place"
	"placio-app/ent/placeinventory"
	"placio-app/ent/placeinventoryattribute"
	"placio-app/ent/placetable"
	"placio-app/ent/plan"
	"placio-app/ent/post"
	"placio-app/ent/price"
	"placio-app/ent/rating"
	"placio-app/ent/reaction"
	"placio-app/ent/reservation"
	"placio-app/ent/reservationblock"
	"placio-app/ent/resourse"
	"placio-app/ent/review"
	"placio-app/ent/room"
	"placio-app/ent/roomcategory"
	"placio-app/ent/staff"
	"placio-app/ent/subscription"
	"placio-app/ent/template"
	"placio-app/ent/ticket"
	"placio-app/ent/ticketoption"
	"placio-app/ent/trainer"
	"placio-app/ent/transactionhistory"
	"placio-app/ent/user"
	"placio-app/ent/userbusiness"
	"placio-app/ent/userfollowbusiness"
	"placio-app/ent/userfollowevent"
	"placio-app/ent/userfollowplace"
	"placio-app/ent/userfollowuser"
	"placio-app/ent/userlikeplace"
	"placio-app/ent/website"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccountSettings is the client for interacting with the AccountSettings builders.
	AccountSettings *AccountSettingsClient
	// AccountWallet is the client for interacting with the AccountWallet builders.
	AccountWallet *AccountWalletClient
	// Amenity is the client for interacting with the Amenity builders.
	Amenity *AmenityClient
	// Booking is the client for interacting with the Booking builders.
	Booking *BookingClient
	// Business is the client for interacting with the Business builders.
	Business *BusinessClient
	// BusinessFollowBusiness is the client for interacting with the BusinessFollowBusiness builders.
	BusinessFollowBusiness *BusinessFollowBusinessClient
	// BusinessFollowEvent is the client for interacting with the BusinessFollowEvent builders.
	BusinessFollowEvent *BusinessFollowEventClient
	// BusinessFollowUser is the client for interacting with the BusinessFollowUser builders.
	BusinessFollowUser *BusinessFollowUserClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// CategoryAssignment is the client for interacting with the CategoryAssignment builders.
	CategoryAssignment *CategoryAssignmentClient
	// Chat is the client for interacting with the Chat builders.
	Chat *ChatClient
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// CustomBlock is the client for interacting with the CustomBlock builders.
	CustomBlock *CustomBlockClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// EventOrganizer is the client for interacting with the EventOrganizer builders.
	EventOrganizer *EventOrganizerClient
	// FAQ is the client for interacting with the FAQ builders.
	FAQ *FAQClient
	// FeatureRelease is the client for interacting with the FeatureRelease builders.
	FeatureRelease *FeatureReleaseClient
	// Fitness is the client for interacting with the Fitness builders.
	Fitness *FitnessClient
	// Help is the client for interacting with the Help builders.
	Help *HelpClient
	// InventoryAttribute is the client for interacting with the InventoryAttribute builders.
	InventoryAttribute *InventoryAttributeClient
	// InventoryType is the client for interacting with the InventoryType builders.
	InventoryType *InventoryTypeClient
	// Like is the client for interacting with the Like builders.
	Like *LikeClient
	// Media is the client for interacting with the Media builders.
	Media *MediaClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// MenuItem is the client for interacting with the MenuItem builders.
	MenuItem *MenuItemClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderItem is the client for interacting with the OrderItem builders.
	OrderItem *OrderItemClient
	// Payment is the client for interacting with the Payment builders.
	Payment *PaymentClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Place is the client for interacting with the Place builders.
	Place *PlaceClient
	// PlaceInventory is the client for interacting with the PlaceInventory builders.
	PlaceInventory *PlaceInventoryClient
	// PlaceInventoryAttribute is the client for interacting with the PlaceInventoryAttribute builders.
	PlaceInventoryAttribute *PlaceInventoryAttributeClient
	// PlaceTable is the client for interacting with the PlaceTable builders.
	PlaceTable *PlaceTableClient
	// Plan is the client for interacting with the Plan builders.
	Plan *PlanClient
	// Post is the client for interacting with the Post builders.
	Post *PostClient
	// Price is the client for interacting with the Price builders.
	Price *PriceClient
	// Rating is the client for interacting with the Rating builders.
	Rating *RatingClient
	// Reaction is the client for interacting with the Reaction builders.
	Reaction *ReactionClient
	// Reservation is the client for interacting with the Reservation builders.
	Reservation *ReservationClient
	// ReservationBlock is the client for interacting with the ReservationBlock builders.
	ReservationBlock *ReservationBlockClient
	// Resourse is the client for interacting with the Resourse builders.
	Resourse *ResourseClient
	// Review is the client for interacting with the Review builders.
	Review *ReviewClient
	// Room is the client for interacting with the Room builders.
	Room *RoomClient
	// RoomCategory is the client for interacting with the RoomCategory builders.
	RoomCategory *RoomCategoryClient
	// Staff is the client for interacting with the Staff builders.
	Staff *StaffClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// Template is the client for interacting with the Template builders.
	Template *TemplateClient
	// Ticket is the client for interacting with the Ticket builders.
	Ticket *TicketClient
	// TicketOption is the client for interacting with the TicketOption builders.
	TicketOption *TicketOptionClient
	// Trainer is the client for interacting with the Trainer builders.
	Trainer *TrainerClient
	// TransactionHistory is the client for interacting with the TransactionHistory builders.
	TransactionHistory *TransactionHistoryClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserBusiness is the client for interacting with the UserBusiness builders.
	UserBusiness *UserBusinessClient
	// UserFollowBusiness is the client for interacting with the UserFollowBusiness builders.
	UserFollowBusiness *UserFollowBusinessClient
	// UserFollowEvent is the client for interacting with the UserFollowEvent builders.
	UserFollowEvent *UserFollowEventClient
	// UserFollowPlace is the client for interacting with the UserFollowPlace builders.
	UserFollowPlace *UserFollowPlaceClient
	// UserFollowUser is the client for interacting with the UserFollowUser builders.
	UserFollowUser *UserFollowUserClient
	// UserLikePlace is the client for interacting with the UserLikePlace builders.
	UserLikePlace *UserLikePlaceClient
	// Website is the client for interacting with the Website builders.
	Website *WebsiteClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccountSettings = NewAccountSettingsClient(c.config)
	c.AccountWallet = NewAccountWalletClient(c.config)
	c.Amenity = NewAmenityClient(c.config)
	c.Booking = NewBookingClient(c.config)
	c.Business = NewBusinessClient(c.config)
	c.BusinessFollowBusiness = NewBusinessFollowBusinessClient(c.config)
	c.BusinessFollowEvent = NewBusinessFollowEventClient(c.config)
	c.BusinessFollowUser = NewBusinessFollowUserClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.CategoryAssignment = NewCategoryAssignmentClient(c.config)
	c.Chat = NewChatClient(c.config)
	c.Comment = NewCommentClient(c.config)
	c.CustomBlock = NewCustomBlockClient(c.config)
	c.Event = NewEventClient(c.config)
	c.EventOrganizer = NewEventOrganizerClient(c.config)
	c.FAQ = NewFAQClient(c.config)
	c.FeatureRelease = NewFeatureReleaseClient(c.config)
	c.Fitness = NewFitnessClient(c.config)
	c.Help = NewHelpClient(c.config)
	c.InventoryAttribute = NewInventoryAttributeClient(c.config)
	c.InventoryType = NewInventoryTypeClient(c.config)
	c.Like = NewLikeClient(c.config)
	c.Media = NewMediaClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.MenuItem = NewMenuItemClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderItem = NewOrderItemClient(c.config)
	c.Payment = NewPaymentClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Place = NewPlaceClient(c.config)
	c.PlaceInventory = NewPlaceInventoryClient(c.config)
	c.PlaceInventoryAttribute = NewPlaceInventoryAttributeClient(c.config)
	c.PlaceTable = NewPlaceTableClient(c.config)
	c.Plan = NewPlanClient(c.config)
	c.Post = NewPostClient(c.config)
	c.Price = NewPriceClient(c.config)
	c.Rating = NewRatingClient(c.config)
	c.Reaction = NewReactionClient(c.config)
	c.Reservation = NewReservationClient(c.config)
	c.ReservationBlock = NewReservationBlockClient(c.config)
	c.Resourse = NewResourseClient(c.config)
	c.Review = NewReviewClient(c.config)
	c.Room = NewRoomClient(c.config)
	c.RoomCategory = NewRoomCategoryClient(c.config)
	c.Staff = NewStaffClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.Template = NewTemplateClient(c.config)
	c.Ticket = NewTicketClient(c.config)
	c.TicketOption = NewTicketOptionClient(c.config)
	c.Trainer = NewTrainerClient(c.config)
	c.TransactionHistory = NewTransactionHistoryClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserBusiness = NewUserBusinessClient(c.config)
	c.UserFollowBusiness = NewUserFollowBusinessClient(c.config)
	c.UserFollowEvent = NewUserFollowEventClient(c.config)
	c.UserFollowPlace = NewUserFollowPlaceClient(c.config)
	c.UserFollowUser = NewUserFollowUserClient(c.config)
	c.UserLikePlace = NewUserLikePlaceClient(c.config)
	c.Website = NewWebsiteClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AccountSettings:         NewAccountSettingsClient(cfg),
		AccountWallet:           NewAccountWalletClient(cfg),
		Amenity:                 NewAmenityClient(cfg),
		Booking:                 NewBookingClient(cfg),
		Business:                NewBusinessClient(cfg),
		BusinessFollowBusiness:  NewBusinessFollowBusinessClient(cfg),
		BusinessFollowEvent:     NewBusinessFollowEventClient(cfg),
		BusinessFollowUser:      NewBusinessFollowUserClient(cfg),
		Category:                NewCategoryClient(cfg),
		CategoryAssignment:      NewCategoryAssignmentClient(cfg),
		Chat:                    NewChatClient(cfg),
		Comment:                 NewCommentClient(cfg),
		CustomBlock:             NewCustomBlockClient(cfg),
		Event:                   NewEventClient(cfg),
		EventOrganizer:          NewEventOrganizerClient(cfg),
		FAQ:                     NewFAQClient(cfg),
		FeatureRelease:          NewFeatureReleaseClient(cfg),
		Fitness:                 NewFitnessClient(cfg),
		Help:                    NewHelpClient(cfg),
		InventoryAttribute:      NewInventoryAttributeClient(cfg),
		InventoryType:           NewInventoryTypeClient(cfg),
		Like:                    NewLikeClient(cfg),
		Media:                   NewMediaClient(cfg),
		Menu:                    NewMenuClient(cfg),
		MenuItem:                NewMenuItemClient(cfg),
		Notification:            NewNotificationClient(cfg),
		Order:                   NewOrderClient(cfg),
		OrderItem:               NewOrderItemClient(cfg),
		Payment:                 NewPaymentClient(cfg),
		Permission:              NewPermissionClient(cfg),
		Place:                   NewPlaceClient(cfg),
		PlaceInventory:          NewPlaceInventoryClient(cfg),
		PlaceInventoryAttribute: NewPlaceInventoryAttributeClient(cfg),
		PlaceTable:              NewPlaceTableClient(cfg),
		Plan:                    NewPlanClient(cfg),
		Post:                    NewPostClient(cfg),
		Price:                   NewPriceClient(cfg),
		Rating:                  NewRatingClient(cfg),
		Reaction:                NewReactionClient(cfg),
		Reservation:             NewReservationClient(cfg),
		ReservationBlock:        NewReservationBlockClient(cfg),
		Resourse:                NewResourseClient(cfg),
		Review:                  NewReviewClient(cfg),
		Room:                    NewRoomClient(cfg),
		RoomCategory:            NewRoomCategoryClient(cfg),
		Staff:                   NewStaffClient(cfg),
		Subscription:            NewSubscriptionClient(cfg),
		Template:                NewTemplateClient(cfg),
		Ticket:                  NewTicketClient(cfg),
		TicketOption:            NewTicketOptionClient(cfg),
		Trainer:                 NewTrainerClient(cfg),
		TransactionHistory:      NewTransactionHistoryClient(cfg),
		User:                    NewUserClient(cfg),
		UserBusiness:            NewUserBusinessClient(cfg),
		UserFollowBusiness:      NewUserFollowBusinessClient(cfg),
		UserFollowEvent:         NewUserFollowEventClient(cfg),
		UserFollowPlace:         NewUserFollowPlaceClient(cfg),
		UserFollowUser:          NewUserFollowUserClient(cfg),
		UserLikePlace:           NewUserLikePlaceClient(cfg),
		Website:                 NewWebsiteClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AccountSettings:         NewAccountSettingsClient(cfg),
		AccountWallet:           NewAccountWalletClient(cfg),
		Amenity:                 NewAmenityClient(cfg),
		Booking:                 NewBookingClient(cfg),
		Business:                NewBusinessClient(cfg),
		BusinessFollowBusiness:  NewBusinessFollowBusinessClient(cfg),
		BusinessFollowEvent:     NewBusinessFollowEventClient(cfg),
		BusinessFollowUser:      NewBusinessFollowUserClient(cfg),
		Category:                NewCategoryClient(cfg),
		CategoryAssignment:      NewCategoryAssignmentClient(cfg),
		Chat:                    NewChatClient(cfg),
		Comment:                 NewCommentClient(cfg),
		CustomBlock:             NewCustomBlockClient(cfg),
		Event:                   NewEventClient(cfg),
		EventOrganizer:          NewEventOrganizerClient(cfg),
		FAQ:                     NewFAQClient(cfg),
		FeatureRelease:          NewFeatureReleaseClient(cfg),
		Fitness:                 NewFitnessClient(cfg),
		Help:                    NewHelpClient(cfg),
		InventoryAttribute:      NewInventoryAttributeClient(cfg),
		InventoryType:           NewInventoryTypeClient(cfg),
		Like:                    NewLikeClient(cfg),
		Media:                   NewMediaClient(cfg),
		Menu:                    NewMenuClient(cfg),
		MenuItem:                NewMenuItemClient(cfg),
		Notification:            NewNotificationClient(cfg),
		Order:                   NewOrderClient(cfg),
		OrderItem:               NewOrderItemClient(cfg),
		Payment:                 NewPaymentClient(cfg),
		Permission:              NewPermissionClient(cfg),
		Place:                   NewPlaceClient(cfg),
		PlaceInventory:          NewPlaceInventoryClient(cfg),
		PlaceInventoryAttribute: NewPlaceInventoryAttributeClient(cfg),
		PlaceTable:              NewPlaceTableClient(cfg),
		Plan:                    NewPlanClient(cfg),
		Post:                    NewPostClient(cfg),
		Price:                   NewPriceClient(cfg),
		Rating:                  NewRatingClient(cfg),
		Reaction:                NewReactionClient(cfg),
		Reservation:             NewReservationClient(cfg),
		ReservationBlock:        NewReservationBlockClient(cfg),
		Resourse:                NewResourseClient(cfg),
		Review:                  NewReviewClient(cfg),
		Room:                    NewRoomClient(cfg),
		RoomCategory:            NewRoomCategoryClient(cfg),
		Staff:                   NewStaffClient(cfg),
		Subscription:            NewSubscriptionClient(cfg),
		Template:                NewTemplateClient(cfg),
		Ticket:                  NewTicketClient(cfg),
		TicketOption:            NewTicketOptionClient(cfg),
		Trainer:                 NewTrainerClient(cfg),
		TransactionHistory:      NewTransactionHistoryClient(cfg),
		User:                    NewUserClient(cfg),
		UserBusiness:            NewUserBusinessClient(cfg),
		UserFollowBusiness:      NewUserFollowBusinessClient(cfg),
		UserFollowEvent:         NewUserFollowEventClient(cfg),
		UserFollowPlace:         NewUserFollowPlaceClient(cfg),
		UserFollowUser:          NewUserFollowUserClient(cfg),
		UserLikePlace:           NewUserLikePlaceClient(cfg),
		Website:                 NewWebsiteClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccountSettings.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccountSettings, c.AccountWallet, c.Amenity, c.Booking, c.Business,
		c.BusinessFollowBusiness, c.BusinessFollowEvent, c.BusinessFollowUser,
		c.Category, c.CategoryAssignment, c.Chat, c.Comment, c.CustomBlock, c.Event,
		c.EventOrganizer, c.FAQ, c.FeatureRelease, c.Fitness, c.Help,
		c.InventoryAttribute, c.InventoryType, c.Like, c.Media, c.Menu, c.MenuItem,
		c.Notification, c.Order, c.OrderItem, c.Payment, c.Permission, c.Place,
		c.PlaceInventory, c.PlaceInventoryAttribute, c.PlaceTable, c.Plan, c.Post,
		c.Price, c.Rating, c.Reaction, c.Reservation, c.ReservationBlock, c.Resourse,
		c.Review, c.Room, c.RoomCategory, c.Staff, c.Subscription, c.Template,
		c.Ticket, c.TicketOption, c.Trainer, c.TransactionHistory, c.User,
		c.UserBusiness, c.UserFollowBusiness, c.UserFollowEvent, c.UserFollowPlace,
		c.UserFollowUser, c.UserLikePlace, c.Website,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccountSettings, c.AccountWallet, c.Amenity, c.Booking, c.Business,
		c.BusinessFollowBusiness, c.BusinessFollowEvent, c.BusinessFollowUser,
		c.Category, c.CategoryAssignment, c.Chat, c.Comment, c.CustomBlock, c.Event,
		c.EventOrganizer, c.FAQ, c.FeatureRelease, c.Fitness, c.Help,
		c.InventoryAttribute, c.InventoryType, c.Like, c.Media, c.Menu, c.MenuItem,
		c.Notification, c.Order, c.OrderItem, c.Payment, c.Permission, c.Place,
		c.PlaceInventory, c.PlaceInventoryAttribute, c.PlaceTable, c.Plan, c.Post,
		c.Price, c.Rating, c.Reaction, c.Reservation, c.ReservationBlock, c.Resourse,
		c.Review, c.Room, c.RoomCategory, c.Staff, c.Subscription, c.Template,
		c.Ticket, c.TicketOption, c.Trainer, c.TransactionHistory, c.User,
		c.UserBusiness, c.UserFollowBusiness, c.UserFollowEvent, c.UserFollowPlace,
		c.UserFollowUser, c.UserLikePlace, c.Website,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountSettingsMutation:
		return c.AccountSettings.mutate(ctx, m)
	case *AccountWalletMutation:
		return c.AccountWallet.mutate(ctx, m)
	case *AmenityMutation:
		return c.Amenity.mutate(ctx, m)
	case *BookingMutation:
		return c.Booking.mutate(ctx, m)
	case *BusinessMutation:
		return c.Business.mutate(ctx, m)
	case *BusinessFollowBusinessMutation:
		return c.BusinessFollowBusiness.mutate(ctx, m)
	case *BusinessFollowEventMutation:
		return c.BusinessFollowEvent.mutate(ctx, m)
	case *BusinessFollowUserMutation:
		return c.BusinessFollowUser.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *CategoryAssignmentMutation:
		return c.CategoryAssignment.mutate(ctx, m)
	case *ChatMutation:
		return c.Chat.mutate(ctx, m)
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *CustomBlockMutation:
		return c.CustomBlock.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EventOrganizerMutation:
		return c.EventOrganizer.mutate(ctx, m)
	case *FAQMutation:
		return c.FAQ.mutate(ctx, m)
	case *FeatureReleaseMutation:
		return c.FeatureRelease.mutate(ctx, m)
	case *FitnessMutation:
		return c.Fitness.mutate(ctx, m)
	case *HelpMutation:
		return c.Help.mutate(ctx, m)
	case *InventoryAttributeMutation:
		return c.InventoryAttribute.mutate(ctx, m)
	case *InventoryTypeMutation:
		return c.InventoryType.mutate(ctx, m)
	case *LikeMutation:
		return c.Like.mutate(ctx, m)
	case *MediaMutation:
		return c.Media.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *MenuItemMutation:
		return c.MenuItem.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderItemMutation:
		return c.OrderItem.mutate(ctx, m)
	case *PaymentMutation:
		return c.Payment.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *PlaceMutation:
		return c.Place.mutate(ctx, m)
	case *PlaceInventoryMutation:
		return c.PlaceInventory.mutate(ctx, m)
	case *PlaceInventoryAttributeMutation:
		return c.PlaceInventoryAttribute.mutate(ctx, m)
	case *PlaceTableMutation:
		return c.PlaceTable.mutate(ctx, m)
	case *PlanMutation:
		return c.Plan.mutate(ctx, m)
	case *PostMutation:
		return c.Post.mutate(ctx, m)
	case *PriceMutation:
		return c.Price.mutate(ctx, m)
	case *RatingMutation:
		return c.Rating.mutate(ctx, m)
	case *ReactionMutation:
		return c.Reaction.mutate(ctx, m)
	case *ReservationMutation:
		return c.Reservation.mutate(ctx, m)
	case *ReservationBlockMutation:
		return c.ReservationBlock.mutate(ctx, m)
	case *ResourseMutation:
		return c.Resourse.mutate(ctx, m)
	case *ReviewMutation:
		return c.Review.mutate(ctx, m)
	case *RoomMutation:
		return c.Room.mutate(ctx, m)
	case *RoomCategoryMutation:
		return c.RoomCategory.mutate(ctx, m)
	case *StaffMutation:
		return c.Staff.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *TemplateMutation:
		return c.Template.mutate(ctx, m)
	case *TicketMutation:
		return c.Ticket.mutate(ctx, m)
	case *TicketOptionMutation:
		return c.TicketOption.mutate(ctx, m)
	case *TrainerMutation:
		return c.Trainer.mutate(ctx, m)
	case *TransactionHistoryMutation:
		return c.TransactionHistory.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserBusinessMutation:
		return c.UserBusiness.mutate(ctx, m)
	case *UserFollowBusinessMutation:
		return c.UserFollowBusiness.mutate(ctx, m)
	case *UserFollowEventMutation:
		return c.UserFollowEvent.mutate(ctx, m)
	case *UserFollowPlaceMutation:
		return c.UserFollowPlace.mutate(ctx, m)
	case *UserFollowUserMutation:
		return c.UserFollowUser.mutate(ctx, m)
	case *UserLikePlaceMutation:
		return c.UserLikePlace.mutate(ctx, m)
	case *WebsiteMutation:
		return c.Website.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccountSettingsClient is a client for the AccountSettings schema.
type AccountSettingsClient struct {
	config
}

// NewAccountSettingsClient returns a client for the AccountSettings from the given config.
func NewAccountSettingsClient(c config) *AccountSettingsClient {
	return &AccountSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountsettings.Hooks(f(g(h())))`.
func (c *AccountSettingsClient) Use(hooks ...Hook) {
	c.hooks.AccountSettings = append(c.hooks.AccountSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountsettings.Intercept(f(g(h())))`.
func (c *AccountSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountSettings = append(c.inters.AccountSettings, interceptors...)
}

// Create returns a builder for creating a AccountSettings entity.
func (c *AccountSettingsClient) Create() *AccountSettingsCreate {
	mutation := newAccountSettingsMutation(c.config, OpCreate)
	return &AccountSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountSettings entities.
func (c *AccountSettingsClient) CreateBulk(builders ...*AccountSettingsCreate) *AccountSettingsCreateBulk {
	return &AccountSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountSettingsClient) MapCreateBulk(slice any, setFunc func(*AccountSettingsCreate, int)) *AccountSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountSettingsCreateBulk{err: fmt.Errorf("calling to AccountSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountSettings.
func (c *AccountSettingsClient) Update() *AccountSettingsUpdate {
	mutation := newAccountSettingsMutation(c.config, OpUpdate)
	return &AccountSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountSettingsClient) UpdateOne(as *AccountSettings) *AccountSettingsUpdateOne {
	mutation := newAccountSettingsMutation(c.config, OpUpdateOne, withAccountSettings(as))
	return &AccountSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountSettingsClient) UpdateOneID(id string) *AccountSettingsUpdateOne {
	mutation := newAccountSettingsMutation(c.config, OpUpdateOne, withAccountSettingsID(id))
	return &AccountSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountSettings.
func (c *AccountSettingsClient) Delete() *AccountSettingsDelete {
	mutation := newAccountSettingsMutation(c.config, OpDelete)
	return &AccountSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountSettingsClient) DeleteOne(as *AccountSettings) *AccountSettingsDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountSettingsClient) DeleteOneID(id string) *AccountSettingsDeleteOne {
	builder := c.Delete().Where(accountsettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountSettingsDeleteOne{builder}
}

// Query returns a query builder for AccountSettings.
func (c *AccountSettingsClient) Query() *AccountSettingsQuery {
	return &AccountSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountSettings entity by its id.
func (c *AccountSettingsClient) Get(ctx context.Context, id string) (*AccountSettings, error) {
	return c.Query().Where(accountsettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountSettingsClient) GetX(ctx context.Context, id string) *AccountSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusinessAccount queries the business_account edge of a AccountSettings.
func (c *AccountSettingsClient) QueryBusinessAccount(as *AccountSettings) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountsettings.Table, accountsettings.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, accountsettings.BusinessAccountTable, accountsettings.BusinessAccountColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountSettingsClient) Hooks() []Hook {
	return c.hooks.AccountSettings
}

// Interceptors returns the client interceptors.
func (c *AccountSettingsClient) Interceptors() []Interceptor {
	return c.inters.AccountSettings
}

func (c *AccountSettingsClient) mutate(ctx context.Context, m *AccountSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccountSettings mutation op: %q", m.Op())
	}
}

// AccountWalletClient is a client for the AccountWallet schema.
type AccountWalletClient struct {
	config
}

// NewAccountWalletClient returns a client for the AccountWallet from the given config.
func NewAccountWalletClient(c config) *AccountWalletClient {
	return &AccountWalletClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountwallet.Hooks(f(g(h())))`.
func (c *AccountWalletClient) Use(hooks ...Hook) {
	c.hooks.AccountWallet = append(c.hooks.AccountWallet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountwallet.Intercept(f(g(h())))`.
func (c *AccountWalletClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountWallet = append(c.inters.AccountWallet, interceptors...)
}

// Create returns a builder for creating a AccountWallet entity.
func (c *AccountWalletClient) Create() *AccountWalletCreate {
	mutation := newAccountWalletMutation(c.config, OpCreate)
	return &AccountWalletCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountWallet entities.
func (c *AccountWalletClient) CreateBulk(builders ...*AccountWalletCreate) *AccountWalletCreateBulk {
	return &AccountWalletCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountWalletClient) MapCreateBulk(slice any, setFunc func(*AccountWalletCreate, int)) *AccountWalletCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountWalletCreateBulk{err: fmt.Errorf("calling to AccountWalletClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountWalletCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountWalletCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountWallet.
func (c *AccountWalletClient) Update() *AccountWalletUpdate {
	mutation := newAccountWalletMutation(c.config, OpUpdate)
	return &AccountWalletUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountWalletClient) UpdateOne(aw *AccountWallet) *AccountWalletUpdateOne {
	mutation := newAccountWalletMutation(c.config, OpUpdateOne, withAccountWallet(aw))
	return &AccountWalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountWalletClient) UpdateOneID(id string) *AccountWalletUpdateOne {
	mutation := newAccountWalletMutation(c.config, OpUpdateOne, withAccountWalletID(id))
	return &AccountWalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountWallet.
func (c *AccountWalletClient) Delete() *AccountWalletDelete {
	mutation := newAccountWalletMutation(c.config, OpDelete)
	return &AccountWalletDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountWalletClient) DeleteOne(aw *AccountWallet) *AccountWalletDeleteOne {
	return c.DeleteOneID(aw.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountWalletClient) DeleteOneID(id string) *AccountWalletDeleteOne {
	builder := c.Delete().Where(accountwallet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountWalletDeleteOne{builder}
}

// Query returns a query builder for AccountWallet.
func (c *AccountWalletClient) Query() *AccountWalletQuery {
	return &AccountWalletQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountWallet},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountWallet entity by its id.
func (c *AccountWalletClient) Get(ctx context.Context, id string) (*AccountWallet, error) {
	return c.Query().Where(accountwallet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountWalletClient) GetX(ctx context.Context, id string) *AccountWallet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a AccountWallet.
func (c *AccountWalletClient) QueryUser(aw *AccountWallet) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := aw.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountwallet.Table, accountwallet.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, accountwallet.UserTable, accountwallet.UserColumn),
		)
		fromV = sqlgraph.Neighbors(aw.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a AccountWallet.
func (c *AccountWalletClient) QueryBusiness(aw *AccountWallet) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := aw.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountwallet.Table, accountwallet.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, accountwallet.BusinessTable, accountwallet.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(aw.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountWalletClient) Hooks() []Hook {
	return c.hooks.AccountWallet
}

// Interceptors returns the client interceptors.
func (c *AccountWalletClient) Interceptors() []Interceptor {
	return c.inters.AccountWallet
}

func (c *AccountWalletClient) mutate(ctx context.Context, m *AccountWalletMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountWalletCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountWalletUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountWalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountWalletDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccountWallet mutation op: %q", m.Op())
	}
}

// AmenityClient is a client for the Amenity schema.
type AmenityClient struct {
	config
}

// NewAmenityClient returns a client for the Amenity from the given config.
func NewAmenityClient(c config) *AmenityClient {
	return &AmenityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `amenity.Hooks(f(g(h())))`.
func (c *AmenityClient) Use(hooks ...Hook) {
	c.hooks.Amenity = append(c.hooks.Amenity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `amenity.Intercept(f(g(h())))`.
func (c *AmenityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Amenity = append(c.inters.Amenity, interceptors...)
}

// Create returns a builder for creating a Amenity entity.
func (c *AmenityClient) Create() *AmenityCreate {
	mutation := newAmenityMutation(c.config, OpCreate)
	return &AmenityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Amenity entities.
func (c *AmenityClient) CreateBulk(builders ...*AmenityCreate) *AmenityCreateBulk {
	return &AmenityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AmenityClient) MapCreateBulk(slice any, setFunc func(*AmenityCreate, int)) *AmenityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AmenityCreateBulk{err: fmt.Errorf("calling to AmenityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AmenityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AmenityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Amenity.
func (c *AmenityClient) Update() *AmenityUpdate {
	mutation := newAmenityMutation(c.config, OpUpdate)
	return &AmenityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AmenityClient) UpdateOne(a *Amenity) *AmenityUpdateOne {
	mutation := newAmenityMutation(c.config, OpUpdateOne, withAmenity(a))
	return &AmenityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AmenityClient) UpdateOneID(id string) *AmenityUpdateOne {
	mutation := newAmenityMutation(c.config, OpUpdateOne, withAmenityID(id))
	return &AmenityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Amenity.
func (c *AmenityClient) Delete() *AmenityDelete {
	mutation := newAmenityMutation(c.config, OpDelete)
	return &AmenityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AmenityClient) DeleteOne(a *Amenity) *AmenityDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AmenityClient) DeleteOneID(id string) *AmenityDeleteOne {
	builder := c.Delete().Where(amenity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AmenityDeleteOne{builder}
}

// Query returns a query builder for Amenity.
func (c *AmenityClient) Query() *AmenityQuery {
	return &AmenityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAmenity},
		inters: c.Interceptors(),
	}
}

// Get returns a Amenity entity by its id.
func (c *AmenityClient) Get(ctx context.Context, id string) (*Amenity, error) {
	return c.Query().Where(amenity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AmenityClient) GetX(ctx context.Context, id string) *Amenity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlaces queries the places edge of a Amenity.
func (c *AmenityClient) QueryPlaces(a *Amenity) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amenity.Table, amenity.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, amenity.PlacesTable, amenity.PlacesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRooms queries the rooms edge of a Amenity.
func (c *AmenityClient) QueryRooms(a *Amenity) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amenity.Table, amenity.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, amenity.RoomsTable, amenity.RoomsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoomCategories queries the room_categories edge of a Amenity.
func (c *AmenityClient) QueryRoomCategories(a *Amenity) *RoomCategoryQuery {
	query := (&RoomCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amenity.Table, amenity.FieldID, id),
			sqlgraph.To(roomcategory.Table, roomcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, amenity.RoomCategoriesTable, amenity.RoomCategoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AmenityClient) Hooks() []Hook {
	return c.hooks.Amenity
}

// Interceptors returns the client interceptors.
func (c *AmenityClient) Interceptors() []Interceptor {
	return c.inters.Amenity
}

func (c *AmenityClient) mutate(ctx context.Context, m *AmenityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AmenityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AmenityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AmenityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AmenityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Amenity mutation op: %q", m.Op())
	}
}

// BookingClient is a client for the Booking schema.
type BookingClient struct {
	config
}

// NewBookingClient returns a client for the Booking from the given config.
func NewBookingClient(c config) *BookingClient {
	return &BookingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `booking.Hooks(f(g(h())))`.
func (c *BookingClient) Use(hooks ...Hook) {
	c.hooks.Booking = append(c.hooks.Booking, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `booking.Intercept(f(g(h())))`.
func (c *BookingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Booking = append(c.inters.Booking, interceptors...)
}

// Create returns a builder for creating a Booking entity.
func (c *BookingClient) Create() *BookingCreate {
	mutation := newBookingMutation(c.config, OpCreate)
	return &BookingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Booking entities.
func (c *BookingClient) CreateBulk(builders ...*BookingCreate) *BookingCreateBulk {
	return &BookingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookingClient) MapCreateBulk(slice any, setFunc func(*BookingCreate, int)) *BookingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookingCreateBulk{err: fmt.Errorf("calling to BookingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Booking.
func (c *BookingClient) Update() *BookingUpdate {
	mutation := newBookingMutation(c.config, OpUpdate)
	return &BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookingClient) UpdateOne(b *Booking) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBooking(b))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookingClient) UpdateOneID(id string) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBookingID(id))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Booking.
func (c *BookingClient) Delete() *BookingDelete {
	mutation := newBookingMutation(c.config, OpDelete)
	return &BookingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookingClient) DeleteOne(b *Booking) *BookingDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookingClient) DeleteOneID(id string) *BookingDeleteOne {
	builder := c.Delete().Where(booking.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookingDeleteOne{builder}
}

// Query returns a query builder for Booking.
func (c *BookingClient) Query() *BookingQuery {
	return &BookingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBooking},
		inters: c.Interceptors(),
	}
}

// Get returns a Booking entity by its id.
func (c *BookingClient) Get(ctx context.Context, id string) (*Booking, error) {
	return c.Query().Where(booking.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookingClient) GetX(ctx context.Context, id string) *Booking {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoom queries the room edge of a Booking.
func (c *BookingClient) QueryRoom(b *Booking) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.RoomTable, booking.RoomColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Booking.
func (c *BookingClient) QueryUser(b *Booking) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.UserTable, booking.UserColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookingClient) Hooks() []Hook {
	return c.hooks.Booking
}

// Interceptors returns the client interceptors.
func (c *BookingClient) Interceptors() []Interceptor {
	return c.inters.Booking
}

func (c *BookingClient) mutate(ctx context.Context, m *BookingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Booking mutation op: %q", m.Op())
	}
}

// BusinessClient is a client for the Business schema.
type BusinessClient struct {
	config
}

// NewBusinessClient returns a client for the Business from the given config.
func NewBusinessClient(c config) *BusinessClient {
	return &BusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `business.Hooks(f(g(h())))`.
func (c *BusinessClient) Use(hooks ...Hook) {
	c.hooks.Business = append(c.hooks.Business, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `business.Intercept(f(g(h())))`.
func (c *BusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.Business = append(c.inters.Business, interceptors...)
}

// Create returns a builder for creating a Business entity.
func (c *BusinessClient) Create() *BusinessCreate {
	mutation := newBusinessMutation(c.config, OpCreate)
	return &BusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Business entities.
func (c *BusinessClient) CreateBulk(builders ...*BusinessCreate) *BusinessCreateBulk {
	return &BusinessCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BusinessClient) MapCreateBulk(slice any, setFunc func(*BusinessCreate, int)) *BusinessCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BusinessCreateBulk{err: fmt.Errorf("calling to BusinessClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BusinessCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Business.
func (c *BusinessClient) Update() *BusinessUpdate {
	mutation := newBusinessMutation(c.config, OpUpdate)
	return &BusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessClient) UpdateOne(b *Business) *BusinessUpdateOne {
	mutation := newBusinessMutation(c.config, OpUpdateOne, withBusiness(b))
	return &BusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessClient) UpdateOneID(id string) *BusinessUpdateOne {
	mutation := newBusinessMutation(c.config, OpUpdateOne, withBusinessID(id))
	return &BusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Business.
func (c *BusinessClient) Delete() *BusinessDelete {
	mutation := newBusinessMutation(c.config, OpDelete)
	return &BusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessClient) DeleteOne(b *Business) *BusinessDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessClient) DeleteOneID(id string) *BusinessDeleteOne {
	builder := c.Delete().Where(business.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessDeleteOne{builder}
}

// Query returns a query builder for Business.
func (c *BusinessClient) Query() *BusinessQuery {
	return &BusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a Business entity by its id.
func (c *BusinessClient) Get(ctx context.Context, id string) (*Business, error) {
	return c.Query().Where(business.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessClient) GetX(ctx context.Context, id string) *Business {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserBusinesses queries the userBusinesses edge of a Business.
func (c *BusinessClient) QueryUserBusinesses(b *Business) *UserBusinessQuery {
	query := (&UserBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(userbusiness.Table, userbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.UserBusinessesTable, business.UserBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessAccountSettings queries the business_account_settings edge of a Business.
func (c *BusinessClient) QueryBusinessAccountSettings(b *Business) *AccountSettingsQuery {
	query := (&AccountSettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(accountsettings.Table, accountsettings.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, business.BusinessAccountSettingsTable, business.BusinessAccountSettingsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a Business.
func (c *BusinessClient) QueryPosts(b *Business) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.PostsTable, business.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedUsers queries the followedUsers edge of a Business.
func (c *BusinessClient) QueryFollowedUsers(b *Business) *BusinessFollowUserQuery {
	query := (&BusinessFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowuser.Table, businessfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowedUsersTable, business.FollowedUsersColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerUsers queries the followerUsers edge of a Business.
func (c *BusinessClient) QueryFollowerUsers(b *Business) *UserFollowBusinessQuery {
	query := (&UserFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(userfollowbusiness.Table, userfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowerUsersTable, business.FollowerUsersColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedBusinesses queries the followedBusinesses edge of a Business.
func (c *BusinessClient) QueryFollowedBusinesses(b *Business) *BusinessFollowBusinessQuery {
	query := (&BusinessFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowbusiness.Table, businessfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowedBusinessesTable, business.FollowedBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerBusinesses queries the followerBusinesses edge of a Business.
func (c *BusinessClient) QueryFollowerBusinesses(b *Business) *BusinessFollowBusinessQuery {
	query := (&BusinessFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowbusiness.Table, businessfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowerBusinessesTable, business.FollowerBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaces queries the places edge of a Business.
func (c *BusinessClient) QueryPlaces(b *Business) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.PlacesTable, business.PlacesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Business.
func (c *BusinessClient) QueryCategories(b *Business) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.CategoriesTable, business.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategoryAssignments queries the categoryAssignments edge of a Business.
func (c *BusinessClient) QueryCategoryAssignments(b *Business) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.CategoryAssignmentsTable, business.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Business.
func (c *BusinessClient) QueryEvents(b *Business) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.EventsTable, business.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessFollowEvents queries the businessFollowEvents edge of a Business.
func (c *BusinessClient) QueryBusinessFollowEvents(b *Business) *BusinessFollowEventQuery {
	query := (&BusinessFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowevent.Table, businessfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.BusinessFollowEventsTable, business.BusinessFollowEventsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaqs queries the faqs edge of a Business.
func (c *BusinessClient) QueryFaqs(b *Business) *FAQQuery {
	query := (&FAQClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(faq.Table, faq.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FaqsTable, business.FaqsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a Business.
func (c *BusinessClient) QueryRatings(b *Business) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.RatingsTable, business.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaceInventories queries the place_inventories edge of a Business.
func (c *BusinessClient) QueryPlaceInventories(b *Business) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.PlaceInventoriesTable, business.PlaceInventoriesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebsites queries the websites edge of a Business.
func (c *BusinessClient) QueryWebsites(b *Business) *WebsiteQuery {
	query := (&WebsiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(website.Table, website.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, business.WebsitesTable, business.WebsitesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Business.
func (c *BusinessClient) QueryNotifications(b *Business) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, business.NotificationsTable, business.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWallet queries the wallet edge of a Business.
func (c *BusinessClient) QueryWallet(b *Business) *AccountWalletQuery {
	query := (&AccountWalletClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(accountwallet.Table, accountwallet.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, business.WalletTable, business.WalletColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffs queries the staffs edge of a Business.
func (c *BusinessClient) QueryStaffs(b *Business) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, business.StaffsTable, business.StaffsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlans queries the plans edge of a Business.
func (c *BusinessClient) QueryPlans(b *Business) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, business.PlansTable, business.PlansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessClient) Hooks() []Hook {
	hooks := c.hooks.Business
	return append(hooks[:len(hooks):len(hooks)], business.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *BusinessClient) Interceptors() []Interceptor {
	return c.inters.Business
}

func (c *BusinessClient) mutate(ctx context.Context, m *BusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Business mutation op: %q", m.Op())
	}
}

// BusinessFollowBusinessClient is a client for the BusinessFollowBusiness schema.
type BusinessFollowBusinessClient struct {
	config
}

// NewBusinessFollowBusinessClient returns a client for the BusinessFollowBusiness from the given config.
func NewBusinessFollowBusinessClient(c config) *BusinessFollowBusinessClient {
	return &BusinessFollowBusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `businessfollowbusiness.Hooks(f(g(h())))`.
func (c *BusinessFollowBusinessClient) Use(hooks ...Hook) {
	c.hooks.BusinessFollowBusiness = append(c.hooks.BusinessFollowBusiness, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `businessfollowbusiness.Intercept(f(g(h())))`.
func (c *BusinessFollowBusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.BusinessFollowBusiness = append(c.inters.BusinessFollowBusiness, interceptors...)
}

// Create returns a builder for creating a BusinessFollowBusiness entity.
func (c *BusinessFollowBusinessClient) Create() *BusinessFollowBusinessCreate {
	mutation := newBusinessFollowBusinessMutation(c.config, OpCreate)
	return &BusinessFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BusinessFollowBusiness entities.
func (c *BusinessFollowBusinessClient) CreateBulk(builders ...*BusinessFollowBusinessCreate) *BusinessFollowBusinessCreateBulk {
	return &BusinessFollowBusinessCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BusinessFollowBusinessClient) MapCreateBulk(slice any, setFunc func(*BusinessFollowBusinessCreate, int)) *BusinessFollowBusinessCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BusinessFollowBusinessCreateBulk{err: fmt.Errorf("calling to BusinessFollowBusinessClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BusinessFollowBusinessCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BusinessFollowBusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) Update() *BusinessFollowBusinessUpdate {
	mutation := newBusinessFollowBusinessMutation(c.config, OpUpdate)
	return &BusinessFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessFollowBusinessClient) UpdateOne(bfb *BusinessFollowBusiness) *BusinessFollowBusinessUpdateOne {
	mutation := newBusinessFollowBusinessMutation(c.config, OpUpdateOne, withBusinessFollowBusiness(bfb))
	return &BusinessFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessFollowBusinessClient) UpdateOneID(id string) *BusinessFollowBusinessUpdateOne {
	mutation := newBusinessFollowBusinessMutation(c.config, OpUpdateOne, withBusinessFollowBusinessID(id))
	return &BusinessFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) Delete() *BusinessFollowBusinessDelete {
	mutation := newBusinessFollowBusinessMutation(c.config, OpDelete)
	return &BusinessFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessFollowBusinessClient) DeleteOne(bfb *BusinessFollowBusiness) *BusinessFollowBusinessDeleteOne {
	return c.DeleteOneID(bfb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessFollowBusinessClient) DeleteOneID(id string) *BusinessFollowBusinessDeleteOne {
	builder := c.Delete().Where(businessfollowbusiness.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessFollowBusinessDeleteOne{builder}
}

// Query returns a query builder for BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) Query() *BusinessFollowBusinessQuery {
	return &BusinessFollowBusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusinessFollowBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a BusinessFollowBusiness entity by its id.
func (c *BusinessFollowBusinessClient) Get(ctx context.Context, id string) (*BusinessFollowBusiness, error) {
	return c.Query().Where(businessfollowbusiness.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessFollowBusinessClient) GetX(ctx context.Context, id string) *BusinessFollowBusiness {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFollower queries the follower edge of a BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) QueryFollower(bfb *BusinessFollowBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowbusiness.Table, businessfollowbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowbusiness.FollowerTable, businessfollowbusiness.FollowerColumn),
		)
		fromV = sqlgraph.Neighbors(bfb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowed queries the followed edge of a BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) QueryFollowed(bfb *BusinessFollowBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowbusiness.Table, businessfollowbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowbusiness.FollowedTable, businessfollowbusiness.FollowedColumn),
		)
		fromV = sqlgraph.Neighbors(bfb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessFollowBusinessClient) Hooks() []Hook {
	return c.hooks.BusinessFollowBusiness
}

// Interceptors returns the client interceptors.
func (c *BusinessFollowBusinessClient) Interceptors() []Interceptor {
	return c.inters.BusinessFollowBusiness
}

func (c *BusinessFollowBusinessClient) mutate(ctx context.Context, m *BusinessFollowBusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BusinessFollowBusiness mutation op: %q", m.Op())
	}
}

// BusinessFollowEventClient is a client for the BusinessFollowEvent schema.
type BusinessFollowEventClient struct {
	config
}

// NewBusinessFollowEventClient returns a client for the BusinessFollowEvent from the given config.
func NewBusinessFollowEventClient(c config) *BusinessFollowEventClient {
	return &BusinessFollowEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `businessfollowevent.Hooks(f(g(h())))`.
func (c *BusinessFollowEventClient) Use(hooks ...Hook) {
	c.hooks.BusinessFollowEvent = append(c.hooks.BusinessFollowEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `businessfollowevent.Intercept(f(g(h())))`.
func (c *BusinessFollowEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.BusinessFollowEvent = append(c.inters.BusinessFollowEvent, interceptors...)
}

// Create returns a builder for creating a BusinessFollowEvent entity.
func (c *BusinessFollowEventClient) Create() *BusinessFollowEventCreate {
	mutation := newBusinessFollowEventMutation(c.config, OpCreate)
	return &BusinessFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BusinessFollowEvent entities.
func (c *BusinessFollowEventClient) CreateBulk(builders ...*BusinessFollowEventCreate) *BusinessFollowEventCreateBulk {
	return &BusinessFollowEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BusinessFollowEventClient) MapCreateBulk(slice any, setFunc func(*BusinessFollowEventCreate, int)) *BusinessFollowEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BusinessFollowEventCreateBulk{err: fmt.Errorf("calling to BusinessFollowEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BusinessFollowEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BusinessFollowEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BusinessFollowEvent.
func (c *BusinessFollowEventClient) Update() *BusinessFollowEventUpdate {
	mutation := newBusinessFollowEventMutation(c.config, OpUpdate)
	return &BusinessFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessFollowEventClient) UpdateOne(bfe *BusinessFollowEvent) *BusinessFollowEventUpdateOne {
	mutation := newBusinessFollowEventMutation(c.config, OpUpdateOne, withBusinessFollowEvent(bfe))
	return &BusinessFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessFollowEventClient) UpdateOneID(id string) *BusinessFollowEventUpdateOne {
	mutation := newBusinessFollowEventMutation(c.config, OpUpdateOne, withBusinessFollowEventID(id))
	return &BusinessFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BusinessFollowEvent.
func (c *BusinessFollowEventClient) Delete() *BusinessFollowEventDelete {
	mutation := newBusinessFollowEventMutation(c.config, OpDelete)
	return &BusinessFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessFollowEventClient) DeleteOne(bfe *BusinessFollowEvent) *BusinessFollowEventDeleteOne {
	return c.DeleteOneID(bfe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessFollowEventClient) DeleteOneID(id string) *BusinessFollowEventDeleteOne {
	builder := c.Delete().Where(businessfollowevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessFollowEventDeleteOne{builder}
}

// Query returns a query builder for BusinessFollowEvent.
func (c *BusinessFollowEventClient) Query() *BusinessFollowEventQuery {
	return &BusinessFollowEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusinessFollowEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a BusinessFollowEvent entity by its id.
func (c *BusinessFollowEventClient) Get(ctx context.Context, id string) (*BusinessFollowEvent, error) {
	return c.Query().Where(businessfollowevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessFollowEventClient) GetX(ctx context.Context, id string) *BusinessFollowEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a BusinessFollowEvent.
func (c *BusinessFollowEventClient) QueryBusiness(bfe *BusinessFollowEvent) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowevent.Table, businessfollowevent.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowevent.BusinessTable, businessfollowevent.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(bfe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a BusinessFollowEvent.
func (c *BusinessFollowEventClient) QueryEvent(bfe *BusinessFollowEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowevent.Table, businessfollowevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, businessfollowevent.EventTable, businessfollowevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(bfe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessFollowEventClient) Hooks() []Hook {
	return c.hooks.BusinessFollowEvent
}

// Interceptors returns the client interceptors.
func (c *BusinessFollowEventClient) Interceptors() []Interceptor {
	return c.inters.BusinessFollowEvent
}

func (c *BusinessFollowEventClient) mutate(ctx context.Context, m *BusinessFollowEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BusinessFollowEvent mutation op: %q", m.Op())
	}
}

// BusinessFollowUserClient is a client for the BusinessFollowUser schema.
type BusinessFollowUserClient struct {
	config
}

// NewBusinessFollowUserClient returns a client for the BusinessFollowUser from the given config.
func NewBusinessFollowUserClient(c config) *BusinessFollowUserClient {
	return &BusinessFollowUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `businessfollowuser.Hooks(f(g(h())))`.
func (c *BusinessFollowUserClient) Use(hooks ...Hook) {
	c.hooks.BusinessFollowUser = append(c.hooks.BusinessFollowUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `businessfollowuser.Intercept(f(g(h())))`.
func (c *BusinessFollowUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.BusinessFollowUser = append(c.inters.BusinessFollowUser, interceptors...)
}

// Create returns a builder for creating a BusinessFollowUser entity.
func (c *BusinessFollowUserClient) Create() *BusinessFollowUserCreate {
	mutation := newBusinessFollowUserMutation(c.config, OpCreate)
	return &BusinessFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BusinessFollowUser entities.
func (c *BusinessFollowUserClient) CreateBulk(builders ...*BusinessFollowUserCreate) *BusinessFollowUserCreateBulk {
	return &BusinessFollowUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BusinessFollowUserClient) MapCreateBulk(slice any, setFunc func(*BusinessFollowUserCreate, int)) *BusinessFollowUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BusinessFollowUserCreateBulk{err: fmt.Errorf("calling to BusinessFollowUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BusinessFollowUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BusinessFollowUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BusinessFollowUser.
func (c *BusinessFollowUserClient) Update() *BusinessFollowUserUpdate {
	mutation := newBusinessFollowUserMutation(c.config, OpUpdate)
	return &BusinessFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessFollowUserClient) UpdateOne(bfu *BusinessFollowUser) *BusinessFollowUserUpdateOne {
	mutation := newBusinessFollowUserMutation(c.config, OpUpdateOne, withBusinessFollowUser(bfu))
	return &BusinessFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessFollowUserClient) UpdateOneID(id string) *BusinessFollowUserUpdateOne {
	mutation := newBusinessFollowUserMutation(c.config, OpUpdateOne, withBusinessFollowUserID(id))
	return &BusinessFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BusinessFollowUser.
func (c *BusinessFollowUserClient) Delete() *BusinessFollowUserDelete {
	mutation := newBusinessFollowUserMutation(c.config, OpDelete)
	return &BusinessFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessFollowUserClient) DeleteOne(bfu *BusinessFollowUser) *BusinessFollowUserDeleteOne {
	return c.DeleteOneID(bfu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessFollowUserClient) DeleteOneID(id string) *BusinessFollowUserDeleteOne {
	builder := c.Delete().Where(businessfollowuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessFollowUserDeleteOne{builder}
}

// Query returns a query builder for BusinessFollowUser.
func (c *BusinessFollowUserClient) Query() *BusinessFollowUserQuery {
	return &BusinessFollowUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusinessFollowUser},
		inters: c.Interceptors(),
	}
}

// Get returns a BusinessFollowUser entity by its id.
func (c *BusinessFollowUserClient) Get(ctx context.Context, id string) (*BusinessFollowUser, error) {
	return c.Query().Where(businessfollowuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessFollowUserClient) GetX(ctx context.Context, id string) *BusinessFollowUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a BusinessFollowUser.
func (c *BusinessFollowUserClient) QueryBusiness(bfu *BusinessFollowUser) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowuser.Table, businessfollowuser.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowuser.BusinessTable, businessfollowuser.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(bfu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a BusinessFollowUser.
func (c *BusinessFollowUserClient) QueryUser(bfu *BusinessFollowUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowuser.Table, businessfollowuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowuser.UserTable, businessfollowuser.UserColumn),
		)
		fromV = sqlgraph.Neighbors(bfu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessFollowUserClient) Hooks() []Hook {
	return c.hooks.BusinessFollowUser
}

// Interceptors returns the client interceptors.
func (c *BusinessFollowUserClient) Interceptors() []Interceptor {
	return c.inters.BusinessFollowUser
}

func (c *BusinessFollowUserClient) mutate(ctx context.Context, m *BusinessFollowUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BusinessFollowUser mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryClient) MapCreateBulk(slice any, setFunc func(*CategoryCreate, int)) *CategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryCreateBulk{err: fmt.Errorf("calling to CategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id string) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id string) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id string) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id string) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategoryAssignments queries the categoryAssignments edge of a Category.
func (c *CategoryClient) QueryCategoryAssignments(ca *Category) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.CategoryAssignmentsTable, category.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaceInventories queries the place_inventories edge of a Category.
func (c *CategoryClient) QueryPlaceInventories(ca *Category) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.PlaceInventoriesTable, category.PlaceInventoriesColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Category.
func (c *CategoryClient) QueryMedia(ca *Category) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, category.MediaTable, category.MediaPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a Category.
func (c *CategoryClient) QueryMenus(ca *Category) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, category.MenusTable, category.MenusPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// CategoryAssignmentClient is a client for the CategoryAssignment schema.
type CategoryAssignmentClient struct {
	config
}

// NewCategoryAssignmentClient returns a client for the CategoryAssignment from the given config.
func NewCategoryAssignmentClient(c config) *CategoryAssignmentClient {
	return &CategoryAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `categoryassignment.Hooks(f(g(h())))`.
func (c *CategoryAssignmentClient) Use(hooks ...Hook) {
	c.hooks.CategoryAssignment = append(c.hooks.CategoryAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `categoryassignment.Intercept(f(g(h())))`.
func (c *CategoryAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.CategoryAssignment = append(c.inters.CategoryAssignment, interceptors...)
}

// Create returns a builder for creating a CategoryAssignment entity.
func (c *CategoryAssignmentClient) Create() *CategoryAssignmentCreate {
	mutation := newCategoryAssignmentMutation(c.config, OpCreate)
	return &CategoryAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CategoryAssignment entities.
func (c *CategoryAssignmentClient) CreateBulk(builders ...*CategoryAssignmentCreate) *CategoryAssignmentCreateBulk {
	return &CategoryAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryAssignmentClient) MapCreateBulk(slice any, setFunc func(*CategoryAssignmentCreate, int)) *CategoryAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryAssignmentCreateBulk{err: fmt.Errorf("calling to CategoryAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CategoryAssignment.
func (c *CategoryAssignmentClient) Update() *CategoryAssignmentUpdate {
	mutation := newCategoryAssignmentMutation(c.config, OpUpdate)
	return &CategoryAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryAssignmentClient) UpdateOne(ca *CategoryAssignment) *CategoryAssignmentUpdateOne {
	mutation := newCategoryAssignmentMutation(c.config, OpUpdateOne, withCategoryAssignment(ca))
	return &CategoryAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryAssignmentClient) UpdateOneID(id string) *CategoryAssignmentUpdateOne {
	mutation := newCategoryAssignmentMutation(c.config, OpUpdateOne, withCategoryAssignmentID(id))
	return &CategoryAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CategoryAssignment.
func (c *CategoryAssignmentClient) Delete() *CategoryAssignmentDelete {
	mutation := newCategoryAssignmentMutation(c.config, OpDelete)
	return &CategoryAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryAssignmentClient) DeleteOne(ca *CategoryAssignment) *CategoryAssignmentDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryAssignmentClient) DeleteOneID(id string) *CategoryAssignmentDeleteOne {
	builder := c.Delete().Where(categoryassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryAssignmentDeleteOne{builder}
}

// Query returns a query builder for CategoryAssignment.
func (c *CategoryAssignmentClient) Query() *CategoryAssignmentQuery {
	return &CategoryAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategoryAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a CategoryAssignment entity by its id.
func (c *CategoryAssignmentClient) Get(ctx context.Context, id string) (*CategoryAssignment, error) {
	return c.Query().Where(categoryassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryAssignmentClient) GetX(ctx context.Context, id string) *CategoryAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryUser(ca *CategoryAssignment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.UserTable, categoryassignment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryBusiness(ca *CategoryAssignment) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.BusinessTable, categoryassignment.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryPlace(ca *CategoryAssignment) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.PlaceTable, categoryassignment.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the category edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryCategory(ca *CategoryAssignment) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.CategoryTable, categoryassignment.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryAssignmentClient) Hooks() []Hook {
	return c.hooks.CategoryAssignment
}

// Interceptors returns the client interceptors.
func (c *CategoryAssignmentClient) Interceptors() []Interceptor {
	return c.inters.CategoryAssignment
}

func (c *CategoryAssignmentClient) mutate(ctx context.Context, m *CategoryAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CategoryAssignment mutation op: %q", m.Op())
	}
}

// ChatClient is a client for the Chat schema.
type ChatClient struct {
	config
}

// NewChatClient returns a client for the Chat from the given config.
func NewChatClient(c config) *ChatClient {
	return &ChatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chat.Hooks(f(g(h())))`.
func (c *ChatClient) Use(hooks ...Hook) {
	c.hooks.Chat = append(c.hooks.Chat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chat.Intercept(f(g(h())))`.
func (c *ChatClient) Intercept(interceptors ...Interceptor) {
	c.inters.Chat = append(c.inters.Chat, interceptors...)
}

// Create returns a builder for creating a Chat entity.
func (c *ChatClient) Create() *ChatCreate {
	mutation := newChatMutation(c.config, OpCreate)
	return &ChatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Chat entities.
func (c *ChatClient) CreateBulk(builders ...*ChatCreate) *ChatCreateBulk {
	return &ChatCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChatClient) MapCreateBulk(slice any, setFunc func(*ChatCreate, int)) *ChatCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChatCreateBulk{err: fmt.Errorf("calling to ChatClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChatCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Chat.
func (c *ChatClient) Update() *ChatUpdate {
	mutation := newChatMutation(c.config, OpUpdate)
	return &ChatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChatClient) UpdateOne(ch *Chat) *ChatUpdateOne {
	mutation := newChatMutation(c.config, OpUpdateOne, withChat(ch))
	return &ChatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChatClient) UpdateOneID(id string) *ChatUpdateOne {
	mutation := newChatMutation(c.config, OpUpdateOne, withChatID(id))
	return &ChatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Chat.
func (c *ChatClient) Delete() *ChatDelete {
	mutation := newChatMutation(c.config, OpDelete)
	return &ChatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChatClient) DeleteOne(ch *Chat) *ChatDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChatClient) DeleteOneID(id string) *ChatDeleteOne {
	builder := c.Delete().Where(chat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChatDeleteOne{builder}
}

// Query returns a query builder for Chat.
func (c *ChatClient) Query() *ChatQuery {
	return &ChatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChat},
		inters: c.Interceptors(),
	}
}

// Get returns a Chat entity by its id.
func (c *ChatClient) Get(ctx context.Context, id string) (*Chat, error) {
	return c.Query().Where(chat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChatClient) GetX(ctx context.Context, id string) *Chat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ChatClient) Hooks() []Hook {
	return c.hooks.Chat
}

// Interceptors returns the client interceptors.
func (c *ChatClient) Interceptors() []Interceptor {
	return c.inters.Chat
}

func (c *ChatClient) mutate(ctx context.Context, m *ChatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Chat mutation op: %q", m.Op())
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommentClient) MapCreateBulk(slice any, setFunc func(*CommentCreate, int)) *CommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommentCreateBulk{err: fmt.Errorf("calling to CommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(co *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(co))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id string) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(co *Comment) *CommentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id string) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id string) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id string) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Comment.
func (c *CommentClient) QueryUser(co *Comment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.UserTable, comment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the post edge of a Comment.
func (c *CommentClient) QueryPost(co *Comment) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.PostTable, comment.PostColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentComment queries the parentComment edge of a Comment.
func (c *CommentClient) QueryParentComment(co *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.ParentCommentTable, comment.ParentCommentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a Comment.
func (c *CommentClient) QueryReplies(co *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, comment.RepliesTable, comment.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Comment.
func (c *CommentClient) QueryNotifications(co *Comment) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, comment.NotificationsTable, comment.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	return c.hooks.Comment
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	return c.inters.Comment
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Comment mutation op: %q", m.Op())
	}
}

// CustomBlockClient is a client for the CustomBlock schema.
type CustomBlockClient struct {
	config
}

// NewCustomBlockClient returns a client for the CustomBlock from the given config.
func NewCustomBlockClient(c config) *CustomBlockClient {
	return &CustomBlockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customblock.Hooks(f(g(h())))`.
func (c *CustomBlockClient) Use(hooks ...Hook) {
	c.hooks.CustomBlock = append(c.hooks.CustomBlock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customblock.Intercept(f(g(h())))`.
func (c *CustomBlockClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomBlock = append(c.inters.CustomBlock, interceptors...)
}

// Create returns a builder for creating a CustomBlock entity.
func (c *CustomBlockClient) Create() *CustomBlockCreate {
	mutation := newCustomBlockMutation(c.config, OpCreate)
	return &CustomBlockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomBlock entities.
func (c *CustomBlockClient) CreateBulk(builders ...*CustomBlockCreate) *CustomBlockCreateBulk {
	return &CustomBlockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomBlockClient) MapCreateBulk(slice any, setFunc func(*CustomBlockCreate, int)) *CustomBlockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomBlockCreateBulk{err: fmt.Errorf("calling to CustomBlockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomBlockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomBlockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomBlock.
func (c *CustomBlockClient) Update() *CustomBlockUpdate {
	mutation := newCustomBlockMutation(c.config, OpUpdate)
	return &CustomBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomBlockClient) UpdateOne(cb *CustomBlock) *CustomBlockUpdateOne {
	mutation := newCustomBlockMutation(c.config, OpUpdateOne, withCustomBlock(cb))
	return &CustomBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomBlockClient) UpdateOneID(id string) *CustomBlockUpdateOne {
	mutation := newCustomBlockMutation(c.config, OpUpdateOne, withCustomBlockID(id))
	return &CustomBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomBlock.
func (c *CustomBlockClient) Delete() *CustomBlockDelete {
	mutation := newCustomBlockMutation(c.config, OpDelete)
	return &CustomBlockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomBlockClient) DeleteOne(cb *CustomBlock) *CustomBlockDeleteOne {
	return c.DeleteOneID(cb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomBlockClient) DeleteOneID(id string) *CustomBlockDeleteOne {
	builder := c.Delete().Where(customblock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomBlockDeleteOne{builder}
}

// Query returns a query builder for CustomBlock.
func (c *CustomBlockClient) Query() *CustomBlockQuery {
	return &CustomBlockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomBlock},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomBlock entity by its id.
func (c *CustomBlockClient) Get(ctx context.Context, id string) (*CustomBlock, error) {
	return c.Query().Where(customblock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomBlockClient) GetX(ctx context.Context, id string) *CustomBlock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWebsite queries the website edge of a CustomBlock.
func (c *CustomBlockClient) QueryWebsite(cb *CustomBlock) *WebsiteQuery {
	query := (&WebsiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customblock.Table, customblock.FieldID, id),
			sqlgraph.To(website.Table, website.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customblock.WebsiteTable, customblock.WebsiteColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomBlockClient) Hooks() []Hook {
	return c.hooks.CustomBlock
}

// Interceptors returns the client interceptors.
func (c *CustomBlockClient) Interceptors() []Interceptor {
	return c.inters.CustomBlock
}

func (c *CustomBlockClient) mutate(ctx context.Context, m *CustomBlockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomBlockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomBlockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomBlock mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id string) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id string) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id string) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id string) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTickets queries the tickets edge of a Event.
func (c *EventClient) QueryTickets(e *Event) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.TicketsTable, event.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTicketOptions queries the ticketOptions edge of a Event.
func (c *EventClient) QueryTicketOptions(e *Event) *TicketOptionQuery {
	query := (&TicketOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(ticketoption.Table, ticketoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.TicketOptionsTable, event.TicketOptionsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Event.
func (c *EventClient) QueryPlace(e *Event) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.PlaceTable, event.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventCategories queries the event_categories edge of a Event.
func (c *EventClient) QueryEventCategories(e *Event) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventCategoriesTable, event.EventCategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventCategoryAssignments queries the event_category_assignments edge of a Event.
func (c *EventClient) QueryEventCategoryAssignments(e *Event) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventCategoryAssignmentsTable, event.EventCategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnerUser queries the ownerUser edge of a Event.
func (c *EventClient) QueryOwnerUser(e *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, event.OwnerUserTable, event.OwnerUserColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnerBusiness queries the ownerBusiness edge of a Event.
func (c *EventClient) QueryOwnerBusiness(e *Event) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.OwnerBusinessTable, event.OwnerBusinessColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserFollowers queries the userFollowers edge of a Event.
func (c *EventClient) QueryUserFollowers(e *Event) *UserFollowEventQuery {
	query := (&UserFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(userfollowevent.Table, userfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, event.UserFollowersTable, event.UserFollowersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessFollowers queries the businessFollowers edge of a Event.
func (c *EventClient) QueryBusinessFollowers(e *Event) *BusinessFollowEventQuery {
	query := (&BusinessFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(businessfollowevent.Table, businessfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, event.BusinessFollowersTable, event.BusinessFollowersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaqs queries the faqs edge of a Event.
func (c *EventClient) QueryFaqs(e *Event) *FAQQuery {
	query := (&FAQClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(faq.Table, faq.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.FaqsTable, event.FaqsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a Event.
func (c *EventClient) QueryRatings(e *Event) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.RatingsTable, event.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdditionalOrganizers queries the additional_organizers edge of a Event.
func (c *EventClient) QueryAdditionalOrganizers(e *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.AdditionalOrganizersTable, event.AdditionalOrganizersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Event.
func (c *EventClient) QueryMedia(e *Event) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.MediaTable, event.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventComments queries the event_comments edge of a Event.
func (c *EventClient) QueryEventComments(e *Event) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventCommentsTable, event.EventCommentsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventReviews queries the event_reviews edge of a Event.
func (c *EventClient) QueryEventReviews(e *Event) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventReviewsTable, event.EventReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPerformers queries the performers edge of a Event.
func (c *EventClient) QueryPerformers(e *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.PerformersTable, event.PerformersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventOrganizers queries the event_organizers edge of a Event.
func (c *EventClient) QueryEventOrganizers(e *Event) *EventOrganizerQuery {
	query := (&EventOrganizerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(eventorganizer.Table, eventorganizer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventOrganizersTable, event.EventOrganizersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	hooks := c.hooks.Event
	return append(hooks[:len(hooks):len(hooks)], event.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// EventOrganizerClient is a client for the EventOrganizer schema.
type EventOrganizerClient struct {
	config
}

// NewEventOrganizerClient returns a client for the EventOrganizer from the given config.
func NewEventOrganizerClient(c config) *EventOrganizerClient {
	return &EventOrganizerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventorganizer.Hooks(f(g(h())))`.
func (c *EventOrganizerClient) Use(hooks ...Hook) {
	c.hooks.EventOrganizer = append(c.hooks.EventOrganizer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventorganizer.Intercept(f(g(h())))`.
func (c *EventOrganizerClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventOrganizer = append(c.inters.EventOrganizer, interceptors...)
}

// Create returns a builder for creating a EventOrganizer entity.
func (c *EventOrganizerClient) Create() *EventOrganizerCreate {
	mutation := newEventOrganizerMutation(c.config, OpCreate)
	return &EventOrganizerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventOrganizer entities.
func (c *EventOrganizerClient) CreateBulk(builders ...*EventOrganizerCreate) *EventOrganizerCreateBulk {
	return &EventOrganizerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventOrganizerClient) MapCreateBulk(slice any, setFunc func(*EventOrganizerCreate, int)) *EventOrganizerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventOrganizerCreateBulk{err: fmt.Errorf("calling to EventOrganizerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventOrganizerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventOrganizerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventOrganizer.
func (c *EventOrganizerClient) Update() *EventOrganizerUpdate {
	mutation := newEventOrganizerMutation(c.config, OpUpdate)
	return &EventOrganizerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventOrganizerClient) UpdateOne(eo *EventOrganizer) *EventOrganizerUpdateOne {
	mutation := newEventOrganizerMutation(c.config, OpUpdateOne, withEventOrganizer(eo))
	return &EventOrganizerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventOrganizerClient) UpdateOneID(id string) *EventOrganizerUpdateOne {
	mutation := newEventOrganizerMutation(c.config, OpUpdateOne, withEventOrganizerID(id))
	return &EventOrganizerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventOrganizer.
func (c *EventOrganizerClient) Delete() *EventOrganizerDelete {
	mutation := newEventOrganizerMutation(c.config, OpDelete)
	return &EventOrganizerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventOrganizerClient) DeleteOne(eo *EventOrganizer) *EventOrganizerDeleteOne {
	return c.DeleteOneID(eo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventOrganizerClient) DeleteOneID(id string) *EventOrganizerDeleteOne {
	builder := c.Delete().Where(eventorganizer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventOrganizerDeleteOne{builder}
}

// Query returns a query builder for EventOrganizer.
func (c *EventOrganizerClient) Query() *EventOrganizerQuery {
	return &EventOrganizerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventOrganizer},
		inters: c.Interceptors(),
	}
}

// Get returns a EventOrganizer entity by its id.
func (c *EventOrganizerClient) Get(ctx context.Context, id string) (*EventOrganizer, error) {
	return c.Query().Where(eventorganizer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventOrganizerClient) GetX(ctx context.Context, id string) *EventOrganizer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a EventOrganizer.
func (c *EventOrganizerClient) QueryEvent(eo *EventOrganizer) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventorganizer.Table, eventorganizer.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventorganizer.EventTable, eventorganizer.EventColumn),
		)
		fromV = sqlgraph.Neighbors(eo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventOrganizerClient) Hooks() []Hook {
	return c.hooks.EventOrganizer
}

// Interceptors returns the client interceptors.
func (c *EventOrganizerClient) Interceptors() []Interceptor {
	return c.inters.EventOrganizer
}

func (c *EventOrganizerClient) mutate(ctx context.Context, m *EventOrganizerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventOrganizerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventOrganizerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventOrganizerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventOrganizerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventOrganizer mutation op: %q", m.Op())
	}
}

// FAQClient is a client for the FAQ schema.
type FAQClient struct {
	config
}

// NewFAQClient returns a client for the FAQ from the given config.
func NewFAQClient(c config) *FAQClient {
	return &FAQClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `faq.Hooks(f(g(h())))`.
func (c *FAQClient) Use(hooks ...Hook) {
	c.hooks.FAQ = append(c.hooks.FAQ, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `faq.Intercept(f(g(h())))`.
func (c *FAQClient) Intercept(interceptors ...Interceptor) {
	c.inters.FAQ = append(c.inters.FAQ, interceptors...)
}

// Create returns a builder for creating a FAQ entity.
func (c *FAQClient) Create() *FAQCreate {
	mutation := newFAQMutation(c.config, OpCreate)
	return &FAQCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FAQ entities.
func (c *FAQClient) CreateBulk(builders ...*FAQCreate) *FAQCreateBulk {
	return &FAQCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FAQClient) MapCreateBulk(slice any, setFunc func(*FAQCreate, int)) *FAQCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FAQCreateBulk{err: fmt.Errorf("calling to FAQClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FAQCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FAQCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FAQ.
func (c *FAQClient) Update() *FAQUpdate {
	mutation := newFAQMutation(c.config, OpUpdate)
	return &FAQUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FAQClient) UpdateOne(f *FAQ) *FAQUpdateOne {
	mutation := newFAQMutation(c.config, OpUpdateOne, withFAQ(f))
	return &FAQUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FAQClient) UpdateOneID(id string) *FAQUpdateOne {
	mutation := newFAQMutation(c.config, OpUpdateOne, withFAQID(id))
	return &FAQUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FAQ.
func (c *FAQClient) Delete() *FAQDelete {
	mutation := newFAQMutation(c.config, OpDelete)
	return &FAQDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FAQClient) DeleteOne(f *FAQ) *FAQDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FAQClient) DeleteOneID(id string) *FAQDeleteOne {
	builder := c.Delete().Where(faq.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FAQDeleteOne{builder}
}

// Query returns a query builder for FAQ.
func (c *FAQClient) Query() *FAQQuery {
	return &FAQQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFAQ},
		inters: c.Interceptors(),
	}
}

// Get returns a FAQ entity by its id.
func (c *FAQClient) Get(ctx context.Context, id string) (*FAQ, error) {
	return c.Query().Where(faq.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FAQClient) GetX(ctx context.Context, id string) *FAQ {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a FAQ.
func (c *FAQClient) QueryBusiness(f *FAQ) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faq.Table, faq.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, faq.BusinessTable, faq.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a FAQ.
func (c *FAQClient) QueryPlace(f *FAQ) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faq.Table, faq.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, faq.PlaceTable, faq.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a FAQ.
func (c *FAQClient) QueryEvent(f *FAQ) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faq.Table, faq.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, faq.EventTable, faq.EventPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FAQClient) Hooks() []Hook {
	return c.hooks.FAQ
}

// Interceptors returns the client interceptors.
func (c *FAQClient) Interceptors() []Interceptor {
	return c.inters.FAQ
}

func (c *FAQClient) mutate(ctx context.Context, m *FAQMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FAQCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FAQUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FAQUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FAQDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FAQ mutation op: %q", m.Op())
	}
}

// FeatureReleaseClient is a client for the FeatureRelease schema.
type FeatureReleaseClient struct {
	config
}

// NewFeatureReleaseClient returns a client for the FeatureRelease from the given config.
func NewFeatureReleaseClient(c config) *FeatureReleaseClient {
	return &FeatureReleaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `featurerelease.Hooks(f(g(h())))`.
func (c *FeatureReleaseClient) Use(hooks ...Hook) {
	c.hooks.FeatureRelease = append(c.hooks.FeatureRelease, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `featurerelease.Intercept(f(g(h())))`.
func (c *FeatureReleaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.FeatureRelease = append(c.inters.FeatureRelease, interceptors...)
}

// Create returns a builder for creating a FeatureRelease entity.
func (c *FeatureReleaseClient) Create() *FeatureReleaseCreate {
	mutation := newFeatureReleaseMutation(c.config, OpCreate)
	return &FeatureReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FeatureRelease entities.
func (c *FeatureReleaseClient) CreateBulk(builders ...*FeatureReleaseCreate) *FeatureReleaseCreateBulk {
	return &FeatureReleaseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeatureReleaseClient) MapCreateBulk(slice any, setFunc func(*FeatureReleaseCreate, int)) *FeatureReleaseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeatureReleaseCreateBulk{err: fmt.Errorf("calling to FeatureReleaseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeatureReleaseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeatureReleaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FeatureRelease.
func (c *FeatureReleaseClient) Update() *FeatureReleaseUpdate {
	mutation := newFeatureReleaseMutation(c.config, OpUpdate)
	return &FeatureReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeatureReleaseClient) UpdateOne(fr *FeatureRelease) *FeatureReleaseUpdateOne {
	mutation := newFeatureReleaseMutation(c.config, OpUpdateOne, withFeatureRelease(fr))
	return &FeatureReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeatureReleaseClient) UpdateOneID(id string) *FeatureReleaseUpdateOne {
	mutation := newFeatureReleaseMutation(c.config, OpUpdateOne, withFeatureReleaseID(id))
	return &FeatureReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FeatureRelease.
func (c *FeatureReleaseClient) Delete() *FeatureReleaseDelete {
	mutation := newFeatureReleaseMutation(c.config, OpDelete)
	return &FeatureReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeatureReleaseClient) DeleteOne(fr *FeatureRelease) *FeatureReleaseDeleteOne {
	return c.DeleteOneID(fr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeatureReleaseClient) DeleteOneID(id string) *FeatureReleaseDeleteOne {
	builder := c.Delete().Where(featurerelease.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeatureReleaseDeleteOne{builder}
}

// Query returns a query builder for FeatureRelease.
func (c *FeatureReleaseClient) Query() *FeatureReleaseQuery {
	return &FeatureReleaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeatureRelease},
		inters: c.Interceptors(),
	}
}

// Get returns a FeatureRelease entity by its id.
func (c *FeatureReleaseClient) Get(ctx context.Context, id string) (*FeatureRelease, error) {
	return c.Query().Where(featurerelease.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeatureReleaseClient) GetX(ctx context.Context, id string) *FeatureRelease {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FeatureReleaseClient) Hooks() []Hook {
	return c.hooks.FeatureRelease
}

// Interceptors returns the client interceptors.
func (c *FeatureReleaseClient) Interceptors() []Interceptor {
	return c.inters.FeatureRelease
}

func (c *FeatureReleaseClient) mutate(ctx context.Context, m *FeatureReleaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeatureReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeatureReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeatureReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeatureReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FeatureRelease mutation op: %q", m.Op())
	}
}

// FitnessClient is a client for the Fitness schema.
type FitnessClient struct {
	config
}

// NewFitnessClient returns a client for the Fitness from the given config.
func NewFitnessClient(c config) *FitnessClient {
	return &FitnessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fitness.Hooks(f(g(h())))`.
func (c *FitnessClient) Use(hooks ...Hook) {
	c.hooks.Fitness = append(c.hooks.Fitness, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fitness.Intercept(f(g(h())))`.
func (c *FitnessClient) Intercept(interceptors ...Interceptor) {
	c.inters.Fitness = append(c.inters.Fitness, interceptors...)
}

// Create returns a builder for creating a Fitness entity.
func (c *FitnessClient) Create() *FitnessCreate {
	mutation := newFitnessMutation(c.config, OpCreate)
	return &FitnessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Fitness entities.
func (c *FitnessClient) CreateBulk(builders ...*FitnessCreate) *FitnessCreateBulk {
	return &FitnessCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FitnessClient) MapCreateBulk(slice any, setFunc func(*FitnessCreate, int)) *FitnessCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FitnessCreateBulk{err: fmt.Errorf("calling to FitnessClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FitnessCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FitnessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Fitness.
func (c *FitnessClient) Update() *FitnessUpdate {
	mutation := newFitnessMutation(c.config, OpUpdate)
	return &FitnessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FitnessClient) UpdateOne(f *Fitness) *FitnessUpdateOne {
	mutation := newFitnessMutation(c.config, OpUpdateOne, withFitness(f))
	return &FitnessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FitnessClient) UpdateOneID(id string) *FitnessUpdateOne {
	mutation := newFitnessMutation(c.config, OpUpdateOne, withFitnessID(id))
	return &FitnessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fitness.
func (c *FitnessClient) Delete() *FitnessDelete {
	mutation := newFitnessMutation(c.config, OpDelete)
	return &FitnessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FitnessClient) DeleteOne(f *Fitness) *FitnessDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FitnessClient) DeleteOneID(id string) *FitnessDeleteOne {
	builder := c.Delete().Where(fitness.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FitnessDeleteOne{builder}
}

// Query returns a query builder for Fitness.
func (c *FitnessClient) Query() *FitnessQuery {
	return &FitnessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFitness},
		inters: c.Interceptors(),
	}
}

// Get returns a Fitness entity by its id.
func (c *FitnessClient) Get(ctx context.Context, id string) (*Fitness, error) {
	return c.Query().Where(fitness.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FitnessClient) GetX(ctx context.Context, id string) *Fitness {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FitnessClient) Hooks() []Hook {
	return c.hooks.Fitness
}

// Interceptors returns the client interceptors.
func (c *FitnessClient) Interceptors() []Interceptor {
	return c.inters.Fitness
}

func (c *FitnessClient) mutate(ctx context.Context, m *FitnessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FitnessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FitnessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FitnessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FitnessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Fitness mutation op: %q", m.Op())
	}
}

// HelpClient is a client for the Help schema.
type HelpClient struct {
	config
}

// NewHelpClient returns a client for the Help from the given config.
func NewHelpClient(c config) *HelpClient {
	return &HelpClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `help.Hooks(f(g(h())))`.
func (c *HelpClient) Use(hooks ...Hook) {
	c.hooks.Help = append(c.hooks.Help, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `help.Intercept(f(g(h())))`.
func (c *HelpClient) Intercept(interceptors ...Interceptor) {
	c.inters.Help = append(c.inters.Help, interceptors...)
}

// Create returns a builder for creating a Help entity.
func (c *HelpClient) Create() *HelpCreate {
	mutation := newHelpMutation(c.config, OpCreate)
	return &HelpCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Help entities.
func (c *HelpClient) CreateBulk(builders ...*HelpCreate) *HelpCreateBulk {
	return &HelpCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HelpClient) MapCreateBulk(slice any, setFunc func(*HelpCreate, int)) *HelpCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HelpCreateBulk{err: fmt.Errorf("calling to HelpClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HelpCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HelpCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Help.
func (c *HelpClient) Update() *HelpUpdate {
	mutation := newHelpMutation(c.config, OpUpdate)
	return &HelpUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HelpClient) UpdateOne(h *Help) *HelpUpdateOne {
	mutation := newHelpMutation(c.config, OpUpdateOne, withHelp(h))
	return &HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HelpClient) UpdateOneID(id string) *HelpUpdateOne {
	mutation := newHelpMutation(c.config, OpUpdateOne, withHelpID(id))
	return &HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Help.
func (c *HelpClient) Delete() *HelpDelete {
	mutation := newHelpMutation(c.config, OpDelete)
	return &HelpDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HelpClient) DeleteOne(h *Help) *HelpDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HelpClient) DeleteOneID(id string) *HelpDeleteOne {
	builder := c.Delete().Where(help.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HelpDeleteOne{builder}
}

// Query returns a query builder for Help.
func (c *HelpClient) Query() *HelpQuery {
	return &HelpQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHelp},
		inters: c.Interceptors(),
	}
}

// Get returns a Help entity by its id.
func (c *HelpClient) Get(ctx context.Context, id string) (*Help, error) {
	return c.Query().Where(help.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HelpClient) GetX(ctx context.Context, id string) *Help {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Help.
func (c *HelpClient) QueryUser(h *Help) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(help.Table, help.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, help.UserTable, help.UserColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HelpClient) Hooks() []Hook {
	return c.hooks.Help
}

// Interceptors returns the client interceptors.
func (c *HelpClient) Interceptors() []Interceptor {
	return c.inters.Help
}

func (c *HelpClient) mutate(ctx context.Context, m *HelpMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HelpCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HelpUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HelpDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Help mutation op: %q", m.Op())
	}
}

// InventoryAttributeClient is a client for the InventoryAttribute schema.
type InventoryAttributeClient struct {
	config
}

// NewInventoryAttributeClient returns a client for the InventoryAttribute from the given config.
func NewInventoryAttributeClient(c config) *InventoryAttributeClient {
	return &InventoryAttributeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inventoryattribute.Hooks(f(g(h())))`.
func (c *InventoryAttributeClient) Use(hooks ...Hook) {
	c.hooks.InventoryAttribute = append(c.hooks.InventoryAttribute, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inventoryattribute.Intercept(f(g(h())))`.
func (c *InventoryAttributeClient) Intercept(interceptors ...Interceptor) {
	c.inters.InventoryAttribute = append(c.inters.InventoryAttribute, interceptors...)
}

// Create returns a builder for creating a InventoryAttribute entity.
func (c *InventoryAttributeClient) Create() *InventoryAttributeCreate {
	mutation := newInventoryAttributeMutation(c.config, OpCreate)
	return &InventoryAttributeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InventoryAttribute entities.
func (c *InventoryAttributeClient) CreateBulk(builders ...*InventoryAttributeCreate) *InventoryAttributeCreateBulk {
	return &InventoryAttributeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InventoryAttributeClient) MapCreateBulk(slice any, setFunc func(*InventoryAttributeCreate, int)) *InventoryAttributeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InventoryAttributeCreateBulk{err: fmt.Errorf("calling to InventoryAttributeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InventoryAttributeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InventoryAttributeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InventoryAttribute.
func (c *InventoryAttributeClient) Update() *InventoryAttributeUpdate {
	mutation := newInventoryAttributeMutation(c.config, OpUpdate)
	return &InventoryAttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InventoryAttributeClient) UpdateOne(ia *InventoryAttribute) *InventoryAttributeUpdateOne {
	mutation := newInventoryAttributeMutation(c.config, OpUpdateOne, withInventoryAttribute(ia))
	return &InventoryAttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InventoryAttributeClient) UpdateOneID(id string) *InventoryAttributeUpdateOne {
	mutation := newInventoryAttributeMutation(c.config, OpUpdateOne, withInventoryAttributeID(id))
	return &InventoryAttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InventoryAttribute.
func (c *InventoryAttributeClient) Delete() *InventoryAttributeDelete {
	mutation := newInventoryAttributeMutation(c.config, OpDelete)
	return &InventoryAttributeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InventoryAttributeClient) DeleteOne(ia *InventoryAttribute) *InventoryAttributeDeleteOne {
	return c.DeleteOneID(ia.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InventoryAttributeClient) DeleteOneID(id string) *InventoryAttributeDeleteOne {
	builder := c.Delete().Where(inventoryattribute.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InventoryAttributeDeleteOne{builder}
}

// Query returns a query builder for InventoryAttribute.
func (c *InventoryAttributeClient) Query() *InventoryAttributeQuery {
	return &InventoryAttributeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInventoryAttribute},
		inters: c.Interceptors(),
	}
}

// Get returns a InventoryAttribute entity by its id.
func (c *InventoryAttributeClient) Get(ctx context.Context, id string) (*InventoryAttribute, error) {
	return c.Query().Where(inventoryattribute.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InventoryAttributeClient) GetX(ctx context.Context, id string) *InventoryAttribute {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInventoryType queries the inventory_type edge of a InventoryAttribute.
func (c *InventoryAttributeClient) QueryInventoryType(ia *InventoryAttribute) *InventoryTypeQuery {
	query := (&InventoryTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ia.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventoryattribute.Table, inventoryattribute.FieldID, id),
			sqlgraph.To(inventorytype.Table, inventorytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inventoryattribute.InventoryTypeTable, inventoryattribute.InventoryTypeColumn),
		)
		fromV = sqlgraph.Neighbors(ia.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaceInventoryAttributes queries the place_inventory_attributes edge of a InventoryAttribute.
func (c *InventoryAttributeClient) QueryPlaceInventoryAttributes(ia *InventoryAttribute) *PlaceInventoryAttributeQuery {
	query := (&PlaceInventoryAttributeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ia.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventoryattribute.Table, inventoryattribute.FieldID, id),
			sqlgraph.To(placeinventoryattribute.Table, placeinventoryattribute.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, inventoryattribute.PlaceInventoryAttributesTable, inventoryattribute.PlaceInventoryAttributesColumn),
		)
		fromV = sqlgraph.Neighbors(ia.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InventoryAttributeClient) Hooks() []Hook {
	return c.hooks.InventoryAttribute
}

// Interceptors returns the client interceptors.
func (c *InventoryAttributeClient) Interceptors() []Interceptor {
	return c.inters.InventoryAttribute
}

func (c *InventoryAttributeClient) mutate(ctx context.Context, m *InventoryAttributeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InventoryAttributeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InventoryAttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InventoryAttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InventoryAttributeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InventoryAttribute mutation op: %q", m.Op())
	}
}

// InventoryTypeClient is a client for the InventoryType schema.
type InventoryTypeClient struct {
	config
}

// NewInventoryTypeClient returns a client for the InventoryType from the given config.
func NewInventoryTypeClient(c config) *InventoryTypeClient {
	return &InventoryTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inventorytype.Hooks(f(g(h())))`.
func (c *InventoryTypeClient) Use(hooks ...Hook) {
	c.hooks.InventoryType = append(c.hooks.InventoryType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inventorytype.Intercept(f(g(h())))`.
func (c *InventoryTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.InventoryType = append(c.inters.InventoryType, interceptors...)
}

// Create returns a builder for creating a InventoryType entity.
func (c *InventoryTypeClient) Create() *InventoryTypeCreate {
	mutation := newInventoryTypeMutation(c.config, OpCreate)
	return &InventoryTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InventoryType entities.
func (c *InventoryTypeClient) CreateBulk(builders ...*InventoryTypeCreate) *InventoryTypeCreateBulk {
	return &InventoryTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InventoryTypeClient) MapCreateBulk(slice any, setFunc func(*InventoryTypeCreate, int)) *InventoryTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InventoryTypeCreateBulk{err: fmt.Errorf("calling to InventoryTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InventoryTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InventoryTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InventoryType.
func (c *InventoryTypeClient) Update() *InventoryTypeUpdate {
	mutation := newInventoryTypeMutation(c.config, OpUpdate)
	return &InventoryTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InventoryTypeClient) UpdateOne(it *InventoryType) *InventoryTypeUpdateOne {
	mutation := newInventoryTypeMutation(c.config, OpUpdateOne, withInventoryType(it))
	return &InventoryTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InventoryTypeClient) UpdateOneID(id string) *InventoryTypeUpdateOne {
	mutation := newInventoryTypeMutation(c.config, OpUpdateOne, withInventoryTypeID(id))
	return &InventoryTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InventoryType.
func (c *InventoryTypeClient) Delete() *InventoryTypeDelete {
	mutation := newInventoryTypeMutation(c.config, OpDelete)
	return &InventoryTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InventoryTypeClient) DeleteOne(it *InventoryType) *InventoryTypeDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InventoryTypeClient) DeleteOneID(id string) *InventoryTypeDeleteOne {
	builder := c.Delete().Where(inventorytype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InventoryTypeDeleteOne{builder}
}

// Query returns a query builder for InventoryType.
func (c *InventoryTypeClient) Query() *InventoryTypeQuery {
	return &InventoryTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInventoryType},
		inters: c.Interceptors(),
	}
}

// Get returns a InventoryType entity by its id.
func (c *InventoryTypeClient) Get(ctx context.Context, id string) (*InventoryType, error) {
	return c.Query().Where(inventorytype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InventoryTypeClient) GetX(ctx context.Context, id string) *InventoryType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttributes queries the attributes edge of a InventoryType.
func (c *InventoryTypeClient) QueryAttributes(it *InventoryType) *InventoryAttributeQuery {
	query := (&InventoryAttributeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventorytype.Table, inventorytype.FieldID, id),
			sqlgraph.To(inventoryattribute.Table, inventoryattribute.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, inventorytype.AttributesTable, inventorytype.AttributesColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaceInventories queries the place_inventories edge of a InventoryType.
func (c *InventoryTypeClient) QueryPlaceInventories(it *InventoryType) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventorytype.Table, inventorytype.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, inventorytype.PlaceInventoriesTable, inventorytype.PlaceInventoriesColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InventoryTypeClient) Hooks() []Hook {
	return c.hooks.InventoryType
}

// Interceptors returns the client interceptors.
func (c *InventoryTypeClient) Interceptors() []Interceptor {
	return c.inters.InventoryType
}

func (c *InventoryTypeClient) mutate(ctx context.Context, m *InventoryTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InventoryTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InventoryTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InventoryTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InventoryTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InventoryType mutation op: %q", m.Op())
	}
}

// LikeClient is a client for the Like schema.
type LikeClient struct {
	config
}

// NewLikeClient returns a client for the Like from the given config.
func NewLikeClient(c config) *LikeClient {
	return &LikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `like.Hooks(f(g(h())))`.
func (c *LikeClient) Use(hooks ...Hook) {
	c.hooks.Like = append(c.hooks.Like, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `like.Intercept(f(g(h())))`.
func (c *LikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Like = append(c.inters.Like, interceptors...)
}

// Create returns a builder for creating a Like entity.
func (c *LikeClient) Create() *LikeCreate {
	mutation := newLikeMutation(c.config, OpCreate)
	return &LikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Like entities.
func (c *LikeClient) CreateBulk(builders ...*LikeCreate) *LikeCreateBulk {
	return &LikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LikeClient) MapCreateBulk(slice any, setFunc func(*LikeCreate, int)) *LikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LikeCreateBulk{err: fmt.Errorf("calling to LikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Like.
func (c *LikeClient) Update() *LikeUpdate {
	mutation := newLikeMutation(c.config, OpUpdate)
	return &LikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LikeClient) UpdateOne(l *Like) *LikeUpdateOne {
	mutation := newLikeMutation(c.config, OpUpdateOne, withLike(l))
	return &LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LikeClient) UpdateOneID(id string) *LikeUpdateOne {
	mutation := newLikeMutation(c.config, OpUpdateOne, withLikeID(id))
	return &LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Like.
func (c *LikeClient) Delete() *LikeDelete {
	mutation := newLikeMutation(c.config, OpDelete)
	return &LikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LikeClient) DeleteOne(l *Like) *LikeDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LikeClient) DeleteOneID(id string) *LikeDeleteOne {
	builder := c.Delete().Where(like.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LikeDeleteOne{builder}
}

// Query returns a query builder for Like.
func (c *LikeClient) Query() *LikeQuery {
	return &LikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLike},
		inters: c.Interceptors(),
	}
}

// Get returns a Like entity by its id.
func (c *LikeClient) Get(ctx context.Context, id string) (*Like, error) {
	return c.Query().Where(like.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LikeClient) GetX(ctx context.Context, id string) *Like {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Like.
func (c *LikeClient) QueryUser(l *Like) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, like.UserTable, like.UserColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReview queries the review edge of a Like.
func (c *LikeClient) QueryReview(l *Like) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, like.ReviewTable, like.ReviewColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Like.
func (c *LikeClient) QueryMedia(l *Like) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, like.MediaTable, like.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the post edge of a Like.
func (c *LikeClient) QueryPost(l *Like) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, like.PostTable, like.PostColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LikeClient) Hooks() []Hook {
	return c.hooks.Like
}

// Interceptors returns the client interceptors.
func (c *LikeClient) Interceptors() []Interceptor {
	return c.inters.Like
}

func (c *LikeClient) mutate(ctx context.Context, m *LikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Like mutation op: %q", m.Op())
	}
}

// MediaClient is a client for the Media schema.
type MediaClient struct {
	config
}

// NewMediaClient returns a client for the Media from the given config.
func NewMediaClient(c config) *MediaClient {
	return &MediaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `media.Hooks(f(g(h())))`.
func (c *MediaClient) Use(hooks ...Hook) {
	c.hooks.Media = append(c.hooks.Media, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `media.Intercept(f(g(h())))`.
func (c *MediaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Media = append(c.inters.Media, interceptors...)
}

// Create returns a builder for creating a Media entity.
func (c *MediaClient) Create() *MediaCreate {
	mutation := newMediaMutation(c.config, OpCreate)
	return &MediaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Media entities.
func (c *MediaClient) CreateBulk(builders ...*MediaCreate) *MediaCreateBulk {
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MediaClient) MapCreateBulk(slice any, setFunc func(*MediaCreate, int)) *MediaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MediaCreateBulk{err: fmt.Errorf("calling to MediaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MediaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Media.
func (c *MediaClient) Update() *MediaUpdate {
	mutation := newMediaMutation(c.config, OpUpdate)
	return &MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediaClient) UpdateOne(m *Media) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMedia(m))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediaClient) UpdateOneID(id string) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMediaID(id))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Media.
func (c *MediaClient) Delete() *MediaDelete {
	mutation := newMediaMutation(c.config, OpDelete)
	return &MediaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediaClient) DeleteOne(m *Media) *MediaDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediaClient) DeleteOneID(id string) *MediaDeleteOne {
	builder := c.Delete().Where(media.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediaDeleteOne{builder}
}

// Query returns a query builder for Media.
func (c *MediaClient) Query() *MediaQuery {
	return &MediaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedia},
		inters: c.Interceptors(),
	}
}

// Get returns a Media entity by its id.
func (c *MediaClient) Get(ctx context.Context, id string) (*Media, error) {
	return c.Query().Where(media.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediaClient) GetX(ctx context.Context, id string) *Media {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPost queries the post edge of a Media.
func (c *MediaClient) QueryPost(m *Media) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.PostTable, media.PostColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReview queries the review edge of a Media.
func (c *MediaClient) QueryReview(m *Media) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.ReviewTable, media.ReviewColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Media.
func (c *MediaClient) QueryCategories(m *Media) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, media.CategoriesTable, media.CategoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Media.
func (c *MediaClient) QueryPlace(m *Media) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, media.PlaceTable, media.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaceInventory queries the place_inventory edge of a Media.
func (c *MediaClient) QueryPlaceInventory(m *Media) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, media.PlaceInventoryTable, media.PlaceInventoryPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenu queries the menu edge of a Media.
func (c *MediaClient) QueryMenu(m *Media) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, media.MenuTable, media.MenuPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoomCategory queries the room_category edge of a Media.
func (c *MediaClient) QueryRoomCategory(m *Media) *RoomCategoryQuery {
	query := (&RoomCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(roomcategory.Table, roomcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, media.RoomCategoryTable, media.RoomCategoryPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoom queries the room edge of a Media.
func (c *MediaClient) QueryRoom(m *Media) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, media.RoomTable, media.RoomPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the plan edge of a Media.
func (c *MediaClient) QueryPlan(m *Media) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.PlanTable, media.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MediaClient) Hooks() []Hook {
	return c.hooks.Media
}

// Interceptors returns the client interceptors.
func (c *MediaClient) Interceptors() []Interceptor {
	return c.inters.Media
}

func (c *MediaClient) mutate(ctx context.Context, m *MediaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Media mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuClient) MapCreateBulk(slice any, setFunc func(*MenuCreate, int)) *MenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuCreateBulk{err: fmt.Errorf("calling to MenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id string) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id string) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id string) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id string) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a Menu.
func (c *MenuClient) QueryPlace(m *Menu) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, menu.PlaceTable, menu.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Menu.
func (c *MenuClient) QueryCategories(m *Menu) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, menu.CategoriesTable, menu.CategoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenuItems queries the menu_items edge of a Menu.
func (c *MenuClient) QueryMenuItems(m *Menu) *MenuItemQuery {
	query := (&MenuItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menuitem.Table, menuitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, menu.MenuItemsTable, menu.MenuItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Menu.
func (c *MenuClient) QueryMedia(m *Menu) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, menu.MediaTable, menu.MediaPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a Menu.
func (c *MenuClient) QueryCreatedBy(m *Menu) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, menu.CreatedByTable, menu.CreatedByPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdatedBy queries the updated_by edge of a Menu.
func (c *MenuClient) QueryUpdatedBy(m *Menu) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, menu.UpdatedByTable, menu.UpdatedByPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// MenuItemClient is a client for the MenuItem schema.
type MenuItemClient struct {
	config
}

// NewMenuItemClient returns a client for the MenuItem from the given config.
func NewMenuItemClient(c config) *MenuItemClient {
	return &MenuItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menuitem.Hooks(f(g(h())))`.
func (c *MenuItemClient) Use(hooks ...Hook) {
	c.hooks.MenuItem = append(c.hooks.MenuItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menuitem.Intercept(f(g(h())))`.
func (c *MenuItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.MenuItem = append(c.inters.MenuItem, interceptors...)
}

// Create returns a builder for creating a MenuItem entity.
func (c *MenuItemClient) Create() *MenuItemCreate {
	mutation := newMenuItemMutation(c.config, OpCreate)
	return &MenuItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MenuItem entities.
func (c *MenuItemClient) CreateBulk(builders ...*MenuItemCreate) *MenuItemCreateBulk {
	return &MenuItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuItemClient) MapCreateBulk(slice any, setFunc func(*MenuItemCreate, int)) *MenuItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuItemCreateBulk{err: fmt.Errorf("calling to MenuItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MenuItem.
func (c *MenuItemClient) Update() *MenuItemUpdate {
	mutation := newMenuItemMutation(c.config, OpUpdate)
	return &MenuItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuItemClient) UpdateOne(mi *MenuItem) *MenuItemUpdateOne {
	mutation := newMenuItemMutation(c.config, OpUpdateOne, withMenuItem(mi))
	return &MenuItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuItemClient) UpdateOneID(id string) *MenuItemUpdateOne {
	mutation := newMenuItemMutation(c.config, OpUpdateOne, withMenuItemID(id))
	return &MenuItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MenuItem.
func (c *MenuItemClient) Delete() *MenuItemDelete {
	mutation := newMenuItemMutation(c.config, OpDelete)
	return &MenuItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuItemClient) DeleteOne(mi *MenuItem) *MenuItemDeleteOne {
	return c.DeleteOneID(mi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuItemClient) DeleteOneID(id string) *MenuItemDeleteOne {
	builder := c.Delete().Where(menuitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuItemDeleteOne{builder}
}

// Query returns a query builder for MenuItem.
func (c *MenuItemClient) Query() *MenuItemQuery {
	return &MenuItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenuItem},
		inters: c.Interceptors(),
	}
}

// Get returns a MenuItem entity by its id.
func (c *MenuItemClient) Get(ctx context.Context, id string) (*MenuItem, error) {
	return c.Query().Where(menuitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuItemClient) GetX(ctx context.Context, id string) *MenuItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenu queries the menu edge of a MenuItem.
func (c *MenuItemClient) QueryMenu(mi *MenuItem) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuitem.Table, menuitem.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, menuitem.MenuTable, menuitem.MenuPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventory queries the inventory edge of a MenuItem.
func (c *MenuItemClient) QueryInventory(mi *MenuItem) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuitem.Table, menuitem.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, menuitem.InventoryTable, menuitem.InventoryColumn),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a MenuItem.
func (c *MenuItemClient) QueryMedia(mi *MenuItem) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuitem.Table, menuitem.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menuitem.MediaTable, menuitem.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderItems queries the order_items edge of a MenuItem.
func (c *MenuItemClient) QueryOrderItems(mi *MenuItem) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuitem.Table, menuitem.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, menuitem.OrderItemsTable, menuitem.OrderItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuItemClient) Hooks() []Hook {
	return c.hooks.MenuItem
}

// Interceptors returns the client interceptors.
func (c *MenuItemClient) Interceptors() []Interceptor {
	return c.inters.MenuItem
}

func (c *MenuItemClient) mutate(ctx context.Context, m *MenuItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MenuItem mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(n *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(n))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id string) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(n *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id string) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id string) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id string) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Notification.
func (c *NotificationClient) QueryUser(n *Notification) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.UserTable, notification.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessAccount queries the business_account edge of a Notification.
func (c *NotificationClient) QueryBusinessAccount(n *Notification) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.BusinessAccountTable, notification.BusinessAccountPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Notification.
func (c *NotificationClient) QueryPlace(n *Notification) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.PlaceTable, notification.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the post edge of a Notification.
func (c *NotificationClient) QueryPost(n *Notification) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.PostTable, notification.PostPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComment queries the comment edge of a Notification.
func (c *NotificationClient) QueryComment(n *Notification) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.CommentTable, notification.CommentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id string) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id string) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id string) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id string) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Order.
func (c *OrderClient) QueryUser(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.UserTable, order.UserColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderItems queries the order_items edge of a Order.
func (c *OrderClient) QueryOrderItems(o *Order) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, order.OrderItemsTable, order.OrderItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTable queries the table edge of a Order.
func (c *OrderClient) QueryTable(o *Order) *PlaceTableQuery {
	query := (&PlaceTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(placetable.Table, placetable.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, order.TableTable, order.TablePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderItemClient is a client for the OrderItem schema.
type OrderItemClient struct {
	config
}

// NewOrderItemClient returns a client for the OrderItem from the given config.
func NewOrderItemClient(c config) *OrderItemClient {
	return &OrderItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderitem.Hooks(f(g(h())))`.
func (c *OrderItemClient) Use(hooks ...Hook) {
	c.hooks.OrderItem = append(c.hooks.OrderItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderitem.Intercept(f(g(h())))`.
func (c *OrderItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderItem = append(c.inters.OrderItem, interceptors...)
}

// Create returns a builder for creating a OrderItem entity.
func (c *OrderItemClient) Create() *OrderItemCreate {
	mutation := newOrderItemMutation(c.config, OpCreate)
	return &OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderItem entities.
func (c *OrderItemClient) CreateBulk(builders ...*OrderItemCreate) *OrderItemCreateBulk {
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderItemClient) MapCreateBulk(slice any, setFunc func(*OrderItemCreate, int)) *OrderItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderItemCreateBulk{err: fmt.Errorf("calling to OrderItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderItem.
func (c *OrderItemClient) Update() *OrderItemUpdate {
	mutation := newOrderItemMutation(c.config, OpUpdate)
	return &OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderItemClient) UpdateOne(oi *OrderItem) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItem(oi))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderItemClient) UpdateOneID(id string) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItemID(id))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderItem.
func (c *OrderItemClient) Delete() *OrderItemDelete {
	mutation := newOrderItemMutation(c.config, OpDelete)
	return &OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderItemClient) DeleteOne(oi *OrderItem) *OrderItemDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderItemClient) DeleteOneID(id string) *OrderItemDeleteOne {
	builder := c.Delete().Where(orderitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderItemDeleteOne{builder}
}

// Query returns a query builder for OrderItem.
func (c *OrderItemClient) Query() *OrderItemQuery {
	return &OrderItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderItem entity by its id.
func (c *OrderItemClient) Get(ctx context.Context, id string) (*OrderItem, error) {
	return c.Query().Where(orderitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderItemClient) GetX(ctx context.Context, id string) *OrderItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderItem.
func (c *OrderItemClient) QueryOrder(oi *OrderItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, orderitem.OrderTable, orderitem.OrderPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenuItem queries the menu_item edge of a OrderItem.
func (c *OrderItemClient) QueryMenuItem(oi *OrderItem) *MenuItemQuery {
	query := (&MenuItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(menuitem.Table, menuitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, orderitem.MenuItemTable, orderitem.MenuItemPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderItemClient) Hooks() []Hook {
	return c.hooks.OrderItem
}

// Interceptors returns the client interceptors.
func (c *OrderItemClient) Interceptors() []Interceptor {
	return c.inters.OrderItem
}

func (c *OrderItemClient) mutate(ctx context.Context, m *OrderItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderItem mutation op: %q", m.Op())
	}
}

// PaymentClient is a client for the Payment schema.
type PaymentClient struct {
	config
}

// NewPaymentClient returns a client for the Payment from the given config.
func NewPaymentClient(c config) *PaymentClient {
	return &PaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payment.Hooks(f(g(h())))`.
func (c *PaymentClient) Use(hooks ...Hook) {
	c.hooks.Payment = append(c.hooks.Payment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `payment.Intercept(f(g(h())))`.
func (c *PaymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Payment = append(c.inters.Payment, interceptors...)
}

// Create returns a builder for creating a Payment entity.
func (c *PaymentClient) Create() *PaymentCreate {
	mutation := newPaymentMutation(c.config, OpCreate)
	return &PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Payment entities.
func (c *PaymentClient) CreateBulk(builders ...*PaymentCreate) *PaymentCreateBulk {
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentClient) MapCreateBulk(slice any, setFunc func(*PaymentCreate, int)) *PaymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentCreateBulk{err: fmt.Errorf("calling to PaymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Payment.
func (c *PaymentClient) Update() *PaymentUpdate {
	mutation := newPaymentMutation(c.config, OpUpdate)
	return &PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentClient) UpdateOne(pa *Payment) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPayment(pa))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentClient) UpdateOneID(id string) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPaymentID(id))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payment.
func (c *PaymentClient) Delete() *PaymentDelete {
	mutation := newPaymentMutation(c.config, OpDelete)
	return &PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentClient) DeleteOne(pa *Payment) *PaymentDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentClient) DeleteOneID(id string) *PaymentDeleteOne {
	builder := c.Delete().Where(payment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentDeleteOne{builder}
}

// Query returns a query builder for Payment.
func (c *PaymentClient) Query() *PaymentQuery {
	return &PaymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayment},
		inters: c.Interceptors(),
	}
}

// Get returns a Payment entity by its id.
func (c *PaymentClient) Get(ctx context.Context, id string) (*Payment, error) {
	return c.Query().Where(payment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentClient) GetX(ctx context.Context, id string) *Payment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentClient) Hooks() []Hook {
	return c.hooks.Payment
}

// Interceptors returns the client interceptors.
func (c *PaymentClient) Interceptors() []Interceptor {
	return c.inters.Payment
}

func (c *PaymentClient) mutate(ctx context.Context, m *PaymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Payment mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(pe *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(pe))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id string) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(pe *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id string) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id string) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id string) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStaffs queries the staffs edge of a Permission.
func (c *PermissionClient) QueryStaffs(pe *Permission) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.StaffsTable, permission.StaffsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	return c.hooks.Permission
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	return c.inters.Permission
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// PlaceClient is a client for the Place schema.
type PlaceClient struct {
	config
}

// NewPlaceClient returns a client for the Place from the given config.
func NewPlaceClient(c config) *PlaceClient {
	return &PlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `place.Hooks(f(g(h())))`.
func (c *PlaceClient) Use(hooks ...Hook) {
	c.hooks.Place = append(c.hooks.Place, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `place.Intercept(f(g(h())))`.
func (c *PlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Place = append(c.inters.Place, interceptors...)
}

// Create returns a builder for creating a Place entity.
func (c *PlaceClient) Create() *PlaceCreate {
	mutation := newPlaceMutation(c.config, OpCreate)
	return &PlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Place entities.
func (c *PlaceClient) CreateBulk(builders ...*PlaceCreate) *PlaceCreateBulk {
	return &PlaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlaceClient) MapCreateBulk(slice any, setFunc func(*PlaceCreate, int)) *PlaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlaceCreateBulk{err: fmt.Errorf("calling to PlaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Place.
func (c *PlaceClient) Update() *PlaceUpdate {
	mutation := newPlaceMutation(c.config, OpUpdate)
	return &PlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaceClient) UpdateOne(pl *Place) *PlaceUpdateOne {
	mutation := newPlaceMutation(c.config, OpUpdateOne, withPlace(pl))
	return &PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaceClient) UpdateOneID(id string) *PlaceUpdateOne {
	mutation := newPlaceMutation(c.config, OpUpdateOne, withPlaceID(id))
	return &PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Place.
func (c *PlaceClient) Delete() *PlaceDelete {
	mutation := newPlaceMutation(c.config, OpDelete)
	return &PlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlaceClient) DeleteOne(pl *Place) *PlaceDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlaceClient) DeleteOneID(id string) *PlaceDeleteOne {
	builder := c.Delete().Where(place.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaceDeleteOne{builder}
}

// Query returns a query builder for Place.
func (c *PlaceClient) Query() *PlaceQuery {
	return &PlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlace},
		inters: c.Interceptors(),
	}
}

// Get returns a Place entity by its id.
func (c *PlaceClient) Get(ctx context.Context, id string) (*Place, error) {
	return c.Query().Where(place.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaceClient) GetX(ctx context.Context, id string) *Place {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a Place.
func (c *PlaceClient) QueryBusiness(pl *Place) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, place.BusinessTable, place.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Place.
func (c *PlaceClient) QueryUsers(pl *Place) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, place.UsersTable, place.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Place.
func (c *PlaceClient) QueryReviews(pl *Place) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.ReviewsTable, place.ReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Place.
func (c *PlaceClient) QueryEvents(pl *Place) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.EventsTable, place.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAmenities queries the amenities edge of a Place.
func (c *PlaceClient) QueryAmenities(pl *Place) *AmenityQuery {
	query := (&AmenityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(amenity.Table, amenity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, place.AmenitiesTable, place.AmenitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a Place.
func (c *PlaceClient) QueryMenus(pl *Place) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.MenusTable, place.MenusPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedias queries the medias edge of a Place.
func (c *PlaceClient) QueryMedias(pl *Place) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.MediasTable, place.MediasPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRooms queries the rooms edge of a Place.
func (c *PlaceClient) QueryRooms(pl *Place) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.RoomsTable, place.RoomsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservations queries the reservations edge of a Place.
func (c *PlaceClient) QueryReservations(pl *Place) *ReservationQuery {
	query := (&ReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(reservation.Table, reservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.ReservationsTable, place.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Place.
func (c *PlaceClient) QueryBookings(pl *Place) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.BookingsTable, place.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Place.
func (c *PlaceClient) QueryCategories(pl *Place) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.CategoriesTable, place.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategoryAssignments queries the categoryAssignments edge of a Place.
func (c *PlaceClient) QueryCategoryAssignments(pl *Place) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.CategoryAssignmentsTable, place.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaqs queries the faqs edge of a Place.
func (c *PlaceClient) QueryFaqs(pl *Place) *FAQQuery {
	query := (&FAQClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(faq.Table, faq.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, place.FaqsTable, place.FaqsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedByUsers queries the likedByUsers edge of a Place.
func (c *PlaceClient) QueryLikedByUsers(pl *Place) *UserLikePlaceQuery {
	query := (&UserLikePlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(userlikeplace.Table, userlikeplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, place.LikedByUsersTable, place.LikedByUsersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerUsers queries the followerUsers edge of a Place.
func (c *PlaceClient) QueryFollowerUsers(pl *Place) *UserFollowPlaceQuery {
	query := (&UserFollowPlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(userfollowplace.Table, userfollowplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.FollowerUsersTable, place.FollowerUsersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a Place.
func (c *PlaceClient) QueryRatings(pl *Place) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.RatingsTable, place.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventories queries the inventories edge of a Place.
func (c *PlaceClient) QueryInventories(pl *Place) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.InventoriesTable, place.InventoriesColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Place.
func (c *PlaceClient) QueryNotifications(pl *Place) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.NotificationsTable, place.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTables queries the tables edge of a Place.
func (c *PlaceClient) QueryTables(pl *Place) *PlaceTableQuery {
	query := (&PlaceTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(placetable.Table, placetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.TablesTable, place.TablesColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffs queries the staffs edge of a Place.
func (c *PlaceClient) QueryStaffs(pl *Place) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.StaffsTable, place.StaffsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoomCategories queries the room_categories edge of a Place.
func (c *PlaceClient) QueryRoomCategories(pl *Place) *RoomCategoryQuery {
	query := (&RoomCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(roomcategory.Table, roomcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.RoomCategoriesTable, place.RoomCategoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlans queries the plans edge of a Place.
func (c *PlaceClient) QueryPlans(pl *Place) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, place.PlansTable, place.PlansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrainers queries the trainers edge of a Place.
func (c *PlaceClient) QueryTrainers(pl *Place) *TrainerQuery {
	query := (&TrainerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(trainer.Table, trainer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.TrainersTable, place.TrainersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Place.
func (c *PlaceClient) QueryMembers(pl *Place) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.MembersTable, place.MembersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegularUsers queries the regularUsers edge of a Place.
func (c *PlaceClient) QueryRegularUsers(pl *Place) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, place.RegularUsersTable, place.RegularUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaceClient) Hooks() []Hook {
	hooks := c.hooks.Place
	return append(hooks[:len(hooks):len(hooks)], place.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PlaceClient) Interceptors() []Interceptor {
	return c.inters.Place
}

func (c *PlaceClient) mutate(ctx context.Context, m *PlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Place mutation op: %q", m.Op())
	}
}

// PlaceInventoryClient is a client for the PlaceInventory schema.
type PlaceInventoryClient struct {
	config
}

// NewPlaceInventoryClient returns a client for the PlaceInventory from the given config.
func NewPlaceInventoryClient(c config) *PlaceInventoryClient {
	return &PlaceInventoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `placeinventory.Hooks(f(g(h())))`.
func (c *PlaceInventoryClient) Use(hooks ...Hook) {
	c.hooks.PlaceInventory = append(c.hooks.PlaceInventory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `placeinventory.Intercept(f(g(h())))`.
func (c *PlaceInventoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlaceInventory = append(c.inters.PlaceInventory, interceptors...)
}

// Create returns a builder for creating a PlaceInventory entity.
func (c *PlaceInventoryClient) Create() *PlaceInventoryCreate {
	mutation := newPlaceInventoryMutation(c.config, OpCreate)
	return &PlaceInventoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlaceInventory entities.
func (c *PlaceInventoryClient) CreateBulk(builders ...*PlaceInventoryCreate) *PlaceInventoryCreateBulk {
	return &PlaceInventoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlaceInventoryClient) MapCreateBulk(slice any, setFunc func(*PlaceInventoryCreate, int)) *PlaceInventoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlaceInventoryCreateBulk{err: fmt.Errorf("calling to PlaceInventoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlaceInventoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlaceInventoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlaceInventory.
func (c *PlaceInventoryClient) Update() *PlaceInventoryUpdate {
	mutation := newPlaceInventoryMutation(c.config, OpUpdate)
	return &PlaceInventoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaceInventoryClient) UpdateOne(pi *PlaceInventory) *PlaceInventoryUpdateOne {
	mutation := newPlaceInventoryMutation(c.config, OpUpdateOne, withPlaceInventory(pi))
	return &PlaceInventoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaceInventoryClient) UpdateOneID(id string) *PlaceInventoryUpdateOne {
	mutation := newPlaceInventoryMutation(c.config, OpUpdateOne, withPlaceInventoryID(id))
	return &PlaceInventoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlaceInventory.
func (c *PlaceInventoryClient) Delete() *PlaceInventoryDelete {
	mutation := newPlaceInventoryMutation(c.config, OpDelete)
	return &PlaceInventoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlaceInventoryClient) DeleteOne(pi *PlaceInventory) *PlaceInventoryDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlaceInventoryClient) DeleteOneID(id string) *PlaceInventoryDeleteOne {
	builder := c.Delete().Where(placeinventory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaceInventoryDeleteOne{builder}
}

// Query returns a query builder for PlaceInventory.
func (c *PlaceInventoryClient) Query() *PlaceInventoryQuery {
	return &PlaceInventoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlaceInventory},
		inters: c.Interceptors(),
	}
}

// Get returns a PlaceInventory entity by its id.
func (c *PlaceInventoryClient) Get(ctx context.Context, id string) (*PlaceInventory, error) {
	return c.Query().Where(placeinventory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaceInventoryClient) GetX(ctx context.Context, id string) *PlaceInventory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryPlace(pi *PlaceInventory) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placeinventory.PlaceTable, placeinventory.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventoryType queries the inventory_type edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryInventoryType(pi *PlaceInventory) *InventoryTypeQuery {
	query := (&InventoryTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(inventorytype.Table, inventorytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placeinventory.InventoryTypeTable, placeinventory.InventoryTypeColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttributes queries the attributes edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryAttributes(pi *PlaceInventory) *PlaceInventoryAttributeQuery {
	query := (&PlaceInventoryAttributeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(placeinventoryattribute.Table, placeinventoryattribute.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, placeinventory.AttributesTable, placeinventory.AttributesColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryMedia(pi *PlaceInventory) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, placeinventory.MediaTable, placeinventory.MediaPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactionHistories queries the transaction_histories edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryTransactionHistories(pi *PlaceInventory) *TransactionHistoryQuery {
	query := (&TransactionHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(transactionhistory.Table, transactionhistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, placeinventory.TransactionHistoriesTable, placeinventory.TransactionHistoriesColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservationBlocks queries the reservation_blocks edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryReservationBlocks(pi *PlaceInventory) *ReservationBlockQuery {
	query := (&ReservationBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(reservationblock.Table, reservationblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, placeinventory.ReservationBlocksTable, placeinventory.ReservationBlocksColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryBusiness(pi *PlaceInventory) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placeinventory.BusinessTable, placeinventory.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the category edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryCategory(pi *PlaceInventory) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placeinventory.CategoryTable, placeinventory.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenuItem queries the menu_item edge of a PlaceInventory.
func (c *PlaceInventoryClient) QueryMenuItem(pi *PlaceInventory) *MenuItemQuery {
	query := (&MenuItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventory.Table, placeinventory.FieldID, id),
			sqlgraph.To(menuitem.Table, menuitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, placeinventory.MenuItemTable, placeinventory.MenuItemColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaceInventoryClient) Hooks() []Hook {
	return c.hooks.PlaceInventory
}

// Interceptors returns the client interceptors.
func (c *PlaceInventoryClient) Interceptors() []Interceptor {
	return c.inters.PlaceInventory
}

func (c *PlaceInventoryClient) mutate(ctx context.Context, m *PlaceInventoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlaceInventoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlaceInventoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlaceInventoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlaceInventoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PlaceInventory mutation op: %q", m.Op())
	}
}

// PlaceInventoryAttributeClient is a client for the PlaceInventoryAttribute schema.
type PlaceInventoryAttributeClient struct {
	config
}

// NewPlaceInventoryAttributeClient returns a client for the PlaceInventoryAttribute from the given config.
func NewPlaceInventoryAttributeClient(c config) *PlaceInventoryAttributeClient {
	return &PlaceInventoryAttributeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `placeinventoryattribute.Hooks(f(g(h())))`.
func (c *PlaceInventoryAttributeClient) Use(hooks ...Hook) {
	c.hooks.PlaceInventoryAttribute = append(c.hooks.PlaceInventoryAttribute, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `placeinventoryattribute.Intercept(f(g(h())))`.
func (c *PlaceInventoryAttributeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlaceInventoryAttribute = append(c.inters.PlaceInventoryAttribute, interceptors...)
}

// Create returns a builder for creating a PlaceInventoryAttribute entity.
func (c *PlaceInventoryAttributeClient) Create() *PlaceInventoryAttributeCreate {
	mutation := newPlaceInventoryAttributeMutation(c.config, OpCreate)
	return &PlaceInventoryAttributeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlaceInventoryAttribute entities.
func (c *PlaceInventoryAttributeClient) CreateBulk(builders ...*PlaceInventoryAttributeCreate) *PlaceInventoryAttributeCreateBulk {
	return &PlaceInventoryAttributeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlaceInventoryAttributeClient) MapCreateBulk(slice any, setFunc func(*PlaceInventoryAttributeCreate, int)) *PlaceInventoryAttributeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlaceInventoryAttributeCreateBulk{err: fmt.Errorf("calling to PlaceInventoryAttributeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlaceInventoryAttributeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlaceInventoryAttributeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlaceInventoryAttribute.
func (c *PlaceInventoryAttributeClient) Update() *PlaceInventoryAttributeUpdate {
	mutation := newPlaceInventoryAttributeMutation(c.config, OpUpdate)
	return &PlaceInventoryAttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaceInventoryAttributeClient) UpdateOne(pia *PlaceInventoryAttribute) *PlaceInventoryAttributeUpdateOne {
	mutation := newPlaceInventoryAttributeMutation(c.config, OpUpdateOne, withPlaceInventoryAttribute(pia))
	return &PlaceInventoryAttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaceInventoryAttributeClient) UpdateOneID(id string) *PlaceInventoryAttributeUpdateOne {
	mutation := newPlaceInventoryAttributeMutation(c.config, OpUpdateOne, withPlaceInventoryAttributeID(id))
	return &PlaceInventoryAttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlaceInventoryAttribute.
func (c *PlaceInventoryAttributeClient) Delete() *PlaceInventoryAttributeDelete {
	mutation := newPlaceInventoryAttributeMutation(c.config, OpDelete)
	return &PlaceInventoryAttributeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlaceInventoryAttributeClient) DeleteOne(pia *PlaceInventoryAttribute) *PlaceInventoryAttributeDeleteOne {
	return c.DeleteOneID(pia.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlaceInventoryAttributeClient) DeleteOneID(id string) *PlaceInventoryAttributeDeleteOne {
	builder := c.Delete().Where(placeinventoryattribute.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaceInventoryAttributeDeleteOne{builder}
}

// Query returns a query builder for PlaceInventoryAttribute.
func (c *PlaceInventoryAttributeClient) Query() *PlaceInventoryAttributeQuery {
	return &PlaceInventoryAttributeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlaceInventoryAttribute},
		inters: c.Interceptors(),
	}
}

// Get returns a PlaceInventoryAttribute entity by its id.
func (c *PlaceInventoryAttributeClient) Get(ctx context.Context, id string) (*PlaceInventoryAttribute, error) {
	return c.Query().Where(placeinventoryattribute.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaceInventoryAttributeClient) GetX(ctx context.Context, id string) *PlaceInventoryAttribute {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInventory queries the inventory edge of a PlaceInventoryAttribute.
func (c *PlaceInventoryAttributeClient) QueryInventory(pia *PlaceInventoryAttribute) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pia.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventoryattribute.Table, placeinventoryattribute.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placeinventoryattribute.InventoryTable, placeinventoryattribute.InventoryColumn),
		)
		fromV = sqlgraph.Neighbors(pia.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttributeType queries the attribute_type edge of a PlaceInventoryAttribute.
func (c *PlaceInventoryAttributeClient) QueryAttributeType(pia *PlaceInventoryAttribute) *InventoryAttributeQuery {
	query := (&InventoryAttributeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pia.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placeinventoryattribute.Table, placeinventoryattribute.FieldID, id),
			sqlgraph.To(inventoryattribute.Table, inventoryattribute.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placeinventoryattribute.AttributeTypeTable, placeinventoryattribute.AttributeTypeColumn),
		)
		fromV = sqlgraph.Neighbors(pia.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaceInventoryAttributeClient) Hooks() []Hook {
	return c.hooks.PlaceInventoryAttribute
}

// Interceptors returns the client interceptors.
func (c *PlaceInventoryAttributeClient) Interceptors() []Interceptor {
	return c.inters.PlaceInventoryAttribute
}

func (c *PlaceInventoryAttributeClient) mutate(ctx context.Context, m *PlaceInventoryAttributeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlaceInventoryAttributeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlaceInventoryAttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlaceInventoryAttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlaceInventoryAttributeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PlaceInventoryAttribute mutation op: %q", m.Op())
	}
}

// PlaceTableClient is a client for the PlaceTable schema.
type PlaceTableClient struct {
	config
}

// NewPlaceTableClient returns a client for the PlaceTable from the given config.
func NewPlaceTableClient(c config) *PlaceTableClient {
	return &PlaceTableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `placetable.Hooks(f(g(h())))`.
func (c *PlaceTableClient) Use(hooks ...Hook) {
	c.hooks.PlaceTable = append(c.hooks.PlaceTable, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `placetable.Intercept(f(g(h())))`.
func (c *PlaceTableClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlaceTable = append(c.inters.PlaceTable, interceptors...)
}

// Create returns a builder for creating a PlaceTable entity.
func (c *PlaceTableClient) Create() *PlaceTableCreate {
	mutation := newPlaceTableMutation(c.config, OpCreate)
	return &PlaceTableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlaceTable entities.
func (c *PlaceTableClient) CreateBulk(builders ...*PlaceTableCreate) *PlaceTableCreateBulk {
	return &PlaceTableCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlaceTableClient) MapCreateBulk(slice any, setFunc func(*PlaceTableCreate, int)) *PlaceTableCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlaceTableCreateBulk{err: fmt.Errorf("calling to PlaceTableClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlaceTableCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlaceTableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlaceTable.
func (c *PlaceTableClient) Update() *PlaceTableUpdate {
	mutation := newPlaceTableMutation(c.config, OpUpdate)
	return &PlaceTableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaceTableClient) UpdateOne(pt *PlaceTable) *PlaceTableUpdateOne {
	mutation := newPlaceTableMutation(c.config, OpUpdateOne, withPlaceTable(pt))
	return &PlaceTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaceTableClient) UpdateOneID(id string) *PlaceTableUpdateOne {
	mutation := newPlaceTableMutation(c.config, OpUpdateOne, withPlaceTableID(id))
	return &PlaceTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlaceTable.
func (c *PlaceTableClient) Delete() *PlaceTableDelete {
	mutation := newPlaceTableMutation(c.config, OpDelete)
	return &PlaceTableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlaceTableClient) DeleteOne(pt *PlaceTable) *PlaceTableDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlaceTableClient) DeleteOneID(id string) *PlaceTableDeleteOne {
	builder := c.Delete().Where(placetable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaceTableDeleteOne{builder}
}

// Query returns a query builder for PlaceTable.
func (c *PlaceTableClient) Query() *PlaceTableQuery {
	return &PlaceTableQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlaceTable},
		inters: c.Interceptors(),
	}
}

// Get returns a PlaceTable entity by its id.
func (c *PlaceTableClient) Get(ctx context.Context, id string) (*PlaceTable, error) {
	return c.Query().Where(placetable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaceTableClient) GetX(ctx context.Context, id string) *PlaceTable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a PlaceTable.
func (c *PlaceTableClient) QueryPlace(pt *PlaceTable) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placetable.Table, placetable.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placetable.PlaceTable, placetable.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a PlaceTable.
func (c *PlaceTableClient) QueryCreatedBy(pt *PlaceTable) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placetable.Table, placetable.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placetable.CreatedByTable, placetable.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdatedBy queries the updated_by edge of a PlaceTable.
func (c *PlaceTableClient) QueryUpdatedBy(pt *PlaceTable) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placetable.Table, placetable.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placetable.UpdatedByTable, placetable.UpdatedByColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeletedBy queries the deleted_by edge of a PlaceTable.
func (c *PlaceTableClient) QueryDeletedBy(pt *PlaceTable) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placetable.Table, placetable.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placetable.DeletedByTable, placetable.DeletedByColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservedBy queries the reserved_by edge of a PlaceTable.
func (c *PlaceTableClient) QueryReservedBy(pt *PlaceTable) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placetable.Table, placetable.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placetable.ReservedByTable, placetable.ReservedByColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWaiter queries the waiter edge of a PlaceTable.
func (c *PlaceTableClient) QueryWaiter(pt *PlaceTable) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placetable.Table, placetable.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, placetable.WaiterTable, placetable.WaiterColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a PlaceTable.
func (c *PlaceTableClient) QueryOrders(pt *PlaceTable) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(placetable.Table, placetable.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, placetable.OrdersTable, placetable.OrdersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaceTableClient) Hooks() []Hook {
	return c.hooks.PlaceTable
}

// Interceptors returns the client interceptors.
func (c *PlaceTableClient) Interceptors() []Interceptor {
	return c.inters.PlaceTable
}

func (c *PlaceTableClient) mutate(ctx context.Context, m *PlaceTableMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlaceTableCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlaceTableUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlaceTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlaceTableDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PlaceTable mutation op: %q", m.Op())
	}
}

// PlanClient is a client for the Plan schema.
type PlanClient struct {
	config
}

// NewPlanClient returns a client for the Plan from the given config.
func NewPlanClient(c config) *PlanClient {
	return &PlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plan.Hooks(f(g(h())))`.
func (c *PlanClient) Use(hooks ...Hook) {
	c.hooks.Plan = append(c.hooks.Plan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plan.Intercept(f(g(h())))`.
func (c *PlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plan = append(c.inters.Plan, interceptors...)
}

// Create returns a builder for creating a Plan entity.
func (c *PlanClient) Create() *PlanCreate {
	mutation := newPlanMutation(c.config, OpCreate)
	return &PlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plan entities.
func (c *PlanClient) CreateBulk(builders ...*PlanCreate) *PlanCreateBulk {
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanClient) MapCreateBulk(slice any, setFunc func(*PlanCreate, int)) *PlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanCreateBulk{err: fmt.Errorf("calling to PlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plan.
func (c *PlanClient) Update() *PlanUpdate {
	mutation := newPlanMutation(c.config, OpUpdate)
	return &PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanClient) UpdateOne(pl *Plan) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlan(pl))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanClient) UpdateOneID(id string) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlanID(id))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plan.
func (c *PlanClient) Delete() *PlanDelete {
	mutation := newPlanMutation(c.config, OpDelete)
	return &PlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanClient) DeleteOne(pl *Plan) *PlanDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanClient) DeleteOneID(id string) *PlanDeleteOne {
	builder := c.Delete().Where(plan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDeleteOne{builder}
}

// Query returns a query builder for Plan.
func (c *PlanClient) Query() *PlanQuery {
	return &PlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlan},
		inters: c.Interceptors(),
	}
}

// Get returns a Plan entity by its id.
func (c *PlanClient) Get(ctx context.Context, id string) (*Plan, error) {
	return c.Query().Where(plan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanClient) GetX(ctx context.Context, id string) *Plan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Plan.
func (c *PlanClient) QueryUsers(pl *Plan) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, plan.UsersTable, plan.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinesses queries the businesses edge of a Plan.
func (c *PlanClient) QueryBusinesses(pl *Plan) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, plan.BusinessesTable, plan.BusinessesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaces queries the places edge of a Plan.
func (c *PlanClient) QueryPlaces(pl *Plan) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, plan.PlacesTable, plan.PlacesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Plan.
func (c *PlanClient) QueryMedia(pl *Plan) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, plan.MediaTable, plan.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrices queries the prices edge of a Plan.
func (c *PlanClient) QueryPrices(pl *Plan) *PriceQuery {
	query := (&PriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(price.Table, price.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, plan.PricesTable, plan.PricesColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a Plan.
func (c *PlanClient) QuerySubscriptions(pl *Plan) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, plan.SubscriptionsTable, plan.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlanClient) Hooks() []Hook {
	return c.hooks.Plan
}

// Interceptors returns the client interceptors.
func (c *PlanClient) Interceptors() []Interceptor {
	return c.inters.Plan
}

func (c *PlanClient) mutate(ctx context.Context, m *PlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plan mutation op: %q", m.Op())
	}
}

// PostClient is a client for the Post schema.
type PostClient struct {
	config
}

// NewPostClient returns a client for the Post from the given config.
func NewPostClient(c config) *PostClient {
	return &PostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `post.Hooks(f(g(h())))`.
func (c *PostClient) Use(hooks ...Hook) {
	c.hooks.Post = append(c.hooks.Post, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `post.Intercept(f(g(h())))`.
func (c *PostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Post = append(c.inters.Post, interceptors...)
}

// Create returns a builder for creating a Post entity.
func (c *PostClient) Create() *PostCreate {
	mutation := newPostMutation(c.config, OpCreate)
	return &PostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Post entities.
func (c *PostClient) CreateBulk(builders ...*PostCreate) *PostCreateBulk {
	return &PostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostClient) MapCreateBulk(slice any, setFunc func(*PostCreate, int)) *PostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostCreateBulk{err: fmt.Errorf("calling to PostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Post.
func (c *PostClient) Update() *PostUpdate {
	mutation := newPostMutation(c.config, OpUpdate)
	return &PostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostClient) UpdateOne(po *Post) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPost(po))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostClient) UpdateOneID(id string) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPostID(id))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Post.
func (c *PostClient) Delete() *PostDelete {
	mutation := newPostMutation(c.config, OpDelete)
	return &PostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostClient) DeleteOne(po *Post) *PostDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostClient) DeleteOneID(id string) *PostDeleteOne {
	builder := c.Delete().Where(post.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostDeleteOne{builder}
}

// Query returns a query builder for Post.
func (c *PostClient) Query() *PostQuery {
	return &PostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePost},
		inters: c.Interceptors(),
	}
}

// Get returns a Post entity by its id.
func (c *PostClient) Get(ctx context.Context, id string) (*Post, error) {
	return c.Query().Where(post.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostClient) GetX(ctx context.Context, id string) *Post {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Post.
func (c *PostClient) QueryUser(po *Post) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.UserTable, post.UserColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessAccount queries the business_account edge of a Post.
func (c *PostClient) QueryBusinessAccount(po *Post) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.BusinessAccountTable, post.BusinessAccountColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedias queries the medias edge of a Post.
func (c *PostClient) QueryMedias(po *Post) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.MediasTable, post.MediasColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Post.
func (c *PostClient) QueryComments(po *Post) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.CommentsTable, post.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a Post.
func (c *PostClient) QueryLikes(po *Post) *LikeQuery {
	query := (&LikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(like.Table, like.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.LikesTable, post.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Post.
func (c *PostClient) QueryCategories(po *Post) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.CategoriesTable, post.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Post.
func (c *PostClient) QueryNotifications(po *Post) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, post.NotificationsTable, post.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReposts queries the reposts edge of a Post.
func (c *PostClient) QueryReposts(po *Post) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.RepostsTable, post.RepostsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOriginalPost queries the original_post edge of a Post.
func (c *PostClient) QueryOriginalPost(po *Post) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.OriginalPostTable, post.OriginalPostColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostClient) Hooks() []Hook {
	return c.hooks.Post
}

// Interceptors returns the client interceptors.
func (c *PostClient) Interceptors() []Interceptor {
	return c.inters.Post
}

func (c *PostClient) mutate(ctx context.Context, m *PostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Post mutation op: %q", m.Op())
	}
}

// PriceClient is a client for the Price schema.
type PriceClient struct {
	config
}

// NewPriceClient returns a client for the Price from the given config.
func NewPriceClient(c config) *PriceClient {
	return &PriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `price.Hooks(f(g(h())))`.
func (c *PriceClient) Use(hooks ...Hook) {
	c.hooks.Price = append(c.hooks.Price, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `price.Intercept(f(g(h())))`.
func (c *PriceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Price = append(c.inters.Price, interceptors...)
}

// Create returns a builder for creating a Price entity.
func (c *PriceClient) Create() *PriceCreate {
	mutation := newPriceMutation(c.config, OpCreate)
	return &PriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Price entities.
func (c *PriceClient) CreateBulk(builders ...*PriceCreate) *PriceCreateBulk {
	return &PriceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PriceClient) MapCreateBulk(slice any, setFunc func(*PriceCreate, int)) *PriceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PriceCreateBulk{err: fmt.Errorf("calling to PriceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PriceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Price.
func (c *PriceClient) Update() *PriceUpdate {
	mutation := newPriceMutation(c.config, OpUpdate)
	return &PriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PriceClient) UpdateOne(pr *Price) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPrice(pr))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PriceClient) UpdateOneID(id string) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPriceID(id))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Price.
func (c *PriceClient) Delete() *PriceDelete {
	mutation := newPriceMutation(c.config, OpDelete)
	return &PriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PriceClient) DeleteOne(pr *Price) *PriceDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PriceClient) DeleteOneID(id string) *PriceDeleteOne {
	builder := c.Delete().Where(price.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PriceDeleteOne{builder}
}

// Query returns a query builder for Price.
func (c *PriceClient) Query() *PriceQuery {
	return &PriceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrice},
		inters: c.Interceptors(),
	}
}

// Get returns a Price entity by its id.
func (c *PriceClient) Get(ctx context.Context, id string) (*Price, error) {
	return c.Query().Where(price.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PriceClient) GetX(ctx context.Context, id string) *Price {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlan queries the plan edge of a Price.
func (c *PriceClient) QueryPlan(pr *Price) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(price.Table, price.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, price.PlanTable, price.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a Price.
func (c *PriceClient) QuerySubscriptions(pr *Price) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(price.Table, price.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, price.SubscriptionsTable, price.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PriceClient) Hooks() []Hook {
	return c.hooks.Price
}

// Interceptors returns the client interceptors.
func (c *PriceClient) Interceptors() []Interceptor {
	return c.inters.Price
}

func (c *PriceClient) mutate(ctx context.Context, m *PriceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PriceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PriceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PriceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Price mutation op: %q", m.Op())
	}
}

// RatingClient is a client for the Rating schema.
type RatingClient struct {
	config
}

// NewRatingClient returns a client for the Rating from the given config.
func NewRatingClient(c config) *RatingClient {
	return &RatingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rating.Hooks(f(g(h())))`.
func (c *RatingClient) Use(hooks ...Hook) {
	c.hooks.Rating = append(c.hooks.Rating, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rating.Intercept(f(g(h())))`.
func (c *RatingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Rating = append(c.inters.Rating, interceptors...)
}

// Create returns a builder for creating a Rating entity.
func (c *RatingClient) Create() *RatingCreate {
	mutation := newRatingMutation(c.config, OpCreate)
	return &RatingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Rating entities.
func (c *RatingClient) CreateBulk(builders ...*RatingCreate) *RatingCreateBulk {
	return &RatingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RatingClient) MapCreateBulk(slice any, setFunc func(*RatingCreate, int)) *RatingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RatingCreateBulk{err: fmt.Errorf("calling to RatingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RatingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RatingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Rating.
func (c *RatingClient) Update() *RatingUpdate {
	mutation := newRatingMutation(c.config, OpUpdate)
	return &RatingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RatingClient) UpdateOne(r *Rating) *RatingUpdateOne {
	mutation := newRatingMutation(c.config, OpUpdateOne, withRating(r))
	return &RatingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RatingClient) UpdateOneID(id string) *RatingUpdateOne {
	mutation := newRatingMutation(c.config, OpUpdateOne, withRatingID(id))
	return &RatingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Rating.
func (c *RatingClient) Delete() *RatingDelete {
	mutation := newRatingMutation(c.config, OpDelete)
	return &RatingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RatingClient) DeleteOne(r *Rating) *RatingDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RatingClient) DeleteOneID(id string) *RatingDeleteOne {
	builder := c.Delete().Where(rating.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RatingDeleteOne{builder}
}

// Query returns a query builder for Rating.
func (c *RatingClient) Query() *RatingQuery {
	return &RatingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRating},
		inters: c.Interceptors(),
	}
}

// Get returns a Rating entity by its id.
func (c *RatingClient) Get(ctx context.Context, id string) (*Rating, error) {
	return c.Query().Where(rating.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RatingClient) GetX(ctx context.Context, id string) *Rating {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Rating.
func (c *RatingClient) QueryUser(r *Rating) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rating.UserTable, rating.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a Rating.
func (c *RatingClient) QueryBusiness(r *Rating) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rating.BusinessTable, rating.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Rating.
func (c *RatingClient) QueryPlace(r *Rating) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rating.PlaceTable, rating.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Rating.
func (c *RatingClient) QueryEvent(r *Rating) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rating.EventTable, rating.EventColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RatingClient) Hooks() []Hook {
	hooks := c.hooks.Rating
	return append(hooks[:len(hooks):len(hooks)], rating.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RatingClient) Interceptors() []Interceptor {
	return c.inters.Rating
}

func (c *RatingClient) mutate(ctx context.Context, m *RatingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RatingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RatingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RatingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RatingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Rating mutation op: %q", m.Op())
	}
}

// ReactionClient is a client for the Reaction schema.
type ReactionClient struct {
	config
}

// NewReactionClient returns a client for the Reaction from the given config.
func NewReactionClient(c config) *ReactionClient {
	return &ReactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reaction.Hooks(f(g(h())))`.
func (c *ReactionClient) Use(hooks ...Hook) {
	c.hooks.Reaction = append(c.hooks.Reaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reaction.Intercept(f(g(h())))`.
func (c *ReactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reaction = append(c.inters.Reaction, interceptors...)
}

// Create returns a builder for creating a Reaction entity.
func (c *ReactionClient) Create() *ReactionCreate {
	mutation := newReactionMutation(c.config, OpCreate)
	return &ReactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reaction entities.
func (c *ReactionClient) CreateBulk(builders ...*ReactionCreate) *ReactionCreateBulk {
	return &ReactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReactionClient) MapCreateBulk(slice any, setFunc func(*ReactionCreate, int)) *ReactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReactionCreateBulk{err: fmt.Errorf("calling to ReactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reaction.
func (c *ReactionClient) Update() *ReactionUpdate {
	mutation := newReactionMutation(c.config, OpUpdate)
	return &ReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReactionClient) UpdateOne(r *Reaction) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReaction(r))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReactionClient) UpdateOneID(id string) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReactionID(id))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reaction.
func (c *ReactionClient) Delete() *ReactionDelete {
	mutation := newReactionMutation(c.config, OpDelete)
	return &ReactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReactionClient) DeleteOne(r *Reaction) *ReactionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReactionClient) DeleteOneID(id string) *ReactionDeleteOne {
	builder := c.Delete().Where(reaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReactionDeleteOne{builder}
}

// Query returns a query builder for Reaction.
func (c *ReactionClient) Query() *ReactionQuery {
	return &ReactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReaction},
		inters: c.Interceptors(),
	}
}

// Get returns a Reaction entity by its id.
func (c *ReactionClient) Get(ctx context.Context, id string) (*Reaction, error) {
	return c.Query().Where(reaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReactionClient) GetX(ctx context.Context, id string) *Reaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ReactionClient) Hooks() []Hook {
	return c.hooks.Reaction
}

// Interceptors returns the client interceptors.
func (c *ReactionClient) Interceptors() []Interceptor {
	return c.inters.Reaction
}

func (c *ReactionClient) mutate(ctx context.Context, m *ReactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reaction mutation op: %q", m.Op())
	}
}

// ReservationClient is a client for the Reservation schema.
type ReservationClient struct {
	config
}

// NewReservationClient returns a client for the Reservation from the given config.
func NewReservationClient(c config) *ReservationClient {
	return &ReservationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reservation.Hooks(f(g(h())))`.
func (c *ReservationClient) Use(hooks ...Hook) {
	c.hooks.Reservation = append(c.hooks.Reservation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reservation.Intercept(f(g(h())))`.
func (c *ReservationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reservation = append(c.inters.Reservation, interceptors...)
}

// Create returns a builder for creating a Reservation entity.
func (c *ReservationClient) Create() *ReservationCreate {
	mutation := newReservationMutation(c.config, OpCreate)
	return &ReservationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reservation entities.
func (c *ReservationClient) CreateBulk(builders ...*ReservationCreate) *ReservationCreateBulk {
	return &ReservationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReservationClient) MapCreateBulk(slice any, setFunc func(*ReservationCreate, int)) *ReservationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReservationCreateBulk{err: fmt.Errorf("calling to ReservationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReservationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReservationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reservation.
func (c *ReservationClient) Update() *ReservationUpdate {
	mutation := newReservationMutation(c.config, OpUpdate)
	return &ReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReservationClient) UpdateOne(r *Reservation) *ReservationUpdateOne {
	mutation := newReservationMutation(c.config, OpUpdateOne, withReservation(r))
	return &ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReservationClient) UpdateOneID(id string) *ReservationUpdateOne {
	mutation := newReservationMutation(c.config, OpUpdateOne, withReservationID(id))
	return &ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reservation.
func (c *ReservationClient) Delete() *ReservationDelete {
	mutation := newReservationMutation(c.config, OpDelete)
	return &ReservationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReservationClient) DeleteOne(r *Reservation) *ReservationDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReservationClient) DeleteOneID(id string) *ReservationDeleteOne {
	builder := c.Delete().Where(reservation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReservationDeleteOne{builder}
}

// Query returns a query builder for Reservation.
func (c *ReservationClient) Query() *ReservationQuery {
	return &ReservationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReservation},
		inters: c.Interceptors(),
	}
}

// Get returns a Reservation entity by its id.
func (c *ReservationClient) Get(ctx context.Context, id string) (*Reservation, error) {
	return c.Query().Where(reservation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReservationClient) GetX(ctx context.Context, id string) *Reservation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a Reservation.
func (c *ReservationClient) QueryPlace(r *Reservation) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservation.Table, reservation.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservation.PlaceTable, reservation.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoom queries the room edge of a Reservation.
func (c *ReservationClient) QueryRoom(r *Reservation) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservation.Table, reservation.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservation.RoomTable, reservation.RoomColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Reservation.
func (c *ReservationClient) QueryUser(r *Reservation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservation.Table, reservation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservation.UserTable, reservation.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReservationClient) Hooks() []Hook {
	return c.hooks.Reservation
}

// Interceptors returns the client interceptors.
func (c *ReservationClient) Interceptors() []Interceptor {
	return c.inters.Reservation
}

func (c *ReservationClient) mutate(ctx context.Context, m *ReservationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReservationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReservationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reservation mutation op: %q", m.Op())
	}
}

// ReservationBlockClient is a client for the ReservationBlock schema.
type ReservationBlockClient struct {
	config
}

// NewReservationBlockClient returns a client for the ReservationBlock from the given config.
func NewReservationBlockClient(c config) *ReservationBlockClient {
	return &ReservationBlockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reservationblock.Hooks(f(g(h())))`.
func (c *ReservationBlockClient) Use(hooks ...Hook) {
	c.hooks.ReservationBlock = append(c.hooks.ReservationBlock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reservationblock.Intercept(f(g(h())))`.
func (c *ReservationBlockClient) Intercept(interceptors ...Interceptor) {
	c.inters.ReservationBlock = append(c.inters.ReservationBlock, interceptors...)
}

// Create returns a builder for creating a ReservationBlock entity.
func (c *ReservationBlockClient) Create() *ReservationBlockCreate {
	mutation := newReservationBlockMutation(c.config, OpCreate)
	return &ReservationBlockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReservationBlock entities.
func (c *ReservationBlockClient) CreateBulk(builders ...*ReservationBlockCreate) *ReservationBlockCreateBulk {
	return &ReservationBlockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReservationBlockClient) MapCreateBulk(slice any, setFunc func(*ReservationBlockCreate, int)) *ReservationBlockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReservationBlockCreateBulk{err: fmt.Errorf("calling to ReservationBlockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReservationBlockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReservationBlockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReservationBlock.
func (c *ReservationBlockClient) Update() *ReservationBlockUpdate {
	mutation := newReservationBlockMutation(c.config, OpUpdate)
	return &ReservationBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReservationBlockClient) UpdateOne(rb *ReservationBlock) *ReservationBlockUpdateOne {
	mutation := newReservationBlockMutation(c.config, OpUpdateOne, withReservationBlock(rb))
	return &ReservationBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReservationBlockClient) UpdateOneID(id string) *ReservationBlockUpdateOne {
	mutation := newReservationBlockMutation(c.config, OpUpdateOne, withReservationBlockID(id))
	return &ReservationBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReservationBlock.
func (c *ReservationBlockClient) Delete() *ReservationBlockDelete {
	mutation := newReservationBlockMutation(c.config, OpDelete)
	return &ReservationBlockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReservationBlockClient) DeleteOne(rb *ReservationBlock) *ReservationBlockDeleteOne {
	return c.DeleteOneID(rb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReservationBlockClient) DeleteOneID(id string) *ReservationBlockDeleteOne {
	builder := c.Delete().Where(reservationblock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReservationBlockDeleteOne{builder}
}

// Query returns a query builder for ReservationBlock.
func (c *ReservationBlockClient) Query() *ReservationBlockQuery {
	return &ReservationBlockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReservationBlock},
		inters: c.Interceptors(),
	}
}

// Get returns a ReservationBlock entity by its id.
func (c *ReservationBlockClient) Get(ctx context.Context, id string) (*ReservationBlock, error) {
	return c.Query().Where(reservationblock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReservationBlockClient) GetX(ctx context.Context, id string) *ReservationBlock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlaceInventory queries the place_inventory edge of a ReservationBlock.
func (c *ReservationBlockClient) QueryPlaceInventory(rb *ReservationBlock) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservationblock.Table, reservationblock.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservationblock.PlaceInventoryTable, reservationblock.PlaceInventoryColumn),
		)
		fromV = sqlgraph.Neighbors(rb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ReservationBlock.
func (c *ReservationBlockClient) QueryUser(rb *ReservationBlock) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservationblock.Table, reservationblock.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservationblock.UserTable, reservationblock.UserColumn),
		)
		fromV = sqlgraph.Neighbors(rb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReservationBlockClient) Hooks() []Hook {
	return c.hooks.ReservationBlock
}

// Interceptors returns the client interceptors.
func (c *ReservationBlockClient) Interceptors() []Interceptor {
	return c.inters.ReservationBlock
}

func (c *ReservationBlockClient) mutate(ctx context.Context, m *ReservationBlockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReservationBlockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReservationBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReservationBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReservationBlockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ReservationBlock mutation op: %q", m.Op())
	}
}

// ResourseClient is a client for the Resourse schema.
type ResourseClient struct {
	config
}

// NewResourseClient returns a client for the Resourse from the given config.
func NewResourseClient(c config) *ResourseClient {
	return &ResourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourse.Hooks(f(g(h())))`.
func (c *ResourseClient) Use(hooks ...Hook) {
	c.hooks.Resourse = append(c.hooks.Resourse, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourse.Intercept(f(g(h())))`.
func (c *ResourseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Resourse = append(c.inters.Resourse, interceptors...)
}

// Create returns a builder for creating a Resourse entity.
func (c *ResourseClient) Create() *ResourseCreate {
	mutation := newResourseMutation(c.config, OpCreate)
	return &ResourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Resourse entities.
func (c *ResourseClient) CreateBulk(builders ...*ResourseCreate) *ResourseCreateBulk {
	return &ResourseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourseClient) MapCreateBulk(slice any, setFunc func(*ResourseCreate, int)) *ResourseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourseCreateBulk{err: fmt.Errorf("calling to ResourseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Resourse.
func (c *ResourseClient) Update() *ResourseUpdate {
	mutation := newResourseMutation(c.config, OpUpdate)
	return &ResourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourseClient) UpdateOne(r *Resourse) *ResourseUpdateOne {
	mutation := newResourseMutation(c.config, OpUpdateOne, withResourse(r))
	return &ResourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourseClient) UpdateOneID(id string) *ResourseUpdateOne {
	mutation := newResourseMutation(c.config, OpUpdateOne, withResourseID(id))
	return &ResourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Resourse.
func (c *ResourseClient) Delete() *ResourseDelete {
	mutation := newResourseMutation(c.config, OpDelete)
	return &ResourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourseClient) DeleteOne(r *Resourse) *ResourseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourseClient) DeleteOneID(id string) *ResourseDeleteOne {
	builder := c.Delete().Where(resourse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourseDeleteOne{builder}
}

// Query returns a query builder for Resourse.
func (c *ResourseClient) Query() *ResourseQuery {
	return &ResourseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourse},
		inters: c.Interceptors(),
	}
}

// Get returns a Resourse entity by its id.
func (c *ResourseClient) Get(ctx context.Context, id string) (*Resourse, error) {
	return c.Query().Where(resourse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourseClient) GetX(ctx context.Context, id string) *Resourse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ResourseClient) Hooks() []Hook {
	return c.hooks.Resourse
}

// Interceptors returns the client interceptors.
func (c *ResourseClient) Interceptors() []Interceptor {
	return c.inters.Resourse
}

func (c *ResourseClient) mutate(ctx context.Context, m *ResourseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Resourse mutation op: %q", m.Op())
	}
}

// ReviewClient is a client for the Review schema.
type ReviewClient struct {
	config
}

// NewReviewClient returns a client for the Review from the given config.
func NewReviewClient(c config) *ReviewClient {
	return &ReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `review.Hooks(f(g(h())))`.
func (c *ReviewClient) Use(hooks ...Hook) {
	c.hooks.Review = append(c.hooks.Review, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `review.Intercept(f(g(h())))`.
func (c *ReviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.Review = append(c.inters.Review, interceptors...)
}

// Create returns a builder for creating a Review entity.
func (c *ReviewClient) Create() *ReviewCreate {
	mutation := newReviewMutation(c.config, OpCreate)
	return &ReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Review entities.
func (c *ReviewClient) CreateBulk(builders ...*ReviewCreate) *ReviewCreateBulk {
	return &ReviewCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReviewClient) MapCreateBulk(slice any, setFunc func(*ReviewCreate, int)) *ReviewCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReviewCreateBulk{err: fmt.Errorf("calling to ReviewClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReviewCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Review.
func (c *ReviewClient) Update() *ReviewUpdate {
	mutation := newReviewMutation(c.config, OpUpdate)
	return &ReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReviewClient) UpdateOne(r *Review) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReview(r))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReviewClient) UpdateOneID(id string) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReviewID(id))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Review.
func (c *ReviewClient) Delete() *ReviewDelete {
	mutation := newReviewMutation(c.config, OpDelete)
	return &ReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReviewClient) DeleteOne(r *Review) *ReviewDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReviewClient) DeleteOneID(id string) *ReviewDeleteOne {
	builder := c.Delete().Where(review.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReviewDeleteOne{builder}
}

// Query returns a query builder for Review.
func (c *ReviewClient) Query() *ReviewQuery {
	return &ReviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReview},
		inters: c.Interceptors(),
	}
}

// Get returns a Review entity by its id.
func (c *ReviewClient) Get(ctx context.Context, id string) (*Review, error) {
	return c.Query().Where(review.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReviewClient) GetX(ctx context.Context, id string) *Review {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Review.
func (c *ReviewClient) QueryUser(r *Review) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, review.UserTable, review.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a Review.
func (c *ReviewClient) QueryBusiness(r *Review) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.BusinessTable, review.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Review.
func (c *ReviewClient) QueryPlace(r *Review) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.PlaceTable, review.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Review.
func (c *ReviewClient) QueryEvent(r *Review) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.EventTable, review.EventColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedias queries the medias edge of a Review.
func (c *ReviewClient) QueryMedias(r *Review) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.MediasTable, review.MediasColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Review.
func (c *ReviewClient) QueryComments(r *Review) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.CommentsTable, review.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a Review.
func (c *ReviewClient) QueryLikes(r *Review) *LikeQuery {
	query := (&LikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(like.Table, like.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.LikesTable, review.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReviewClient) Hooks() []Hook {
	hooks := c.hooks.Review
	return append(hooks[:len(hooks):len(hooks)], review.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ReviewClient) Interceptors() []Interceptor {
	return c.inters.Review
}

func (c *ReviewClient) mutate(ctx context.Context, m *ReviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Review mutation op: %q", m.Op())
	}
}

// RoomClient is a client for the Room schema.
type RoomClient struct {
	config
}

// NewRoomClient returns a client for the Room from the given config.
func NewRoomClient(c config) *RoomClient {
	return &RoomClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `room.Hooks(f(g(h())))`.
func (c *RoomClient) Use(hooks ...Hook) {
	c.hooks.Room = append(c.hooks.Room, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `room.Intercept(f(g(h())))`.
func (c *RoomClient) Intercept(interceptors ...Interceptor) {
	c.inters.Room = append(c.inters.Room, interceptors...)
}

// Create returns a builder for creating a Room entity.
func (c *RoomClient) Create() *RoomCreate {
	mutation := newRoomMutation(c.config, OpCreate)
	return &RoomCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Room entities.
func (c *RoomClient) CreateBulk(builders ...*RoomCreate) *RoomCreateBulk {
	return &RoomCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoomClient) MapCreateBulk(slice any, setFunc func(*RoomCreate, int)) *RoomCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoomCreateBulk{err: fmt.Errorf("calling to RoomClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoomCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoomCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Room.
func (c *RoomClient) Update() *RoomUpdate {
	mutation := newRoomMutation(c.config, OpUpdate)
	return &RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoomClient) UpdateOne(r *Room) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoom(r))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoomClient) UpdateOneID(id string) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoomID(id))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Room.
func (c *RoomClient) Delete() *RoomDelete {
	mutation := newRoomMutation(c.config, OpDelete)
	return &RoomDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoomClient) DeleteOne(r *Room) *RoomDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoomClient) DeleteOneID(id string) *RoomDeleteOne {
	builder := c.Delete().Where(room.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoomDeleteOne{builder}
}

// Query returns a query builder for Room.
func (c *RoomClient) Query() *RoomQuery {
	return &RoomQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoom},
		inters: c.Interceptors(),
	}
}

// Get returns a Room entity by its id.
func (c *RoomClient) Get(ctx context.Context, id string) (*Room, error) {
	return c.Query().Where(room.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoomClient) GetX(ctx context.Context, id string) *Room {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a Room.
func (c *RoomClient) QueryPlace(r *Room) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, room.PlaceTable, room.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoomCategory queries the room_category edge of a Room.
func (c *RoomClient) QueryRoomCategory(r *Room) *RoomCategoryQuery {
	query := (&RoomCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(roomcategory.Table, roomcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, room.RoomCategoryTable, room.RoomCategoryPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Room.
func (c *RoomClient) QueryBookings(r *Room) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, room.BookingsTable, room.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAmenities queries the amenities edge of a Room.
func (c *RoomClient) QueryAmenities(r *Room) *AmenityQuery {
	query := (&AmenityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(amenity.Table, amenity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, room.AmenitiesTable, room.AmenitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Room.
func (c *RoomClient) QueryMedia(r *Room) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, room.MediaTable, room.MediaPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservations queries the reservations edge of a Room.
func (c *RoomClient) QueryReservations(r *Room) *ReservationQuery {
	query := (&ReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(reservation.Table, reservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, room.ReservationsTable, room.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoomClient) Hooks() []Hook {
	return c.hooks.Room
}

// Interceptors returns the client interceptors.
func (c *RoomClient) Interceptors() []Interceptor {
	return c.inters.Room
}

func (c *RoomClient) mutate(ctx context.Context, m *RoomMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoomCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoomDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Room mutation op: %q", m.Op())
	}
}

// RoomCategoryClient is a client for the RoomCategory schema.
type RoomCategoryClient struct {
	config
}

// NewRoomCategoryClient returns a client for the RoomCategory from the given config.
func NewRoomCategoryClient(c config) *RoomCategoryClient {
	return &RoomCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `roomcategory.Hooks(f(g(h())))`.
func (c *RoomCategoryClient) Use(hooks ...Hook) {
	c.hooks.RoomCategory = append(c.hooks.RoomCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `roomcategory.Intercept(f(g(h())))`.
func (c *RoomCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.RoomCategory = append(c.inters.RoomCategory, interceptors...)
}

// Create returns a builder for creating a RoomCategory entity.
func (c *RoomCategoryClient) Create() *RoomCategoryCreate {
	mutation := newRoomCategoryMutation(c.config, OpCreate)
	return &RoomCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RoomCategory entities.
func (c *RoomCategoryClient) CreateBulk(builders ...*RoomCategoryCreate) *RoomCategoryCreateBulk {
	return &RoomCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoomCategoryClient) MapCreateBulk(slice any, setFunc func(*RoomCategoryCreate, int)) *RoomCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoomCategoryCreateBulk{err: fmt.Errorf("calling to RoomCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoomCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoomCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RoomCategory.
func (c *RoomCategoryClient) Update() *RoomCategoryUpdate {
	mutation := newRoomCategoryMutation(c.config, OpUpdate)
	return &RoomCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoomCategoryClient) UpdateOne(rc *RoomCategory) *RoomCategoryUpdateOne {
	mutation := newRoomCategoryMutation(c.config, OpUpdateOne, withRoomCategory(rc))
	return &RoomCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoomCategoryClient) UpdateOneID(id string) *RoomCategoryUpdateOne {
	mutation := newRoomCategoryMutation(c.config, OpUpdateOne, withRoomCategoryID(id))
	return &RoomCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RoomCategory.
func (c *RoomCategoryClient) Delete() *RoomCategoryDelete {
	mutation := newRoomCategoryMutation(c.config, OpDelete)
	return &RoomCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoomCategoryClient) DeleteOne(rc *RoomCategory) *RoomCategoryDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoomCategoryClient) DeleteOneID(id string) *RoomCategoryDeleteOne {
	builder := c.Delete().Where(roomcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoomCategoryDeleteOne{builder}
}

// Query returns a query builder for RoomCategory.
func (c *RoomCategoryClient) Query() *RoomCategoryQuery {
	return &RoomCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoomCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a RoomCategory entity by its id.
func (c *RoomCategoryClient) Get(ctx context.Context, id string) (*RoomCategory, error) {
	return c.Query().Where(roomcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoomCategoryClient) GetX(ctx context.Context, id string) *RoomCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a RoomCategory.
func (c *RoomCategoryClient) QueryPlace(rc *RoomCategory) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(roomcategory.Table, roomcategory.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, roomcategory.PlaceTable, roomcategory.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRooms queries the rooms edge of a RoomCategory.
func (c *RoomCategoryClient) QueryRooms(rc *RoomCategory) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(roomcategory.Table, roomcategory.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, roomcategory.RoomsTable, roomcategory.RoomsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a RoomCategory.
func (c *RoomCategoryClient) QueryMedia(rc *RoomCategory) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(roomcategory.Table, roomcategory.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, roomcategory.MediaTable, roomcategory.MediaPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAmenities queries the amenities edge of a RoomCategory.
func (c *RoomCategoryClient) QueryAmenities(rc *RoomCategory) *AmenityQuery {
	query := (&AmenityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(roomcategory.Table, roomcategory.FieldID, id),
			sqlgraph.To(amenity.Table, amenity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, roomcategory.AmenitiesTable, roomcategory.AmenitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoomCategoryClient) Hooks() []Hook {
	return c.hooks.RoomCategory
}

// Interceptors returns the client interceptors.
func (c *RoomCategoryClient) Interceptors() []Interceptor {
	return c.inters.RoomCategory
}

func (c *RoomCategoryClient) mutate(ctx context.Context, m *RoomCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoomCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoomCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoomCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoomCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RoomCategory mutation op: %q", m.Op())
	}
}

// StaffClient is a client for the Staff schema.
type StaffClient struct {
	config
}

// NewStaffClient returns a client for the Staff from the given config.
func NewStaffClient(c config) *StaffClient {
	return &StaffClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `staff.Hooks(f(g(h())))`.
func (c *StaffClient) Use(hooks ...Hook) {
	c.hooks.Staff = append(c.hooks.Staff, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `staff.Intercept(f(g(h())))`.
func (c *StaffClient) Intercept(interceptors ...Interceptor) {
	c.inters.Staff = append(c.inters.Staff, interceptors...)
}

// Create returns a builder for creating a Staff entity.
func (c *StaffClient) Create() *StaffCreate {
	mutation := newStaffMutation(c.config, OpCreate)
	return &StaffCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Staff entities.
func (c *StaffClient) CreateBulk(builders ...*StaffCreate) *StaffCreateBulk {
	return &StaffCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StaffClient) MapCreateBulk(slice any, setFunc func(*StaffCreate, int)) *StaffCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StaffCreateBulk{err: fmt.Errorf("calling to StaffClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StaffCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StaffCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Staff.
func (c *StaffClient) Update() *StaffUpdate {
	mutation := newStaffMutation(c.config, OpUpdate)
	return &StaffUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StaffClient) UpdateOne(s *Staff) *StaffUpdateOne {
	mutation := newStaffMutation(c.config, OpUpdateOne, withStaff(s))
	return &StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StaffClient) UpdateOneID(id string) *StaffUpdateOne {
	mutation := newStaffMutation(c.config, OpUpdateOne, withStaffID(id))
	return &StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Staff.
func (c *StaffClient) Delete() *StaffDelete {
	mutation := newStaffMutation(c.config, OpDelete)
	return &StaffDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StaffClient) DeleteOne(s *Staff) *StaffDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StaffClient) DeleteOneID(id string) *StaffDeleteOne {
	builder := c.Delete().Where(staff.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StaffDeleteOne{builder}
}

// Query returns a query builder for Staff.
func (c *StaffClient) Query() *StaffQuery {
	return &StaffQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStaff},
		inters: c.Interceptors(),
	}
}

// Get returns a Staff entity by its id.
func (c *StaffClient) Get(ctx context.Context, id string) (*Staff, error) {
	return c.Query().Where(staff.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StaffClient) GetX(ctx context.Context, id string) *Staff {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Staff.
func (c *StaffClient) QueryUser(s *Staff) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, staff.UserTable, staff.UserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Staff.
func (c *StaffClient) QueryPlace(s *Staff) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, staff.PlaceTable, staff.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a Staff.
func (c *StaffClient) QueryPermissions(s *Staff) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, staff.PermissionsTable, staff.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a Staff.
func (c *StaffClient) QueryBusiness(s *Staff) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, staff.BusinessTable, staff.BusinessPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StaffClient) Hooks() []Hook {
	return c.hooks.Staff
}

// Interceptors returns the client interceptors.
func (c *StaffClient) Interceptors() []Interceptor {
	return c.inters.Staff
}

func (c *StaffClient) mutate(ctx context.Context, m *StaffMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StaffCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StaffUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StaffDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Staff mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(s *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(s))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id string) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(s *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id string) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id string) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id string) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Subscription.
func (c *SubscriptionClient) QueryUser(s *Subscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.UserTable, subscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the plan edge of a Subscription.
func (c *SubscriptionClient) QueryPlan(s *Subscription) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.PlanTable, subscription.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrice queries the price edge of a Subscription.
func (c *SubscriptionClient) QueryPrice(s *Subscription) *PriceQuery {
	query := (&PriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(price.Table, price.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.PriceTable, subscription.PriceColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subscription mutation op: %q", m.Op())
	}
}

// TemplateClient is a client for the Template schema.
type TemplateClient struct {
	config
}

// NewTemplateClient returns a client for the Template from the given config.
func NewTemplateClient(c config) *TemplateClient {
	return &TemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `template.Hooks(f(g(h())))`.
func (c *TemplateClient) Use(hooks ...Hook) {
	c.hooks.Template = append(c.hooks.Template, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `template.Intercept(f(g(h())))`.
func (c *TemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Template = append(c.inters.Template, interceptors...)
}

// Create returns a builder for creating a Template entity.
func (c *TemplateClient) Create() *TemplateCreate {
	mutation := newTemplateMutation(c.config, OpCreate)
	return &TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Template entities.
func (c *TemplateClient) CreateBulk(builders ...*TemplateCreate) *TemplateCreateBulk {
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateClient) MapCreateBulk(slice any, setFunc func(*TemplateCreate, int)) *TemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateCreateBulk{err: fmt.Errorf("calling to TemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Template.
func (c *TemplateClient) Update() *TemplateUpdate {
	mutation := newTemplateMutation(c.config, OpUpdate)
	return &TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateClient) UpdateOne(t *Template) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplate(t))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateClient) UpdateOneID(id string) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplateID(id))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Template.
func (c *TemplateClient) Delete() *TemplateDelete {
	mutation := newTemplateMutation(c.config, OpDelete)
	return &TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateClient) DeleteOne(t *Template) *TemplateDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateClient) DeleteOneID(id string) *TemplateDeleteOne {
	builder := c.Delete().Where(template.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateDeleteOne{builder}
}

// Query returns a query builder for Template.
func (c *TemplateClient) Query() *TemplateQuery {
	return &TemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a Template entity by its id.
func (c *TemplateClient) Get(ctx context.Context, id string) (*Template, error) {
	return c.Query().Where(template.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateClient) GetX(ctx context.Context, id string) *Template {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWebsites queries the websites edge of a Template.
func (c *TemplateClient) QueryWebsites(t *Template) *WebsiteQuery {
	query := (&WebsiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(website.Table, website.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, template.WebsitesTable, template.WebsitesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TemplateClient) Hooks() []Hook {
	return c.hooks.Template
}

// Interceptors returns the client interceptors.
func (c *TemplateClient) Interceptors() []Interceptor {
	return c.inters.Template
}

func (c *TemplateClient) mutate(ctx context.Context, m *TemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Template mutation op: %q", m.Op())
	}
}

// TicketClient is a client for the Ticket schema.
type TicketClient struct {
	config
}

// NewTicketClient returns a client for the Ticket from the given config.
func NewTicketClient(c config) *TicketClient {
	return &TicketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ticket.Hooks(f(g(h())))`.
func (c *TicketClient) Use(hooks ...Hook) {
	c.hooks.Ticket = append(c.hooks.Ticket, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ticket.Intercept(f(g(h())))`.
func (c *TicketClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ticket = append(c.inters.Ticket, interceptors...)
}

// Create returns a builder for creating a Ticket entity.
func (c *TicketClient) Create() *TicketCreate {
	mutation := newTicketMutation(c.config, OpCreate)
	return &TicketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ticket entities.
func (c *TicketClient) CreateBulk(builders ...*TicketCreate) *TicketCreateBulk {
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TicketClient) MapCreateBulk(slice any, setFunc func(*TicketCreate, int)) *TicketCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TicketCreateBulk{err: fmt.Errorf("calling to TicketClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TicketCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ticket.
func (c *TicketClient) Update() *TicketUpdate {
	mutation := newTicketMutation(c.config, OpUpdate)
	return &TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TicketClient) UpdateOne(t *Ticket) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicket(t))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TicketClient) UpdateOneID(id string) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicketID(id))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ticket.
func (c *TicketClient) Delete() *TicketDelete {
	mutation := newTicketMutation(c.config, OpDelete)
	return &TicketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TicketClient) DeleteOne(t *Ticket) *TicketDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TicketClient) DeleteOneID(id string) *TicketDeleteOne {
	builder := c.Delete().Where(ticket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TicketDeleteOne{builder}
}

// Query returns a query builder for Ticket.
func (c *TicketClient) Query() *TicketQuery {
	return &TicketQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTicket},
		inters: c.Interceptors(),
	}
}

// Get returns a Ticket entity by its id.
func (c *TicketClient) Get(ctx context.Context, id string) (*Ticket, error) {
	return c.Query().Where(ticket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TicketClient) GetX(ctx context.Context, id string) *Ticket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTicketOption queries the ticketOption edge of a Ticket.
func (c *TicketClient) QueryTicketOption(t *Ticket) *TicketOptionQuery {
	query := (&TicketOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(ticketoption.Table, ticketoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.TicketOptionTable, ticket.TicketOptionColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPurchaser queries the purchaser edge of a Ticket.
func (c *TicketClient) QueryPurchaser(t *Ticket) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.PurchaserTable, ticket.PurchaserColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Ticket.
func (c *TicketClient) QueryEvent(t *Ticket) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.EventTable, ticket.EventColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TicketClient) Hooks() []Hook {
	return c.hooks.Ticket
}

// Interceptors returns the client interceptors.
func (c *TicketClient) Interceptors() []Interceptor {
	return c.inters.Ticket
}

func (c *TicketClient) mutate(ctx context.Context, m *TicketMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TicketCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TicketDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ticket mutation op: %q", m.Op())
	}
}

// TicketOptionClient is a client for the TicketOption schema.
type TicketOptionClient struct {
	config
}

// NewTicketOptionClient returns a client for the TicketOption from the given config.
func NewTicketOptionClient(c config) *TicketOptionClient {
	return &TicketOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ticketoption.Hooks(f(g(h())))`.
func (c *TicketOptionClient) Use(hooks ...Hook) {
	c.hooks.TicketOption = append(c.hooks.TicketOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ticketoption.Intercept(f(g(h())))`.
func (c *TicketOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TicketOption = append(c.inters.TicketOption, interceptors...)
}

// Create returns a builder for creating a TicketOption entity.
func (c *TicketOptionClient) Create() *TicketOptionCreate {
	mutation := newTicketOptionMutation(c.config, OpCreate)
	return &TicketOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TicketOption entities.
func (c *TicketOptionClient) CreateBulk(builders ...*TicketOptionCreate) *TicketOptionCreateBulk {
	return &TicketOptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TicketOptionClient) MapCreateBulk(slice any, setFunc func(*TicketOptionCreate, int)) *TicketOptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TicketOptionCreateBulk{err: fmt.Errorf("calling to TicketOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TicketOptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TicketOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TicketOption.
func (c *TicketOptionClient) Update() *TicketOptionUpdate {
	mutation := newTicketOptionMutation(c.config, OpUpdate)
	return &TicketOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TicketOptionClient) UpdateOne(to *TicketOption) *TicketOptionUpdateOne {
	mutation := newTicketOptionMutation(c.config, OpUpdateOne, withTicketOption(to))
	return &TicketOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TicketOptionClient) UpdateOneID(id string) *TicketOptionUpdateOne {
	mutation := newTicketOptionMutation(c.config, OpUpdateOne, withTicketOptionID(id))
	return &TicketOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TicketOption.
func (c *TicketOptionClient) Delete() *TicketOptionDelete {
	mutation := newTicketOptionMutation(c.config, OpDelete)
	return &TicketOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TicketOptionClient) DeleteOne(to *TicketOption) *TicketOptionDeleteOne {
	return c.DeleteOneID(to.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TicketOptionClient) DeleteOneID(id string) *TicketOptionDeleteOne {
	builder := c.Delete().Where(ticketoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TicketOptionDeleteOne{builder}
}

// Query returns a query builder for TicketOption.
func (c *TicketOptionClient) Query() *TicketOptionQuery {
	return &TicketOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTicketOption},
		inters: c.Interceptors(),
	}
}

// Get returns a TicketOption entity by its id.
func (c *TicketOptionClient) Get(ctx context.Context, id string) (*TicketOption, error) {
	return c.Query().Where(ticketoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TicketOptionClient) GetX(ctx context.Context, id string) *TicketOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a TicketOption.
func (c *TicketOptionClient) QueryEvent(to *TicketOption) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticketoption.Table, ticketoption.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticketoption.EventTable, ticketoption.EventColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTickets queries the tickets edge of a TicketOption.
func (c *TicketOptionClient) QueryTickets(to *TicketOption) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticketoption.Table, ticketoption.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ticketoption.TicketsTable, ticketoption.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TicketOptionClient) Hooks() []Hook {
	return c.hooks.TicketOption
}

// Interceptors returns the client interceptors.
func (c *TicketOptionClient) Interceptors() []Interceptor {
	return c.inters.TicketOption
}

func (c *TicketOptionClient) mutate(ctx context.Context, m *TicketOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TicketOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TicketOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TicketOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TicketOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TicketOption mutation op: %q", m.Op())
	}
}

// TrainerClient is a client for the Trainer schema.
type TrainerClient struct {
	config
}

// NewTrainerClient returns a client for the Trainer from the given config.
func NewTrainerClient(c config) *TrainerClient {
	return &TrainerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trainer.Hooks(f(g(h())))`.
func (c *TrainerClient) Use(hooks ...Hook) {
	c.hooks.Trainer = append(c.hooks.Trainer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trainer.Intercept(f(g(h())))`.
func (c *TrainerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Trainer = append(c.inters.Trainer, interceptors...)
}

// Create returns a builder for creating a Trainer entity.
func (c *TrainerClient) Create() *TrainerCreate {
	mutation := newTrainerMutation(c.config, OpCreate)
	return &TrainerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Trainer entities.
func (c *TrainerClient) CreateBulk(builders ...*TrainerCreate) *TrainerCreateBulk {
	return &TrainerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrainerClient) MapCreateBulk(slice any, setFunc func(*TrainerCreate, int)) *TrainerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrainerCreateBulk{err: fmt.Errorf("calling to TrainerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrainerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrainerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Trainer.
func (c *TrainerClient) Update() *TrainerUpdate {
	mutation := newTrainerMutation(c.config, OpUpdate)
	return &TrainerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrainerClient) UpdateOne(t *Trainer) *TrainerUpdateOne {
	mutation := newTrainerMutation(c.config, OpUpdateOne, withTrainer(t))
	return &TrainerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrainerClient) UpdateOneID(id string) *TrainerUpdateOne {
	mutation := newTrainerMutation(c.config, OpUpdateOne, withTrainerID(id))
	return &TrainerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Trainer.
func (c *TrainerClient) Delete() *TrainerDelete {
	mutation := newTrainerMutation(c.config, OpDelete)
	return &TrainerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrainerClient) DeleteOne(t *Trainer) *TrainerDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrainerClient) DeleteOneID(id string) *TrainerDeleteOne {
	builder := c.Delete().Where(trainer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrainerDeleteOne{builder}
}

// Query returns a query builder for Trainer.
func (c *TrainerClient) Query() *TrainerQuery {
	return &TrainerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrainer},
		inters: c.Interceptors(),
	}
}

// Get returns a Trainer entity by its id.
func (c *TrainerClient) Get(ctx context.Context, id string) (*Trainer, error) {
	return c.Query().Where(trainer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrainerClient) GetX(ctx context.Context, id string) *Trainer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Trainer.
func (c *TrainerClient) QueryUser(t *Trainer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trainer.Table, trainer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, trainer.UserTable, trainer.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Trainer.
func (c *TrainerClient) QueryPlace(t *Trainer) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trainer.Table, trainer.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, trainer.PlaceTable, trainer.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrainerClient) Hooks() []Hook {
	return c.hooks.Trainer
}

// Interceptors returns the client interceptors.
func (c *TrainerClient) Interceptors() []Interceptor {
	return c.inters.Trainer
}

func (c *TrainerClient) mutate(ctx context.Context, m *TrainerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrainerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrainerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrainerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrainerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Trainer mutation op: %q", m.Op())
	}
}

// TransactionHistoryClient is a client for the TransactionHistory schema.
type TransactionHistoryClient struct {
	config
}

// NewTransactionHistoryClient returns a client for the TransactionHistory from the given config.
func NewTransactionHistoryClient(c config) *TransactionHistoryClient {
	return &TransactionHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transactionhistory.Hooks(f(g(h())))`.
func (c *TransactionHistoryClient) Use(hooks ...Hook) {
	c.hooks.TransactionHistory = append(c.hooks.TransactionHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `transactionhistory.Intercept(f(g(h())))`.
func (c *TransactionHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TransactionHistory = append(c.inters.TransactionHistory, interceptors...)
}

// Create returns a builder for creating a TransactionHistory entity.
func (c *TransactionHistoryClient) Create() *TransactionHistoryCreate {
	mutation := newTransactionHistoryMutation(c.config, OpCreate)
	return &TransactionHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TransactionHistory entities.
func (c *TransactionHistoryClient) CreateBulk(builders ...*TransactionHistoryCreate) *TransactionHistoryCreateBulk {
	return &TransactionHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TransactionHistoryClient) MapCreateBulk(slice any, setFunc func(*TransactionHistoryCreate, int)) *TransactionHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TransactionHistoryCreateBulk{err: fmt.Errorf("calling to TransactionHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TransactionHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TransactionHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TransactionHistory.
func (c *TransactionHistoryClient) Update() *TransactionHistoryUpdate {
	mutation := newTransactionHistoryMutation(c.config, OpUpdate)
	return &TransactionHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransactionHistoryClient) UpdateOne(th *TransactionHistory) *TransactionHistoryUpdateOne {
	mutation := newTransactionHistoryMutation(c.config, OpUpdateOne, withTransactionHistory(th))
	return &TransactionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransactionHistoryClient) UpdateOneID(id string) *TransactionHistoryUpdateOne {
	mutation := newTransactionHistoryMutation(c.config, OpUpdateOne, withTransactionHistoryID(id))
	return &TransactionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TransactionHistory.
func (c *TransactionHistoryClient) Delete() *TransactionHistoryDelete {
	mutation := newTransactionHistoryMutation(c.config, OpDelete)
	return &TransactionHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransactionHistoryClient) DeleteOne(th *TransactionHistory) *TransactionHistoryDeleteOne {
	return c.DeleteOneID(th.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TransactionHistoryClient) DeleteOneID(id string) *TransactionHistoryDeleteOne {
	builder := c.Delete().Where(transactionhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransactionHistoryDeleteOne{builder}
}

// Query returns a query builder for TransactionHistory.
func (c *TransactionHistoryClient) Query() *TransactionHistoryQuery {
	return &TransactionHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTransactionHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TransactionHistory entity by its id.
func (c *TransactionHistoryClient) Get(ctx context.Context, id string) (*TransactionHistory, error) {
	return c.Query().Where(transactionhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransactionHistoryClient) GetX(ctx context.Context, id string) *TransactionHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlaceInventory queries the place_inventory edge of a TransactionHistory.
func (c *TransactionHistoryClient) QueryPlaceInventory(th *TransactionHistory) *PlaceInventoryQuery {
	query := (&PlaceInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := th.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transactionhistory.Table, transactionhistory.FieldID, id),
			sqlgraph.To(placeinventory.Table, placeinventory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transactionhistory.PlaceInventoryTable, transactionhistory.PlaceInventoryColumn),
		)
		fromV = sqlgraph.Neighbors(th.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a TransactionHistory.
func (c *TransactionHistoryClient) QueryUser(th *TransactionHistory) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := th.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transactionhistory.Table, transactionhistory.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transactionhistory.UserTable, transactionhistory.UserColumn),
		)
		fromV = sqlgraph.Neighbors(th.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransactionHistoryClient) Hooks() []Hook {
	return c.hooks.TransactionHistory
}

// Interceptors returns the client interceptors.
func (c *TransactionHistoryClient) Interceptors() []Interceptor {
	return c.inters.TransactionHistory
}

func (c *TransactionHistoryClient) mutate(ctx context.Context, m *TransactionHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TransactionHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TransactionHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TransactionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TransactionHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TransactionHistory mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserBusinesses queries the userBusinesses edge of a User.
func (c *UserClient) QueryUserBusinesses(u *User) *UserBusinessQuery {
	query := (&UserBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userbusiness.Table, userbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserBusinessesTable, user.UserBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a User.
func (c *UserClient) QueryComments(u *User) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CommentsTable, user.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a User.
func (c *UserClient) QueryLikes(u *User) *LikeQuery {
	query := (&LikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(like.Table, like.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LikesTable, user.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a User.
func (c *UserClient) QueryPosts(u *User) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PostsTable, user.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedUsers queries the followedUsers edge of a User.
func (c *UserClient) QueryFollowedUsers(u *User) *UserFollowUserQuery {
	query := (&UserFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowuser.Table, userfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowedUsersTable, user.FollowedUsersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerUsers queries the followerUsers edge of a User.
func (c *UserClient) QueryFollowerUsers(u *User) *UserFollowUserQuery {
	query := (&UserFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowuser.Table, userfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowerUsersTable, user.FollowerUsersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedBusinesses queries the followedBusinesses edge of a User.
func (c *UserClient) QueryFollowedBusinesses(u *User) *UserFollowBusinessQuery {
	query := (&UserFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowbusiness.Table, userfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowedBusinessesTable, user.FollowedBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerBusinesses queries the followerBusinesses edge of a User.
func (c *UserClient) QueryFollowerBusinesses(u *User) *BusinessFollowUserQuery {
	query := (&BusinessFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(businessfollowuser.Table, businessfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowerBusinessesTable, user.FollowerBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a User.
func (c *UserClient) QueryReviews(u *User) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReviewsTable, user.ReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a User.
func (c *UserClient) QueryBookings(u *User) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BookingsTable, user.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservations queries the reservations edge of a User.
func (c *UserClient) QueryReservations(u *User) *ReservationQuery {
	query := (&ReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reservation.Table, reservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReservationsTable, user.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHelps queries the helps edge of a User.
func (c *UserClient) QueryHelps(u *User) *HelpQuery {
	query := (&HelpClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(help.Table, help.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.HelpsTable, user.HelpsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a User.
func (c *UserClient) QueryCategories(u *User) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CategoriesTable, user.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaces queries the places edge of a User.
func (c *UserClient) QueryPlaces(u *User) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.PlacesTable, user.PlacesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategoryAssignments queries the categoryAssignments edge of a User.
func (c *UserClient) QueryCategoryAssignments(u *User) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CategoryAssignmentsTable, user.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedEvents queries the ownedEvents edge of a User.
func (c *UserClient) QueryOwnedEvents(u *User) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.OwnedEventsTable, user.OwnedEventsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserFollowEvents queries the userFollowEvents edge of a User.
func (c *UserClient) QueryUserFollowEvents(u *User) *UserFollowEventQuery {
	query := (&UserFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowevent.Table, userfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserFollowEventsTable, user.UserFollowEventsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedPlaces queries the followedPlaces edge of a User.
func (c *UserClient) QueryFollowedPlaces(u *User) *UserFollowPlaceQuery {
	query := (&UserFollowPlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowplace.Table, userfollowplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowedPlacesTable, user.FollowedPlacesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedPlaces queries the likedPlaces edge of a User.
func (c *UserClient) QueryLikedPlaces(u *User) *UserLikePlaceQuery {
	query := (&UserLikePlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userlikeplace.Table, userlikeplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LikedPlacesTable, user.LikedPlacesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a User.
func (c *UserClient) QueryRatings(u *User) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RatingsTable, user.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactionHistories queries the transaction_histories edge of a User.
func (c *UserClient) QueryTransactionHistories(u *User) *TransactionHistoryQuery {
	query := (&TransactionHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(transactionhistory.Table, transactionhistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TransactionHistoriesTable, user.TransactionHistoriesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservationBlocks queries the reservation_blocks edge of a User.
func (c *UserClient) QueryReservationBlocks(u *User) *ReservationBlockQuery {
	query := (&ReservationBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reservationblock.Table, reservationblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReservationBlocksTable, user.ReservationBlocksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a User.
func (c *UserClient) QueryNotifications(u *User) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.NotificationsTable, user.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWallet queries the wallet edge of a User.
func (c *UserClient) QueryWallet(u *User) *AccountWalletQuery {
	query := (&AccountWalletClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(accountwallet.Table, accountwallet.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.WalletTable, user.WalletColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a User.
func (c *UserClient) QueryOrders(u *User) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OrdersTable, user.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTablesCreated queries the tables_created edge of a User.
func (c *UserClient) QueryTablesCreated(u *User) *PlaceTableQuery {
	query := (&PlaceTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(placetable.Table, placetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TablesCreatedTable, user.TablesCreatedColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTablesUpdated queries the tables_updated edge of a User.
func (c *UserClient) QueryTablesUpdated(u *User) *PlaceTableQuery {
	query := (&PlaceTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(placetable.Table, placetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TablesUpdatedTable, user.TablesUpdatedColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTablesDeleted queries the tables_deleted edge of a User.
func (c *UserClient) QueryTablesDeleted(u *User) *PlaceTableQuery {
	query := (&PlaceTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(placetable.Table, placetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TablesDeletedTable, user.TablesDeletedColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTablesReserved queries the tables_reserved edge of a User.
func (c *UserClient) QueryTablesReserved(u *User) *PlaceTableQuery {
	query := (&PlaceTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(placetable.Table, placetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TablesReservedTable, user.TablesReservedColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTablesWaited queries the tables_waited edge of a User.
func (c *UserClient) QueryTablesWaited(u *User) *PlaceTableQuery {
	query := (&PlaceTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(placetable.Table, placetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TablesWaitedTable, user.TablesWaitedColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffs queries the staffs edge of a User.
func (c *UserClient) QueryStaffs(u *User) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.StaffsTable, user.StaffsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedMenus queries the created_menus edge of a User.
func (c *UserClient) QueryCreatedMenus(u *User) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.CreatedMenusTable, user.CreatedMenusPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdatedMenus queries the updated_menus edge of a User.
func (c *UserClient) QueryUpdatedMenus(u *User) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.UpdatedMenusTable, user.UpdatedMenusPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlans queries the plans edge of a User.
func (c *UserClient) QueryPlans(u *User) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.PlansTable, user.PlansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(u *User) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrainers queries the trainers edge of a User.
func (c *UserClient) QueryTrainers(u *User) *TrainerQuery {
	query := (&TrainerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(trainer.Table, trainer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.TrainersTable, user.TrainersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberOf queries the memberOf edge of a User.
func (c *UserClient) QueryMemberOf(u *User) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.MemberOfTable, user.MemberOfPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a User.
func (c *UserClient) QueryCustomer(u *User) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.CustomerTable, user.CustomerPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPurchasedTickets queries the purchasedTickets edge of a User.
func (c *UserClient) QueryPurchasedTickets(u *User) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PurchasedTicketsTable, user.PurchasedTicketsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserBusinessClient is a client for the UserBusiness schema.
type UserBusinessClient struct {
	config
}

// NewUserBusinessClient returns a client for the UserBusiness from the given config.
func NewUserBusinessClient(c config) *UserBusinessClient {
	return &UserBusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userbusiness.Hooks(f(g(h())))`.
func (c *UserBusinessClient) Use(hooks ...Hook) {
	c.hooks.UserBusiness = append(c.hooks.UserBusiness, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userbusiness.Intercept(f(g(h())))`.
func (c *UserBusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBusiness = append(c.inters.UserBusiness, interceptors...)
}

// Create returns a builder for creating a UserBusiness entity.
func (c *UserBusinessClient) Create() *UserBusinessCreate {
	mutation := newUserBusinessMutation(c.config, OpCreate)
	return &UserBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBusiness entities.
func (c *UserBusinessClient) CreateBulk(builders ...*UserBusinessCreate) *UserBusinessCreateBulk {
	return &UserBusinessCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBusinessClient) MapCreateBulk(slice any, setFunc func(*UserBusinessCreate, int)) *UserBusinessCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBusinessCreateBulk{err: fmt.Errorf("calling to UserBusinessClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBusinessCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBusiness.
func (c *UserBusinessClient) Update() *UserBusinessUpdate {
	mutation := newUserBusinessMutation(c.config, OpUpdate)
	return &UserBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBusinessClient) UpdateOne(ub *UserBusiness) *UserBusinessUpdateOne {
	mutation := newUserBusinessMutation(c.config, OpUpdateOne, withUserBusiness(ub))
	return &UserBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserBusinessClient) UpdateOneID(id string) *UserBusinessUpdateOne {
	mutation := newUserBusinessMutation(c.config, OpUpdateOne, withUserBusinessID(id))
	return &UserBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBusiness.
func (c *UserBusinessClient) Delete() *UserBusinessDelete {
	mutation := newUserBusinessMutation(c.config, OpDelete)
	return &UserBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserBusinessClient) DeleteOne(ub *UserBusiness) *UserBusinessDeleteOne {
	return c.DeleteOneID(ub.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserBusinessClient) DeleteOneID(id string) *UserBusinessDeleteOne {
	builder := c.Delete().Where(userbusiness.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserBusinessDeleteOne{builder}
}

// Query returns a query builder for UserBusiness.
func (c *UserBusinessClient) Query() *UserBusinessQuery {
	return &UserBusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a UserBusiness entity by its id.
func (c *UserBusinessClient) Get(ctx context.Context, id string) (*UserBusiness, error) {
	return c.Query().Where(userbusiness.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserBusinessClient) GetX(ctx context.Context, id string) *UserBusiness {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserBusiness.
func (c *UserBusinessClient) QueryUser(ub *UserBusiness) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ub.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userbusiness.Table, userbusiness.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userbusiness.UserTable, userbusiness.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ub.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a UserBusiness.
func (c *UserBusinessClient) QueryBusiness(ub *UserBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ub.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userbusiness.Table, userbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userbusiness.BusinessTable, userbusiness.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(ub.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserBusinessClient) Hooks() []Hook {
	return c.hooks.UserBusiness
}

// Interceptors returns the client interceptors.
func (c *UserBusinessClient) Interceptors() []Interceptor {
	return c.inters.UserBusiness
}

func (c *UserBusinessClient) mutate(ctx context.Context, m *UserBusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserBusiness mutation op: %q", m.Op())
	}
}

// UserFollowBusinessClient is a client for the UserFollowBusiness schema.
type UserFollowBusinessClient struct {
	config
}

// NewUserFollowBusinessClient returns a client for the UserFollowBusiness from the given config.
func NewUserFollowBusinessClient(c config) *UserFollowBusinessClient {
	return &UserFollowBusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowbusiness.Hooks(f(g(h())))`.
func (c *UserFollowBusinessClient) Use(hooks ...Hook) {
	c.hooks.UserFollowBusiness = append(c.hooks.UserFollowBusiness, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowbusiness.Intercept(f(g(h())))`.
func (c *UserFollowBusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowBusiness = append(c.inters.UserFollowBusiness, interceptors...)
}

// Create returns a builder for creating a UserFollowBusiness entity.
func (c *UserFollowBusinessClient) Create() *UserFollowBusinessCreate {
	mutation := newUserFollowBusinessMutation(c.config, OpCreate)
	return &UserFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowBusiness entities.
func (c *UserFollowBusinessClient) CreateBulk(builders ...*UserFollowBusinessCreate) *UserFollowBusinessCreateBulk {
	return &UserFollowBusinessCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserFollowBusinessClient) MapCreateBulk(slice any, setFunc func(*UserFollowBusinessCreate, int)) *UserFollowBusinessCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserFollowBusinessCreateBulk{err: fmt.Errorf("calling to UserFollowBusinessClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserFollowBusinessCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserFollowBusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowBusiness.
func (c *UserFollowBusinessClient) Update() *UserFollowBusinessUpdate {
	mutation := newUserFollowBusinessMutation(c.config, OpUpdate)
	return &UserFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowBusinessClient) UpdateOne(ufb *UserFollowBusiness) *UserFollowBusinessUpdateOne {
	mutation := newUserFollowBusinessMutation(c.config, OpUpdateOne, withUserFollowBusiness(ufb))
	return &UserFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowBusinessClient) UpdateOneID(id string) *UserFollowBusinessUpdateOne {
	mutation := newUserFollowBusinessMutation(c.config, OpUpdateOne, withUserFollowBusinessID(id))
	return &UserFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowBusiness.
func (c *UserFollowBusinessClient) Delete() *UserFollowBusinessDelete {
	mutation := newUserFollowBusinessMutation(c.config, OpDelete)
	return &UserFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowBusinessClient) DeleteOne(ufb *UserFollowBusiness) *UserFollowBusinessDeleteOne {
	return c.DeleteOneID(ufb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowBusinessClient) DeleteOneID(id string) *UserFollowBusinessDeleteOne {
	builder := c.Delete().Where(userfollowbusiness.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowBusinessDeleteOne{builder}
}

// Query returns a query builder for UserFollowBusiness.
func (c *UserFollowBusinessClient) Query() *UserFollowBusinessQuery {
	return &UserFollowBusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowBusiness entity by its id.
func (c *UserFollowBusinessClient) Get(ctx context.Context, id string) (*UserFollowBusiness, error) {
	return c.Query().Where(userfollowbusiness.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowBusinessClient) GetX(ctx context.Context, id string) *UserFollowBusiness {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserFollowBusiness.
func (c *UserFollowBusinessClient) QueryUser(ufb *UserFollowBusiness) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowbusiness.Table, userfollowbusiness.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowbusiness.UserTable, userfollowbusiness.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ufb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a UserFollowBusiness.
func (c *UserFollowBusinessClient) QueryBusiness(ufb *UserFollowBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowbusiness.Table, userfollowbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowbusiness.BusinessTable, userfollowbusiness.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(ufb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowBusinessClient) Hooks() []Hook {
	return c.hooks.UserFollowBusiness
}

// Interceptors returns the client interceptors.
func (c *UserFollowBusinessClient) Interceptors() []Interceptor {
	return c.inters.UserFollowBusiness
}

func (c *UserFollowBusinessClient) mutate(ctx context.Context, m *UserFollowBusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowBusiness mutation op: %q", m.Op())
	}
}

// UserFollowEventClient is a client for the UserFollowEvent schema.
type UserFollowEventClient struct {
	config
}

// NewUserFollowEventClient returns a client for the UserFollowEvent from the given config.
func NewUserFollowEventClient(c config) *UserFollowEventClient {
	return &UserFollowEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowevent.Hooks(f(g(h())))`.
func (c *UserFollowEventClient) Use(hooks ...Hook) {
	c.hooks.UserFollowEvent = append(c.hooks.UserFollowEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowevent.Intercept(f(g(h())))`.
func (c *UserFollowEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowEvent = append(c.inters.UserFollowEvent, interceptors...)
}

// Create returns a builder for creating a UserFollowEvent entity.
func (c *UserFollowEventClient) Create() *UserFollowEventCreate {
	mutation := newUserFollowEventMutation(c.config, OpCreate)
	return &UserFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowEvent entities.
func (c *UserFollowEventClient) CreateBulk(builders ...*UserFollowEventCreate) *UserFollowEventCreateBulk {
	return &UserFollowEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserFollowEventClient) MapCreateBulk(slice any, setFunc func(*UserFollowEventCreate, int)) *UserFollowEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserFollowEventCreateBulk{err: fmt.Errorf("calling to UserFollowEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserFollowEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserFollowEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowEvent.
func (c *UserFollowEventClient) Update() *UserFollowEventUpdate {
	mutation := newUserFollowEventMutation(c.config, OpUpdate)
	return &UserFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowEventClient) UpdateOne(ufe *UserFollowEvent) *UserFollowEventUpdateOne {
	mutation := newUserFollowEventMutation(c.config, OpUpdateOne, withUserFollowEvent(ufe))
	return &UserFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowEventClient) UpdateOneID(id string) *UserFollowEventUpdateOne {
	mutation := newUserFollowEventMutation(c.config, OpUpdateOne, withUserFollowEventID(id))
	return &UserFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowEvent.
func (c *UserFollowEventClient) Delete() *UserFollowEventDelete {
	mutation := newUserFollowEventMutation(c.config, OpDelete)
	return &UserFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowEventClient) DeleteOne(ufe *UserFollowEvent) *UserFollowEventDeleteOne {
	return c.DeleteOneID(ufe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowEventClient) DeleteOneID(id string) *UserFollowEventDeleteOne {
	builder := c.Delete().Where(userfollowevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowEventDeleteOne{builder}
}

// Query returns a query builder for UserFollowEvent.
func (c *UserFollowEventClient) Query() *UserFollowEventQuery {
	return &UserFollowEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowEvent entity by its id.
func (c *UserFollowEventClient) Get(ctx context.Context, id string) (*UserFollowEvent, error) {
	return c.Query().Where(userfollowevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowEventClient) GetX(ctx context.Context, id string) *UserFollowEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserFollowEvent.
func (c *UserFollowEventClient) QueryUser(ufe *UserFollowEvent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowevent.Table, userfollowevent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowevent.UserTable, userfollowevent.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ufe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a UserFollowEvent.
func (c *UserFollowEventClient) QueryEvent(ufe *UserFollowEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowevent.Table, userfollowevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userfollowevent.EventTable, userfollowevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(ufe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowEventClient) Hooks() []Hook {
	return c.hooks.UserFollowEvent
}

// Interceptors returns the client interceptors.
func (c *UserFollowEventClient) Interceptors() []Interceptor {
	return c.inters.UserFollowEvent
}

func (c *UserFollowEventClient) mutate(ctx context.Context, m *UserFollowEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowEvent mutation op: %q", m.Op())
	}
}

// UserFollowPlaceClient is a client for the UserFollowPlace schema.
type UserFollowPlaceClient struct {
	config
}

// NewUserFollowPlaceClient returns a client for the UserFollowPlace from the given config.
func NewUserFollowPlaceClient(c config) *UserFollowPlaceClient {
	return &UserFollowPlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowplace.Hooks(f(g(h())))`.
func (c *UserFollowPlaceClient) Use(hooks ...Hook) {
	c.hooks.UserFollowPlace = append(c.hooks.UserFollowPlace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowplace.Intercept(f(g(h())))`.
func (c *UserFollowPlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowPlace = append(c.inters.UserFollowPlace, interceptors...)
}

// Create returns a builder for creating a UserFollowPlace entity.
func (c *UserFollowPlaceClient) Create() *UserFollowPlaceCreate {
	mutation := newUserFollowPlaceMutation(c.config, OpCreate)
	return &UserFollowPlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowPlace entities.
func (c *UserFollowPlaceClient) CreateBulk(builders ...*UserFollowPlaceCreate) *UserFollowPlaceCreateBulk {
	return &UserFollowPlaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserFollowPlaceClient) MapCreateBulk(slice any, setFunc func(*UserFollowPlaceCreate, int)) *UserFollowPlaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserFollowPlaceCreateBulk{err: fmt.Errorf("calling to UserFollowPlaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserFollowPlaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserFollowPlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowPlace.
func (c *UserFollowPlaceClient) Update() *UserFollowPlaceUpdate {
	mutation := newUserFollowPlaceMutation(c.config, OpUpdate)
	return &UserFollowPlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowPlaceClient) UpdateOne(ufp *UserFollowPlace) *UserFollowPlaceUpdateOne {
	mutation := newUserFollowPlaceMutation(c.config, OpUpdateOne, withUserFollowPlace(ufp))
	return &UserFollowPlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowPlaceClient) UpdateOneID(id string) *UserFollowPlaceUpdateOne {
	mutation := newUserFollowPlaceMutation(c.config, OpUpdateOne, withUserFollowPlaceID(id))
	return &UserFollowPlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowPlace.
func (c *UserFollowPlaceClient) Delete() *UserFollowPlaceDelete {
	mutation := newUserFollowPlaceMutation(c.config, OpDelete)
	return &UserFollowPlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowPlaceClient) DeleteOne(ufp *UserFollowPlace) *UserFollowPlaceDeleteOne {
	return c.DeleteOneID(ufp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowPlaceClient) DeleteOneID(id string) *UserFollowPlaceDeleteOne {
	builder := c.Delete().Where(userfollowplace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowPlaceDeleteOne{builder}
}

// Query returns a query builder for UserFollowPlace.
func (c *UserFollowPlaceClient) Query() *UserFollowPlaceQuery {
	return &UserFollowPlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowPlace},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowPlace entity by its id.
func (c *UserFollowPlaceClient) Get(ctx context.Context, id string) (*UserFollowPlace, error) {
	return c.Query().Where(userfollowplace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowPlaceClient) GetX(ctx context.Context, id string) *UserFollowPlace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserFollowPlace.
func (c *UserFollowPlaceClient) QueryUser(ufp *UserFollowPlace) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowplace.Table, userfollowplace.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowplace.UserTable, userfollowplace.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ufp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a UserFollowPlace.
func (c *UserFollowPlaceClient) QueryPlace(ufp *UserFollowPlace) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowplace.Table, userfollowplace.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userfollowplace.PlaceTable, userfollowplace.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(ufp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowPlaceClient) Hooks() []Hook {
	return c.hooks.UserFollowPlace
}

// Interceptors returns the client interceptors.
func (c *UserFollowPlaceClient) Interceptors() []Interceptor {
	return c.inters.UserFollowPlace
}

func (c *UserFollowPlaceClient) mutate(ctx context.Context, m *UserFollowPlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowPlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowPlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowPlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowPlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowPlace mutation op: %q", m.Op())
	}
}

// UserFollowUserClient is a client for the UserFollowUser schema.
type UserFollowUserClient struct {
	config
}

// NewUserFollowUserClient returns a client for the UserFollowUser from the given config.
func NewUserFollowUserClient(c config) *UserFollowUserClient {
	return &UserFollowUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowuser.Hooks(f(g(h())))`.
func (c *UserFollowUserClient) Use(hooks ...Hook) {
	c.hooks.UserFollowUser = append(c.hooks.UserFollowUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowuser.Intercept(f(g(h())))`.
func (c *UserFollowUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowUser = append(c.inters.UserFollowUser, interceptors...)
}

// Create returns a builder for creating a UserFollowUser entity.
func (c *UserFollowUserClient) Create() *UserFollowUserCreate {
	mutation := newUserFollowUserMutation(c.config, OpCreate)
	return &UserFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowUser entities.
func (c *UserFollowUserClient) CreateBulk(builders ...*UserFollowUserCreate) *UserFollowUserCreateBulk {
	return &UserFollowUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserFollowUserClient) MapCreateBulk(slice any, setFunc func(*UserFollowUserCreate, int)) *UserFollowUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserFollowUserCreateBulk{err: fmt.Errorf("calling to UserFollowUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserFollowUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserFollowUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowUser.
func (c *UserFollowUserClient) Update() *UserFollowUserUpdate {
	mutation := newUserFollowUserMutation(c.config, OpUpdate)
	return &UserFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowUserClient) UpdateOne(ufu *UserFollowUser) *UserFollowUserUpdateOne {
	mutation := newUserFollowUserMutation(c.config, OpUpdateOne, withUserFollowUser(ufu))
	return &UserFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowUserClient) UpdateOneID(id string) *UserFollowUserUpdateOne {
	mutation := newUserFollowUserMutation(c.config, OpUpdateOne, withUserFollowUserID(id))
	return &UserFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowUser.
func (c *UserFollowUserClient) Delete() *UserFollowUserDelete {
	mutation := newUserFollowUserMutation(c.config, OpDelete)
	return &UserFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowUserClient) DeleteOne(ufu *UserFollowUser) *UserFollowUserDeleteOne {
	return c.DeleteOneID(ufu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowUserClient) DeleteOneID(id string) *UserFollowUserDeleteOne {
	builder := c.Delete().Where(userfollowuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowUserDeleteOne{builder}
}

// Query returns a query builder for UserFollowUser.
func (c *UserFollowUserClient) Query() *UserFollowUserQuery {
	return &UserFollowUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowUser},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowUser entity by its id.
func (c *UserFollowUserClient) Get(ctx context.Context, id string) (*UserFollowUser, error) {
	return c.Query().Where(userfollowuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowUserClient) GetX(ctx context.Context, id string) *UserFollowUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFollower queries the follower edge of a UserFollowUser.
func (c *UserFollowUserClient) QueryFollower(ufu *UserFollowUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowuser.Table, userfollowuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowuser.FollowerTable, userfollowuser.FollowerColumn),
		)
		fromV = sqlgraph.Neighbors(ufu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowed queries the followed edge of a UserFollowUser.
func (c *UserFollowUserClient) QueryFollowed(ufu *UserFollowUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowuser.Table, userfollowuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowuser.FollowedTable, userfollowuser.FollowedColumn),
		)
		fromV = sqlgraph.Neighbors(ufu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowUserClient) Hooks() []Hook {
	return c.hooks.UserFollowUser
}

// Interceptors returns the client interceptors.
func (c *UserFollowUserClient) Interceptors() []Interceptor {
	return c.inters.UserFollowUser
}

func (c *UserFollowUserClient) mutate(ctx context.Context, m *UserFollowUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowUser mutation op: %q", m.Op())
	}
}

// UserLikePlaceClient is a client for the UserLikePlace schema.
type UserLikePlaceClient struct {
	config
}

// NewUserLikePlaceClient returns a client for the UserLikePlace from the given config.
func NewUserLikePlaceClient(c config) *UserLikePlaceClient {
	return &UserLikePlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userlikeplace.Hooks(f(g(h())))`.
func (c *UserLikePlaceClient) Use(hooks ...Hook) {
	c.hooks.UserLikePlace = append(c.hooks.UserLikePlace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userlikeplace.Intercept(f(g(h())))`.
func (c *UserLikePlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserLikePlace = append(c.inters.UserLikePlace, interceptors...)
}

// Create returns a builder for creating a UserLikePlace entity.
func (c *UserLikePlaceClient) Create() *UserLikePlaceCreate {
	mutation := newUserLikePlaceMutation(c.config, OpCreate)
	return &UserLikePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserLikePlace entities.
func (c *UserLikePlaceClient) CreateBulk(builders ...*UserLikePlaceCreate) *UserLikePlaceCreateBulk {
	return &UserLikePlaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserLikePlaceClient) MapCreateBulk(slice any, setFunc func(*UserLikePlaceCreate, int)) *UserLikePlaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserLikePlaceCreateBulk{err: fmt.Errorf("calling to UserLikePlaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserLikePlaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserLikePlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserLikePlace.
func (c *UserLikePlaceClient) Update() *UserLikePlaceUpdate {
	mutation := newUserLikePlaceMutation(c.config, OpUpdate)
	return &UserLikePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserLikePlaceClient) UpdateOne(ulp *UserLikePlace) *UserLikePlaceUpdateOne {
	mutation := newUserLikePlaceMutation(c.config, OpUpdateOne, withUserLikePlace(ulp))
	return &UserLikePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserLikePlaceClient) UpdateOneID(id string) *UserLikePlaceUpdateOne {
	mutation := newUserLikePlaceMutation(c.config, OpUpdateOne, withUserLikePlaceID(id))
	return &UserLikePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserLikePlace.
func (c *UserLikePlaceClient) Delete() *UserLikePlaceDelete {
	mutation := newUserLikePlaceMutation(c.config, OpDelete)
	return &UserLikePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserLikePlaceClient) DeleteOne(ulp *UserLikePlace) *UserLikePlaceDeleteOne {
	return c.DeleteOneID(ulp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserLikePlaceClient) DeleteOneID(id string) *UserLikePlaceDeleteOne {
	builder := c.Delete().Where(userlikeplace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserLikePlaceDeleteOne{builder}
}

// Query returns a query builder for UserLikePlace.
func (c *UserLikePlaceClient) Query() *UserLikePlaceQuery {
	return &UserLikePlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserLikePlace},
		inters: c.Interceptors(),
	}
}

// Get returns a UserLikePlace entity by its id.
func (c *UserLikePlaceClient) Get(ctx context.Context, id string) (*UserLikePlace, error) {
	return c.Query().Where(userlikeplace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserLikePlaceClient) GetX(ctx context.Context, id string) *UserLikePlace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserLikePlace.
func (c *UserLikePlaceClient) QueryUser(ulp *UserLikePlace) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ulp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userlikeplace.Table, userlikeplace.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userlikeplace.UserTable, userlikeplace.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ulp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a UserLikePlace.
func (c *UserLikePlaceClient) QueryPlace(ulp *UserLikePlace) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ulp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userlikeplace.Table, userlikeplace.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userlikeplace.PlaceTable, userlikeplace.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(ulp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserLikePlaceClient) Hooks() []Hook {
	return c.hooks.UserLikePlace
}

// Interceptors returns the client interceptors.
func (c *UserLikePlaceClient) Interceptors() []Interceptor {
	return c.inters.UserLikePlace
}

func (c *UserLikePlaceClient) mutate(ctx context.Context, m *UserLikePlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserLikePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserLikePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserLikePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserLikePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserLikePlace mutation op: %q", m.Op())
	}
}

// WebsiteClient is a client for the Website schema.
type WebsiteClient struct {
	config
}

// NewWebsiteClient returns a client for the Website from the given config.
func NewWebsiteClient(c config) *WebsiteClient {
	return &WebsiteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `website.Hooks(f(g(h())))`.
func (c *WebsiteClient) Use(hooks ...Hook) {
	c.hooks.Website = append(c.hooks.Website, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `website.Intercept(f(g(h())))`.
func (c *WebsiteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Website = append(c.inters.Website, interceptors...)
}

// Create returns a builder for creating a Website entity.
func (c *WebsiteClient) Create() *WebsiteCreate {
	mutation := newWebsiteMutation(c.config, OpCreate)
	return &WebsiteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Website entities.
func (c *WebsiteClient) CreateBulk(builders ...*WebsiteCreate) *WebsiteCreateBulk {
	return &WebsiteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebsiteClient) MapCreateBulk(slice any, setFunc func(*WebsiteCreate, int)) *WebsiteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebsiteCreateBulk{err: fmt.Errorf("calling to WebsiteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebsiteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebsiteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Website.
func (c *WebsiteClient) Update() *WebsiteUpdate {
	mutation := newWebsiteMutation(c.config, OpUpdate)
	return &WebsiteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebsiteClient) UpdateOne(w *Website) *WebsiteUpdateOne {
	mutation := newWebsiteMutation(c.config, OpUpdateOne, withWebsite(w))
	return &WebsiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebsiteClient) UpdateOneID(id string) *WebsiteUpdateOne {
	mutation := newWebsiteMutation(c.config, OpUpdateOne, withWebsiteID(id))
	return &WebsiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Website.
func (c *WebsiteClient) Delete() *WebsiteDelete {
	mutation := newWebsiteMutation(c.config, OpDelete)
	return &WebsiteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebsiteClient) DeleteOne(w *Website) *WebsiteDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebsiteClient) DeleteOneID(id string) *WebsiteDeleteOne {
	builder := c.Delete().Where(website.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebsiteDeleteOne{builder}
}

// Query returns a query builder for Website.
func (c *WebsiteClient) Query() *WebsiteQuery {
	return &WebsiteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebsite},
		inters: c.Interceptors(),
	}
}

// Get returns a Website entity by its id.
func (c *WebsiteClient) Get(ctx context.Context, id string) (*Website, error) {
	return c.Query().Where(website.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebsiteClient) GetX(ctx context.Context, id string) *Website {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a Website.
func (c *WebsiteClient) QueryBusiness(w *Website) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(website.Table, website.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, website.BusinessTable, website.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomBlocks queries the customBlocks edge of a Website.
func (c *WebsiteClient) QueryCustomBlocks(w *Website) *CustomBlockQuery {
	query := (&CustomBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(website.Table, website.FieldID, id),
			sqlgraph.To(customblock.Table, customblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, website.CustomBlocksTable, website.CustomBlocksColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Website.
func (c *WebsiteClient) QueryAssets(w *Website) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(website.Table, website.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, website.AssetsTable, website.AssetsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WebsiteClient) Hooks() []Hook {
	return c.hooks.Website
}

// Interceptors returns the client interceptors.
func (c *WebsiteClient) Interceptors() []Interceptor {
	return c.inters.Website
}

func (c *WebsiteClient) mutate(ctx context.Context, m *WebsiteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebsiteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebsiteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebsiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebsiteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Website mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccountSettings, AccountWallet, Amenity, Booking, Business,
		BusinessFollowBusiness, BusinessFollowEvent, BusinessFollowUser, Category,
		CategoryAssignment, Chat, Comment, CustomBlock, Event, EventOrganizer, FAQ,
		FeatureRelease, Fitness, Help, InventoryAttribute, InventoryType, Like, Media,
		Menu, MenuItem, Notification, Order, OrderItem, Payment, Permission, Place,
		PlaceInventory, PlaceInventoryAttribute, PlaceTable, Plan, Post, Price, Rating,
		Reaction, Reservation, ReservationBlock, Resourse, Review, Room, RoomCategory,
		Staff, Subscription, Template, Ticket, TicketOption, Trainer,
		TransactionHistory, User, UserBusiness, UserFollowBusiness, UserFollowEvent,
		UserFollowPlace, UserFollowUser, UserLikePlace, Website []ent.Hook
	}
	inters struct {
		AccountSettings, AccountWallet, Amenity, Booking, Business,
		BusinessFollowBusiness, BusinessFollowEvent, BusinessFollowUser, Category,
		CategoryAssignment, Chat, Comment, CustomBlock, Event, EventOrganizer, FAQ,
		FeatureRelease, Fitness, Help, InventoryAttribute, InventoryType, Like, Media,
		Menu, MenuItem, Notification, Order, OrderItem, Payment, Permission, Place,
		PlaceInventory, PlaceInventoryAttribute, PlaceTable, Plan, Post, Price, Rating,
		Reaction, Reservation, ReservationBlock, Resourse, Review, Room, RoomCategory,
		Staff, Subscription, Template, Ticket, TicketOption, Trainer,
		TransactionHistory, User, UserBusiness, UserFollowBusiness, UserFollowEvent,
		UserFollowPlace, UserFollowUser, UserLikePlace, Website []ent.Interceptor
	}
)
