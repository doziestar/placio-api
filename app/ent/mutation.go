// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"placio-app/ent/accountsettings"
	"placio-app/ent/accountwallet"
	"placio-app/ent/amenity"
	"placio-app/ent/booking"
	"placio-app/ent/business"
	"placio-app/ent/businessfollowbusiness"
	"placio-app/ent/businessfollowevent"
	"placio-app/ent/businessfollowuser"
	"placio-app/ent/category"
	"placio-app/ent/categoryassignment"
	"placio-app/ent/comment"
	"placio-app/ent/customblock"
	"placio-app/ent/event"
	"placio-app/ent/eventorganizer"
	"placio-app/ent/faq"
	"placio-app/ent/featurerelease"
	"placio-app/ent/fitness"
	"placio-app/ent/help"
	"placio-app/ent/inventoryattribute"
	"placio-app/ent/inventorytype"
	"placio-app/ent/like"
	"placio-app/ent/media"
	"placio-app/ent/menu"
	"placio-app/ent/menuitem"
	"placio-app/ent/notification"
	"placio-app/ent/order"
	"placio-app/ent/orderitem"
	"placio-app/ent/permission"
	"placio-app/ent/place"
	"placio-app/ent/placeinventory"
	"placio-app/ent/placeinventoryattribute"
	"placio-app/ent/placetable"
	"placio-app/ent/plan"
	"placio-app/ent/post"
	"placio-app/ent/predicate"
	"placio-app/ent/price"
	"placio-app/ent/rating"
	"placio-app/ent/reservation"
	"placio-app/ent/reservationblock"
	"placio-app/ent/review"
	"placio-app/ent/room"
	"placio-app/ent/roomcategory"
	"placio-app/ent/staff"
	"placio-app/ent/subscription"
	"placio-app/ent/template"
	"placio-app/ent/ticket"
	"placio-app/ent/ticketoption"
	"placio-app/ent/trainer"
	"placio-app/ent/transactionhistory"
	"placio-app/ent/user"
	"placio-app/ent/userbusiness"
	"placio-app/ent/userfollowbusiness"
	"placio-app/ent/userfollowevent"
	"placio-app/ent/userfollowplace"
	"placio-app/ent/userfollowuser"
	"placio-app/ent/userlikeplace"
	"placio-app/ent/website"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/auth0/go-auth0/management"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountSettings         = "AccountSettings"
	TypeAccountWallet           = "AccountWallet"
	TypeAmenity                 = "Amenity"
	TypeBooking                 = "Booking"
	TypeBusiness                = "Business"
	TypeBusinessFollowBusiness  = "BusinessFollowBusiness"
	TypeBusinessFollowEvent     = "BusinessFollowEvent"
	TypeBusinessFollowUser      = "BusinessFollowUser"
	TypeCategory                = "Category"
	TypeCategoryAssignment      = "CategoryAssignment"
	TypeChat                    = "Chat"
	TypeComment                 = "Comment"
	TypeCustomBlock             = "CustomBlock"
	TypeEvent                   = "Event"
	TypeEventOrganizer          = "EventOrganizer"
	TypeFAQ                     = "FAQ"
	TypeFeatureRelease          = "FeatureRelease"
	TypeFitness                 = "Fitness"
	TypeHelp                    = "Help"
	TypeInventoryAttribute      = "InventoryAttribute"
	TypeInventoryType           = "InventoryType"
	TypeLike                    = "Like"
	TypeMedia                   = "Media"
	TypeMenu                    = "Menu"
	TypeMenuItem                = "MenuItem"
	TypeNotification            = "Notification"
	TypeOrder                   = "Order"
	TypeOrderItem               = "OrderItem"
	TypePayment                 = "Payment"
	TypePermission              = "Permission"
	TypePlace                   = "Place"
	TypePlaceInventory          = "PlaceInventory"
	TypePlaceInventoryAttribute = "PlaceInventoryAttribute"
	TypePlaceTable              = "PlaceTable"
	TypePlan                    = "Plan"
	TypePost                    = "Post"
	TypePrice                   = "Price"
	TypeRating                  = "Rating"
	TypeReaction                = "Reaction"
	TypeReservation             = "Reservation"
	TypeReservationBlock        = "ReservationBlock"
	TypeResourse                = "Resourse"
	TypeReview                  = "Review"
	TypeRoom                    = "Room"
	TypeRoomCategory            = "RoomCategory"
	TypeStaff                   = "Staff"
	TypeSubscription            = "Subscription"
	TypeTemplate                = "Template"
	TypeTicket                  = "Ticket"
	TypeTicketOption            = "TicketOption"
	TypeTrainer                 = "Trainer"
	TypeTransactionHistory      = "TransactionHistory"
	TypeUser                    = "User"
	TypeUserBusiness            = "UserBusiness"
	TypeUserFollowBusiness      = "UserFollowBusiness"
	TypeUserFollowEvent         = "UserFollowEvent"
	TypeUserFollowPlace         = "UserFollowPlace"
	TypeUserFollowUser          = "UserFollowUser"
	TypeUserLikePlace           = "UserLikePlace"
	TypeWebsite                 = "Website"
)

// AccountSettingsMutation represents an operation that mutates the AccountSettings nodes in the graph.
type AccountSettingsMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	_TwoFactorAuthentication *bool
	_BlockedUsers            *[]string
	append_BlockedUsers      []string
	_MutedUsers              *[]string
	append_MutedUsers        []string
	clearedFields            map[string]struct{}
	business_account         *string
	clearedbusiness_account  bool
	done                     bool
	oldValue                 func(context.Context) (*AccountSettings, error)
	predicates               []predicate.AccountSettings
}

var _ ent.Mutation = (*AccountSettingsMutation)(nil)

// accountsettingsOption allows management of the mutation configuration using functional options.
type accountsettingsOption func(*AccountSettingsMutation)

// newAccountSettingsMutation creates new mutation for the AccountSettings entity.
func newAccountSettingsMutation(c config, op Op, opts ...accountsettingsOption) *AccountSettingsMutation {
	m := &AccountSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountSettingsID sets the ID field of the mutation.
func withAccountSettingsID(id string) accountsettingsOption {
	return func(m *AccountSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountSettings
		)
		m.oldValue = func(ctx context.Context) (*AccountSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountSettings sets the old AccountSettings of the mutation.
func withAccountSettings(node *AccountSettings) accountsettingsOption {
	return func(m *AccountSettingsMutation) {
		m.oldValue = func(context.Context) (*AccountSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountSettings entities.
func (m *AccountSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTwoFactorAuthentication sets the "TwoFactorAuthentication" field.
func (m *AccountSettingsMutation) SetTwoFactorAuthentication(b bool) {
	m._TwoFactorAuthentication = &b
}

// TwoFactorAuthentication returns the value of the "TwoFactorAuthentication" field in the mutation.
func (m *AccountSettingsMutation) TwoFactorAuthentication() (r bool, exists bool) {
	v := m._TwoFactorAuthentication
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactorAuthentication returns the old "TwoFactorAuthentication" field's value of the AccountSettings entity.
// If the AccountSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSettingsMutation) OldTwoFactorAuthentication(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactorAuthentication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactorAuthentication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactorAuthentication: %w", err)
	}
	return oldValue.TwoFactorAuthentication, nil
}

// ResetTwoFactorAuthentication resets all changes to the "TwoFactorAuthentication" field.
func (m *AccountSettingsMutation) ResetTwoFactorAuthentication() {
	m._TwoFactorAuthentication = nil
}

// SetBlockedUsers sets the "BlockedUsers" field.
func (m *AccountSettingsMutation) SetBlockedUsers(s []string) {
	m._BlockedUsers = &s
	m.append_BlockedUsers = nil
}

// BlockedUsers returns the value of the "BlockedUsers" field in the mutation.
func (m *AccountSettingsMutation) BlockedUsers() (r []string, exists bool) {
	v := m._BlockedUsers
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockedUsers returns the old "BlockedUsers" field's value of the AccountSettings entity.
// If the AccountSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSettingsMutation) OldBlockedUsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockedUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockedUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockedUsers: %w", err)
	}
	return oldValue.BlockedUsers, nil
}

// AppendBlockedUsers adds s to the "BlockedUsers" field.
func (m *AccountSettingsMutation) AppendBlockedUsers(s []string) {
	m.append_BlockedUsers = append(m.append_BlockedUsers, s...)
}

// AppendedBlockedUsers returns the list of values that were appended to the "BlockedUsers" field in this mutation.
func (m *AccountSettingsMutation) AppendedBlockedUsers() ([]string, bool) {
	if len(m.append_BlockedUsers) == 0 {
		return nil, false
	}
	return m.append_BlockedUsers, true
}

// ResetBlockedUsers resets all changes to the "BlockedUsers" field.
func (m *AccountSettingsMutation) ResetBlockedUsers() {
	m._BlockedUsers = nil
	m.append_BlockedUsers = nil
}

// SetMutedUsers sets the "MutedUsers" field.
func (m *AccountSettingsMutation) SetMutedUsers(s []string) {
	m._MutedUsers = &s
	m.append_MutedUsers = nil
}

// MutedUsers returns the value of the "MutedUsers" field in the mutation.
func (m *AccountSettingsMutation) MutedUsers() (r []string, exists bool) {
	v := m._MutedUsers
	if v == nil {
		return
	}
	return *v, true
}

// OldMutedUsers returns the old "MutedUsers" field's value of the AccountSettings entity.
// If the AccountSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSettingsMutation) OldMutedUsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMutedUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMutedUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMutedUsers: %w", err)
	}
	return oldValue.MutedUsers, nil
}

// AppendMutedUsers adds s to the "MutedUsers" field.
func (m *AccountSettingsMutation) AppendMutedUsers(s []string) {
	m.append_MutedUsers = append(m.append_MutedUsers, s...)
}

// AppendedMutedUsers returns the list of values that were appended to the "MutedUsers" field in this mutation.
func (m *AccountSettingsMutation) AppendedMutedUsers() ([]string, bool) {
	if len(m.append_MutedUsers) == 0 {
		return nil, false
	}
	return m.append_MutedUsers, true
}

// ResetMutedUsers resets all changes to the "MutedUsers" field.
func (m *AccountSettingsMutation) ResetMutedUsers() {
	m._MutedUsers = nil
	m.append_MutedUsers = nil
}

// SetBusinessAccountID sets the "business_account" edge to the Business entity by id.
func (m *AccountSettingsMutation) SetBusinessAccountID(id string) {
	m.business_account = &id
}

// ClearBusinessAccount clears the "business_account" edge to the Business entity.
func (m *AccountSettingsMutation) ClearBusinessAccount() {
	m.clearedbusiness_account = true
}

// BusinessAccountCleared reports if the "business_account" edge to the Business entity was cleared.
func (m *AccountSettingsMutation) BusinessAccountCleared() bool {
	return m.clearedbusiness_account
}

// BusinessAccountID returns the "business_account" edge ID in the mutation.
func (m *AccountSettingsMutation) BusinessAccountID() (id string, exists bool) {
	if m.business_account != nil {
		return *m.business_account, true
	}
	return
}

// BusinessAccountIDs returns the "business_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessAccountID instead. It exists only for internal usage by the builders.
func (m *AccountSettingsMutation) BusinessAccountIDs() (ids []string) {
	if id := m.business_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessAccount resets all changes to the "business_account" edge.
func (m *AccountSettingsMutation) ResetBusinessAccount() {
	m.business_account = nil
	m.clearedbusiness_account = false
}

// Where appends a list predicates to the AccountSettingsMutation builder.
func (m *AccountSettingsMutation) Where(ps ...predicate.AccountSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountSettings).
func (m *AccountSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountSettingsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._TwoFactorAuthentication != nil {
		fields = append(fields, accountsettings.FieldTwoFactorAuthentication)
	}
	if m._BlockedUsers != nil {
		fields = append(fields, accountsettings.FieldBlockedUsers)
	}
	if m._MutedUsers != nil {
		fields = append(fields, accountsettings.FieldMutedUsers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		return m.TwoFactorAuthentication()
	case accountsettings.FieldBlockedUsers:
		return m.BlockedUsers()
	case accountsettings.FieldMutedUsers:
		return m.MutedUsers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		return m.OldTwoFactorAuthentication(ctx)
	case accountsettings.FieldBlockedUsers:
		return m.OldBlockedUsers(ctx)
	case accountsettings.FieldMutedUsers:
		return m.OldMutedUsers(ctx)
	}
	return nil, fmt.Errorf("unknown AccountSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactorAuthentication(v)
		return nil
	case accountsettings.FieldBlockedUsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockedUsers(v)
		return nil
	case accountsettings.FieldMutedUsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMutedUsers(v)
		return nil
	}
	return fmt.Errorf("unknown AccountSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountSettingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountSettingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountSettingsMutation) ResetField(name string) error {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		m.ResetTwoFactorAuthentication()
		return nil
	case accountsettings.FieldBlockedUsers:
		m.ResetBlockedUsers()
		return nil
	case accountsettings.FieldMutedUsers:
		m.ResetMutedUsers()
		return nil
	}
	return fmt.Errorf("unknown AccountSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.business_account != nil {
		edges = append(edges, accountsettings.EdgeBusinessAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		if id := m.business_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbusiness_account {
		edges = append(edges, accountsettings.EdgeBusinessAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		return m.clearedbusiness_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountSettingsMutation) ClearEdge(name string) error {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		m.ClearBusinessAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountSettingsMutation) ResetEdge(name string) error {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		m.ResetBusinessAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountSettings edge %s", name)
}

// AccountWalletMutation represents an operation that mutates the AccountWallet nodes in the graph.
type AccountWalletMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	balance            *float64
	addbalance         *float64
	total_deposited    *float64
	addtotal_deposited *float64
	total_withdrawn    *float64
	addtotal_withdrawn *float64
	total_earned       *float64
	addtotal_earned    *float64
	total_spent        *float64
	addtotal_spent     *float64
	total_refunded     *float64
	addtotal_refunded  *float64
	total_fees         *float64
	addtotal_fees      *float64
	total_tax          *float64
	addtotal_tax       *float64
	total_discount     *float64
	addtotal_discount  *float64
	total_revenue      *float64
	addtotal_revenue   *float64
	total_expenses     *float64
	addtotal_expenses  *float64
	total_profit       *float64
	addtotal_profit    *float64
	total_loss         *float64
	addtotal_loss      *float64
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	business           *string
	clearedbusiness    bool
	done               bool
	oldValue           func(context.Context) (*AccountWallet, error)
	predicates         []predicate.AccountWallet
}

var _ ent.Mutation = (*AccountWalletMutation)(nil)

// accountwalletOption allows management of the mutation configuration using functional options.
type accountwalletOption func(*AccountWalletMutation)

// newAccountWalletMutation creates new mutation for the AccountWallet entity.
func newAccountWalletMutation(c config, op Op, opts ...accountwalletOption) *AccountWalletMutation {
	m := &AccountWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountWalletID sets the ID field of the mutation.
func withAccountWalletID(id string) accountwalletOption {
	return func(m *AccountWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountWallet
		)
		m.oldValue = func(ctx context.Context) (*AccountWallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountWallet sets the old AccountWallet of the mutation.
func withAccountWallet(node *AccountWallet) accountwalletOption {
	return func(m *AccountWalletMutation) {
		m.oldValue = func(context.Context) (*AccountWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountWallet entities.
func (m *AccountWalletMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountWalletMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountWalletMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountWallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBalance sets the "balance" field.
func (m *AccountWalletMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountWalletMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *AccountWalletMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AccountWalletMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountWalletMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetTotalDeposited sets the "total_deposited" field.
func (m *AccountWalletMutation) SetTotalDeposited(f float64) {
	m.total_deposited = &f
	m.addtotal_deposited = nil
}

// TotalDeposited returns the value of the "total_deposited" field in the mutation.
func (m *AccountWalletMutation) TotalDeposited() (r float64, exists bool) {
	v := m.total_deposited
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDeposited returns the old "total_deposited" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalDeposited(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDeposited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDeposited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDeposited: %w", err)
	}
	return oldValue.TotalDeposited, nil
}

// AddTotalDeposited adds f to the "total_deposited" field.
func (m *AccountWalletMutation) AddTotalDeposited(f float64) {
	if m.addtotal_deposited != nil {
		*m.addtotal_deposited += f
	} else {
		m.addtotal_deposited = &f
	}
}

// AddedTotalDeposited returns the value that was added to the "total_deposited" field in this mutation.
func (m *AccountWalletMutation) AddedTotalDeposited() (r float64, exists bool) {
	v := m.addtotal_deposited
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalDeposited resets all changes to the "total_deposited" field.
func (m *AccountWalletMutation) ResetTotalDeposited() {
	m.total_deposited = nil
	m.addtotal_deposited = nil
}

// SetTotalWithdrawn sets the "total_withdrawn" field.
func (m *AccountWalletMutation) SetTotalWithdrawn(f float64) {
	m.total_withdrawn = &f
	m.addtotal_withdrawn = nil
}

// TotalWithdrawn returns the value of the "total_withdrawn" field in the mutation.
func (m *AccountWalletMutation) TotalWithdrawn() (r float64, exists bool) {
	v := m.total_withdrawn
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalWithdrawn returns the old "total_withdrawn" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalWithdrawn(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalWithdrawn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalWithdrawn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalWithdrawn: %w", err)
	}
	return oldValue.TotalWithdrawn, nil
}

// AddTotalWithdrawn adds f to the "total_withdrawn" field.
func (m *AccountWalletMutation) AddTotalWithdrawn(f float64) {
	if m.addtotal_withdrawn != nil {
		*m.addtotal_withdrawn += f
	} else {
		m.addtotal_withdrawn = &f
	}
}

// AddedTotalWithdrawn returns the value that was added to the "total_withdrawn" field in this mutation.
func (m *AccountWalletMutation) AddedTotalWithdrawn() (r float64, exists bool) {
	v := m.addtotal_withdrawn
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalWithdrawn resets all changes to the "total_withdrawn" field.
func (m *AccountWalletMutation) ResetTotalWithdrawn() {
	m.total_withdrawn = nil
	m.addtotal_withdrawn = nil
}

// SetTotalEarned sets the "total_earned" field.
func (m *AccountWalletMutation) SetTotalEarned(f float64) {
	m.total_earned = &f
	m.addtotal_earned = nil
}

// TotalEarned returns the value of the "total_earned" field in the mutation.
func (m *AccountWalletMutation) TotalEarned() (r float64, exists bool) {
	v := m.total_earned
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalEarned returns the old "total_earned" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalEarned(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalEarned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalEarned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalEarned: %w", err)
	}
	return oldValue.TotalEarned, nil
}

// AddTotalEarned adds f to the "total_earned" field.
func (m *AccountWalletMutation) AddTotalEarned(f float64) {
	if m.addtotal_earned != nil {
		*m.addtotal_earned += f
	} else {
		m.addtotal_earned = &f
	}
}

// AddedTotalEarned returns the value that was added to the "total_earned" field in this mutation.
func (m *AccountWalletMutation) AddedTotalEarned() (r float64, exists bool) {
	v := m.addtotal_earned
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalEarned resets all changes to the "total_earned" field.
func (m *AccountWalletMutation) ResetTotalEarned() {
	m.total_earned = nil
	m.addtotal_earned = nil
}

// SetTotalSpent sets the "total_spent" field.
func (m *AccountWalletMutation) SetTotalSpent(f float64) {
	m.total_spent = &f
	m.addtotal_spent = nil
}

// TotalSpent returns the value of the "total_spent" field in the mutation.
func (m *AccountWalletMutation) TotalSpent() (r float64, exists bool) {
	v := m.total_spent
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSpent returns the old "total_spent" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalSpent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSpent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSpent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSpent: %w", err)
	}
	return oldValue.TotalSpent, nil
}

// AddTotalSpent adds f to the "total_spent" field.
func (m *AccountWalletMutation) AddTotalSpent(f float64) {
	if m.addtotal_spent != nil {
		*m.addtotal_spent += f
	} else {
		m.addtotal_spent = &f
	}
}

// AddedTotalSpent returns the value that was added to the "total_spent" field in this mutation.
func (m *AccountWalletMutation) AddedTotalSpent() (r float64, exists bool) {
	v := m.addtotal_spent
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSpent resets all changes to the "total_spent" field.
func (m *AccountWalletMutation) ResetTotalSpent() {
	m.total_spent = nil
	m.addtotal_spent = nil
}

// SetTotalRefunded sets the "total_refunded" field.
func (m *AccountWalletMutation) SetTotalRefunded(f float64) {
	m.total_refunded = &f
	m.addtotal_refunded = nil
}

// TotalRefunded returns the value of the "total_refunded" field in the mutation.
func (m *AccountWalletMutation) TotalRefunded() (r float64, exists bool) {
	v := m.total_refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRefunded returns the old "total_refunded" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalRefunded(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRefunded: %w", err)
	}
	return oldValue.TotalRefunded, nil
}

// AddTotalRefunded adds f to the "total_refunded" field.
func (m *AccountWalletMutation) AddTotalRefunded(f float64) {
	if m.addtotal_refunded != nil {
		*m.addtotal_refunded += f
	} else {
		m.addtotal_refunded = &f
	}
}

// AddedTotalRefunded returns the value that was added to the "total_refunded" field in this mutation.
func (m *AccountWalletMutation) AddedTotalRefunded() (r float64, exists bool) {
	v := m.addtotal_refunded
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRefunded resets all changes to the "total_refunded" field.
func (m *AccountWalletMutation) ResetTotalRefunded() {
	m.total_refunded = nil
	m.addtotal_refunded = nil
}

// SetTotalFees sets the "total_fees" field.
func (m *AccountWalletMutation) SetTotalFees(f float64) {
	m.total_fees = &f
	m.addtotal_fees = nil
}

// TotalFees returns the value of the "total_fees" field in the mutation.
func (m *AccountWalletMutation) TotalFees() (r float64, exists bool) {
	v := m.total_fees
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalFees returns the old "total_fees" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalFees(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalFees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalFees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalFees: %w", err)
	}
	return oldValue.TotalFees, nil
}

// AddTotalFees adds f to the "total_fees" field.
func (m *AccountWalletMutation) AddTotalFees(f float64) {
	if m.addtotal_fees != nil {
		*m.addtotal_fees += f
	} else {
		m.addtotal_fees = &f
	}
}

// AddedTotalFees returns the value that was added to the "total_fees" field in this mutation.
func (m *AccountWalletMutation) AddedTotalFees() (r float64, exists bool) {
	v := m.addtotal_fees
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalFees resets all changes to the "total_fees" field.
func (m *AccountWalletMutation) ResetTotalFees() {
	m.total_fees = nil
	m.addtotal_fees = nil
}

// SetTotalTax sets the "total_tax" field.
func (m *AccountWalletMutation) SetTotalTax(f float64) {
	m.total_tax = &f
	m.addtotal_tax = nil
}

// TotalTax returns the value of the "total_tax" field in the mutation.
func (m *AccountWalletMutation) TotalTax() (r float64, exists bool) {
	v := m.total_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTax returns the old "total_tax" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalTax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTax: %w", err)
	}
	return oldValue.TotalTax, nil
}

// AddTotalTax adds f to the "total_tax" field.
func (m *AccountWalletMutation) AddTotalTax(f float64) {
	if m.addtotal_tax != nil {
		*m.addtotal_tax += f
	} else {
		m.addtotal_tax = &f
	}
}

// AddedTotalTax returns the value that was added to the "total_tax" field in this mutation.
func (m *AccountWalletMutation) AddedTotalTax() (r float64, exists bool) {
	v := m.addtotal_tax
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTax resets all changes to the "total_tax" field.
func (m *AccountWalletMutation) ResetTotalTax() {
	m.total_tax = nil
	m.addtotal_tax = nil
}

// SetTotalDiscount sets the "total_discount" field.
func (m *AccountWalletMutation) SetTotalDiscount(f float64) {
	m.total_discount = &f
	m.addtotal_discount = nil
}

// TotalDiscount returns the value of the "total_discount" field in the mutation.
func (m *AccountWalletMutation) TotalDiscount() (r float64, exists bool) {
	v := m.total_discount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDiscount returns the old "total_discount" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalDiscount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDiscount: %w", err)
	}
	return oldValue.TotalDiscount, nil
}

// AddTotalDiscount adds f to the "total_discount" field.
func (m *AccountWalletMutation) AddTotalDiscount(f float64) {
	if m.addtotal_discount != nil {
		*m.addtotal_discount += f
	} else {
		m.addtotal_discount = &f
	}
}

// AddedTotalDiscount returns the value that was added to the "total_discount" field in this mutation.
func (m *AccountWalletMutation) AddedTotalDiscount() (r float64, exists bool) {
	v := m.addtotal_discount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalDiscount resets all changes to the "total_discount" field.
func (m *AccountWalletMutation) ResetTotalDiscount() {
	m.total_discount = nil
	m.addtotal_discount = nil
}

// SetTotalRevenue sets the "total_revenue" field.
func (m *AccountWalletMutation) SetTotalRevenue(f float64) {
	m.total_revenue = &f
	m.addtotal_revenue = nil
}

// TotalRevenue returns the value of the "total_revenue" field in the mutation.
func (m *AccountWalletMutation) TotalRevenue() (r float64, exists bool) {
	v := m.total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRevenue returns the old "total_revenue" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRevenue: %w", err)
	}
	return oldValue.TotalRevenue, nil
}

// AddTotalRevenue adds f to the "total_revenue" field.
func (m *AccountWalletMutation) AddTotalRevenue(f float64) {
	if m.addtotal_revenue != nil {
		*m.addtotal_revenue += f
	} else {
		m.addtotal_revenue = &f
	}
}

// AddedTotalRevenue returns the value that was added to the "total_revenue" field in this mutation.
func (m *AccountWalletMutation) AddedTotalRevenue() (r float64, exists bool) {
	v := m.addtotal_revenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRevenue resets all changes to the "total_revenue" field.
func (m *AccountWalletMutation) ResetTotalRevenue() {
	m.total_revenue = nil
	m.addtotal_revenue = nil
}

// SetTotalExpenses sets the "total_expenses" field.
func (m *AccountWalletMutation) SetTotalExpenses(f float64) {
	m.total_expenses = &f
	m.addtotal_expenses = nil
}

// TotalExpenses returns the value of the "total_expenses" field in the mutation.
func (m *AccountWalletMutation) TotalExpenses() (r float64, exists bool) {
	v := m.total_expenses
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalExpenses returns the old "total_expenses" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalExpenses(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalExpenses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalExpenses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalExpenses: %w", err)
	}
	return oldValue.TotalExpenses, nil
}

// AddTotalExpenses adds f to the "total_expenses" field.
func (m *AccountWalletMutation) AddTotalExpenses(f float64) {
	if m.addtotal_expenses != nil {
		*m.addtotal_expenses += f
	} else {
		m.addtotal_expenses = &f
	}
}

// AddedTotalExpenses returns the value that was added to the "total_expenses" field in this mutation.
func (m *AccountWalletMutation) AddedTotalExpenses() (r float64, exists bool) {
	v := m.addtotal_expenses
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalExpenses resets all changes to the "total_expenses" field.
func (m *AccountWalletMutation) ResetTotalExpenses() {
	m.total_expenses = nil
	m.addtotal_expenses = nil
}

// SetTotalProfit sets the "total_profit" field.
func (m *AccountWalletMutation) SetTotalProfit(f float64) {
	m.total_profit = &f
	m.addtotal_profit = nil
}

// TotalProfit returns the value of the "total_profit" field in the mutation.
func (m *AccountWalletMutation) TotalProfit() (r float64, exists bool) {
	v := m.total_profit
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalProfit returns the old "total_profit" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalProfit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalProfit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalProfit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalProfit: %w", err)
	}
	return oldValue.TotalProfit, nil
}

// AddTotalProfit adds f to the "total_profit" field.
func (m *AccountWalletMutation) AddTotalProfit(f float64) {
	if m.addtotal_profit != nil {
		*m.addtotal_profit += f
	} else {
		m.addtotal_profit = &f
	}
}

// AddedTotalProfit returns the value that was added to the "total_profit" field in this mutation.
func (m *AccountWalletMutation) AddedTotalProfit() (r float64, exists bool) {
	v := m.addtotal_profit
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalProfit resets all changes to the "total_profit" field.
func (m *AccountWalletMutation) ResetTotalProfit() {
	m.total_profit = nil
	m.addtotal_profit = nil
}

// SetTotalLoss sets the "total_loss" field.
func (m *AccountWalletMutation) SetTotalLoss(f float64) {
	m.total_loss = &f
	m.addtotal_loss = nil
}

// TotalLoss returns the value of the "total_loss" field in the mutation.
func (m *AccountWalletMutation) TotalLoss() (r float64, exists bool) {
	v := m.total_loss
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalLoss returns the old "total_loss" field's value of the AccountWallet entity.
// If the AccountWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountWalletMutation) OldTotalLoss(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalLoss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalLoss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalLoss: %w", err)
	}
	return oldValue.TotalLoss, nil
}

// AddTotalLoss adds f to the "total_loss" field.
func (m *AccountWalletMutation) AddTotalLoss(f float64) {
	if m.addtotal_loss != nil {
		*m.addtotal_loss += f
	} else {
		m.addtotal_loss = &f
	}
}

// AddedTotalLoss returns the value that was added to the "total_loss" field in this mutation.
func (m *AccountWalletMutation) AddedTotalLoss() (r float64, exists bool) {
	v := m.addtotal_loss
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalLoss resets all changes to the "total_loss" field.
func (m *AccountWalletMutation) ResetTotalLoss() {
	m.total_loss = nil
	m.addtotal_loss = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AccountWalletMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccountWalletMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccountWalletMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AccountWalletMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccountWalletMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccountWalletMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *AccountWalletMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *AccountWalletMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *AccountWalletMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *AccountWalletMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *AccountWalletMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *AccountWalletMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the AccountWalletMutation builder.
func (m *AccountWalletMutation) Where(ps ...predicate.AccountWallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountWalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountWalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountWallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountWalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountWalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountWallet).
func (m *AccountWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountWalletMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.balance != nil {
		fields = append(fields, accountwallet.FieldBalance)
	}
	if m.total_deposited != nil {
		fields = append(fields, accountwallet.FieldTotalDeposited)
	}
	if m.total_withdrawn != nil {
		fields = append(fields, accountwallet.FieldTotalWithdrawn)
	}
	if m.total_earned != nil {
		fields = append(fields, accountwallet.FieldTotalEarned)
	}
	if m.total_spent != nil {
		fields = append(fields, accountwallet.FieldTotalSpent)
	}
	if m.total_refunded != nil {
		fields = append(fields, accountwallet.FieldTotalRefunded)
	}
	if m.total_fees != nil {
		fields = append(fields, accountwallet.FieldTotalFees)
	}
	if m.total_tax != nil {
		fields = append(fields, accountwallet.FieldTotalTax)
	}
	if m.total_discount != nil {
		fields = append(fields, accountwallet.FieldTotalDiscount)
	}
	if m.total_revenue != nil {
		fields = append(fields, accountwallet.FieldTotalRevenue)
	}
	if m.total_expenses != nil {
		fields = append(fields, accountwallet.FieldTotalExpenses)
	}
	if m.total_profit != nil {
		fields = append(fields, accountwallet.FieldTotalProfit)
	}
	if m.total_loss != nil {
		fields = append(fields, accountwallet.FieldTotalLoss)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountwallet.FieldBalance:
		return m.Balance()
	case accountwallet.FieldTotalDeposited:
		return m.TotalDeposited()
	case accountwallet.FieldTotalWithdrawn:
		return m.TotalWithdrawn()
	case accountwallet.FieldTotalEarned:
		return m.TotalEarned()
	case accountwallet.FieldTotalSpent:
		return m.TotalSpent()
	case accountwallet.FieldTotalRefunded:
		return m.TotalRefunded()
	case accountwallet.FieldTotalFees:
		return m.TotalFees()
	case accountwallet.FieldTotalTax:
		return m.TotalTax()
	case accountwallet.FieldTotalDiscount:
		return m.TotalDiscount()
	case accountwallet.FieldTotalRevenue:
		return m.TotalRevenue()
	case accountwallet.FieldTotalExpenses:
		return m.TotalExpenses()
	case accountwallet.FieldTotalProfit:
		return m.TotalProfit()
	case accountwallet.FieldTotalLoss:
		return m.TotalLoss()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountwallet.FieldBalance:
		return m.OldBalance(ctx)
	case accountwallet.FieldTotalDeposited:
		return m.OldTotalDeposited(ctx)
	case accountwallet.FieldTotalWithdrawn:
		return m.OldTotalWithdrawn(ctx)
	case accountwallet.FieldTotalEarned:
		return m.OldTotalEarned(ctx)
	case accountwallet.FieldTotalSpent:
		return m.OldTotalSpent(ctx)
	case accountwallet.FieldTotalRefunded:
		return m.OldTotalRefunded(ctx)
	case accountwallet.FieldTotalFees:
		return m.OldTotalFees(ctx)
	case accountwallet.FieldTotalTax:
		return m.OldTotalTax(ctx)
	case accountwallet.FieldTotalDiscount:
		return m.OldTotalDiscount(ctx)
	case accountwallet.FieldTotalRevenue:
		return m.OldTotalRevenue(ctx)
	case accountwallet.FieldTotalExpenses:
		return m.OldTotalExpenses(ctx)
	case accountwallet.FieldTotalProfit:
		return m.OldTotalProfit(ctx)
	case accountwallet.FieldTotalLoss:
		return m.OldTotalLoss(ctx)
	}
	return nil, fmt.Errorf("unknown AccountWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountwallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case accountwallet.FieldTotalDeposited:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDeposited(v)
		return nil
	case accountwallet.FieldTotalWithdrawn:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalWithdrawn(v)
		return nil
	case accountwallet.FieldTotalEarned:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalEarned(v)
		return nil
	case accountwallet.FieldTotalSpent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSpent(v)
		return nil
	case accountwallet.FieldTotalRefunded:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRefunded(v)
		return nil
	case accountwallet.FieldTotalFees:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalFees(v)
		return nil
	case accountwallet.FieldTotalTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTax(v)
		return nil
	case accountwallet.FieldTotalDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDiscount(v)
		return nil
	case accountwallet.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRevenue(v)
		return nil
	case accountwallet.FieldTotalExpenses:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalExpenses(v)
		return nil
	case accountwallet.FieldTotalProfit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalProfit(v)
		return nil
	case accountwallet.FieldTotalLoss:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalLoss(v)
		return nil
	}
	return fmt.Errorf("unknown AccountWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountWalletMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, accountwallet.FieldBalance)
	}
	if m.addtotal_deposited != nil {
		fields = append(fields, accountwallet.FieldTotalDeposited)
	}
	if m.addtotal_withdrawn != nil {
		fields = append(fields, accountwallet.FieldTotalWithdrawn)
	}
	if m.addtotal_earned != nil {
		fields = append(fields, accountwallet.FieldTotalEarned)
	}
	if m.addtotal_spent != nil {
		fields = append(fields, accountwallet.FieldTotalSpent)
	}
	if m.addtotal_refunded != nil {
		fields = append(fields, accountwallet.FieldTotalRefunded)
	}
	if m.addtotal_fees != nil {
		fields = append(fields, accountwallet.FieldTotalFees)
	}
	if m.addtotal_tax != nil {
		fields = append(fields, accountwallet.FieldTotalTax)
	}
	if m.addtotal_discount != nil {
		fields = append(fields, accountwallet.FieldTotalDiscount)
	}
	if m.addtotal_revenue != nil {
		fields = append(fields, accountwallet.FieldTotalRevenue)
	}
	if m.addtotal_expenses != nil {
		fields = append(fields, accountwallet.FieldTotalExpenses)
	}
	if m.addtotal_profit != nil {
		fields = append(fields, accountwallet.FieldTotalProfit)
	}
	if m.addtotal_loss != nil {
		fields = append(fields, accountwallet.FieldTotalLoss)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountWalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountwallet.FieldBalance:
		return m.AddedBalance()
	case accountwallet.FieldTotalDeposited:
		return m.AddedTotalDeposited()
	case accountwallet.FieldTotalWithdrawn:
		return m.AddedTotalWithdrawn()
	case accountwallet.FieldTotalEarned:
		return m.AddedTotalEarned()
	case accountwallet.FieldTotalSpent:
		return m.AddedTotalSpent()
	case accountwallet.FieldTotalRefunded:
		return m.AddedTotalRefunded()
	case accountwallet.FieldTotalFees:
		return m.AddedTotalFees()
	case accountwallet.FieldTotalTax:
		return m.AddedTotalTax()
	case accountwallet.FieldTotalDiscount:
		return m.AddedTotalDiscount()
	case accountwallet.FieldTotalRevenue:
		return m.AddedTotalRevenue()
	case accountwallet.FieldTotalExpenses:
		return m.AddedTotalExpenses()
	case accountwallet.FieldTotalProfit:
		return m.AddedTotalProfit()
	case accountwallet.FieldTotalLoss:
		return m.AddedTotalLoss()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountwallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case accountwallet.FieldTotalDeposited:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDeposited(v)
		return nil
	case accountwallet.FieldTotalWithdrawn:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalWithdrawn(v)
		return nil
	case accountwallet.FieldTotalEarned:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalEarned(v)
		return nil
	case accountwallet.FieldTotalSpent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSpent(v)
		return nil
	case accountwallet.FieldTotalRefunded:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRefunded(v)
		return nil
	case accountwallet.FieldTotalFees:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalFees(v)
		return nil
	case accountwallet.FieldTotalTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTax(v)
		return nil
	case accountwallet.FieldTotalDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDiscount(v)
		return nil
	case accountwallet.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRevenue(v)
		return nil
	case accountwallet.FieldTotalExpenses:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalExpenses(v)
		return nil
	case accountwallet.FieldTotalProfit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalProfit(v)
		return nil
	case accountwallet.FieldTotalLoss:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalLoss(v)
		return nil
	}
	return fmt.Errorf("unknown AccountWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountWalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountWalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountWalletMutation) ResetField(name string) error {
	switch name {
	case accountwallet.FieldBalance:
		m.ResetBalance()
		return nil
	case accountwallet.FieldTotalDeposited:
		m.ResetTotalDeposited()
		return nil
	case accountwallet.FieldTotalWithdrawn:
		m.ResetTotalWithdrawn()
		return nil
	case accountwallet.FieldTotalEarned:
		m.ResetTotalEarned()
		return nil
	case accountwallet.FieldTotalSpent:
		m.ResetTotalSpent()
		return nil
	case accountwallet.FieldTotalRefunded:
		m.ResetTotalRefunded()
		return nil
	case accountwallet.FieldTotalFees:
		m.ResetTotalFees()
		return nil
	case accountwallet.FieldTotalTax:
		m.ResetTotalTax()
		return nil
	case accountwallet.FieldTotalDiscount:
		m.ResetTotalDiscount()
		return nil
	case accountwallet.FieldTotalRevenue:
		m.ResetTotalRevenue()
		return nil
	case accountwallet.FieldTotalExpenses:
		m.ResetTotalExpenses()
		return nil
	case accountwallet.FieldTotalProfit:
		m.ResetTotalProfit()
		return nil
	case accountwallet.FieldTotalLoss:
		m.ResetTotalLoss()
		return nil
	}
	return fmt.Errorf("unknown AccountWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, accountwallet.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, accountwallet.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountWalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountwallet.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case accountwallet.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, accountwallet.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, accountwallet.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountWalletMutation) EdgeCleared(name string) bool {
	switch name {
	case accountwallet.EdgeUser:
		return m.cleareduser
	case accountwallet.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountWalletMutation) ClearEdge(name string) error {
	switch name {
	case accountwallet.EdgeUser:
		m.ClearUser()
		return nil
	case accountwallet.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown AccountWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountWalletMutation) ResetEdge(name string) error {
	switch name {
	case accountwallet.EdgeUser:
		m.ResetUser()
		return nil
	case accountwallet.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown AccountWallet edge %s", name)
}

// AmenityMutation represents an operation that mutates the Amenity nodes in the graph.
type AmenityMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	name                   *string
	icon                   *string
	clearedFields          map[string]struct{}
	places                 map[string]struct{}
	removedplaces          map[string]struct{}
	clearedplaces          bool
	rooms                  map[string]struct{}
	removedrooms           map[string]struct{}
	clearedrooms           bool
	room_categories        map[string]struct{}
	removedroom_categories map[string]struct{}
	clearedroom_categories bool
	done                   bool
	oldValue               func(context.Context) (*Amenity, error)
	predicates             []predicate.Amenity
}

var _ ent.Mutation = (*AmenityMutation)(nil)

// amenityOption allows management of the mutation configuration using functional options.
type amenityOption func(*AmenityMutation)

// newAmenityMutation creates new mutation for the Amenity entity.
func newAmenityMutation(c config, op Op, opts ...amenityOption) *AmenityMutation {
	m := &AmenityMutation{
		config:        c,
		op:            op,
		typ:           TypeAmenity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmenityID sets the ID field of the mutation.
func withAmenityID(id string) amenityOption {
	return func(m *AmenityMutation) {
		var (
			err   error
			once  sync.Once
			value *Amenity
		)
		m.oldValue = func(ctx context.Context) (*Amenity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Amenity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmenity sets the old Amenity of the mutation.
func withAmenity(node *Amenity) amenityOption {
	return func(m *AmenityMutation) {
		m.oldValue = func(context.Context) (*Amenity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmenityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmenityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Amenity entities.
func (m *AmenityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AmenityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AmenityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Amenity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AmenityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AmenityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Amenity entity.
// If the Amenity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmenityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AmenityMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *AmenityMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AmenityMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Amenity entity.
// If the Amenity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmenityMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *AmenityMutation) ResetIcon() {
	m.icon = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *AmenityMutation) AddPlaceIDs(ids ...string) {
	if m.places == nil {
		m.places = make(map[string]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *AmenityMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *AmenityMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *AmenityMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *AmenityMutation) RemovedPlacesIDs() (ids []string) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *AmenityMutation) PlacesIDs() (ids []string) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *AmenityMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddRoomIDs adds the "rooms" edge to the Room entity by ids.
func (m *AmenityMutation) AddRoomIDs(ids ...string) {
	if m.rooms == nil {
		m.rooms = make(map[string]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// ClearRooms clears the "rooms" edge to the Room entity.
func (m *AmenityMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared reports if the "rooms" edge to the Room entity was cleared.
func (m *AmenityMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RemoveRoomIDs removes the "rooms" edge to the Room entity by IDs.
func (m *AmenityMutation) RemoveRoomIDs(ids ...string) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rooms, ids[i])
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed IDs of the "rooms" edge to the Room entity.
func (m *AmenityMutation) RemovedRoomsIDs() (ids []string) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the "rooms" edge IDs in the mutation.
func (m *AmenityMutation) RoomsIDs() (ids []string) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms resets all changes to the "rooms" edge.
func (m *AmenityMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
	m.removedrooms = nil
}

// AddRoomCategoryIDs adds the "room_categories" edge to the RoomCategory entity by ids.
func (m *AmenityMutation) AddRoomCategoryIDs(ids ...string) {
	if m.room_categories == nil {
		m.room_categories = make(map[string]struct{})
	}
	for i := range ids {
		m.room_categories[ids[i]] = struct{}{}
	}
}

// ClearRoomCategories clears the "room_categories" edge to the RoomCategory entity.
func (m *AmenityMutation) ClearRoomCategories() {
	m.clearedroom_categories = true
}

// RoomCategoriesCleared reports if the "room_categories" edge to the RoomCategory entity was cleared.
func (m *AmenityMutation) RoomCategoriesCleared() bool {
	return m.clearedroom_categories
}

// RemoveRoomCategoryIDs removes the "room_categories" edge to the RoomCategory entity by IDs.
func (m *AmenityMutation) RemoveRoomCategoryIDs(ids ...string) {
	if m.removedroom_categories == nil {
		m.removedroom_categories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.room_categories, ids[i])
		m.removedroom_categories[ids[i]] = struct{}{}
	}
}

// RemovedRoomCategories returns the removed IDs of the "room_categories" edge to the RoomCategory entity.
func (m *AmenityMutation) RemovedRoomCategoriesIDs() (ids []string) {
	for id := range m.removedroom_categories {
		ids = append(ids, id)
	}
	return
}

// RoomCategoriesIDs returns the "room_categories" edge IDs in the mutation.
func (m *AmenityMutation) RoomCategoriesIDs() (ids []string) {
	for id := range m.room_categories {
		ids = append(ids, id)
	}
	return
}

// ResetRoomCategories resets all changes to the "room_categories" edge.
func (m *AmenityMutation) ResetRoomCategories() {
	m.room_categories = nil
	m.clearedroom_categories = false
	m.removedroom_categories = nil
}

// Where appends a list predicates to the AmenityMutation builder.
func (m *AmenityMutation) Where(ps ...predicate.Amenity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AmenityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AmenityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Amenity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AmenityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AmenityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Amenity).
func (m *AmenityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AmenityMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, amenity.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, amenity.FieldIcon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AmenityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case amenity.FieldName:
		return m.Name()
	case amenity.FieldIcon:
		return m.Icon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AmenityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case amenity.FieldName:
		return m.OldName(ctx)
	case amenity.FieldIcon:
		return m.OldIcon(ctx)
	}
	return nil, fmt.Errorf("unknown Amenity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmenityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case amenity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case amenity.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	}
	return fmt.Errorf("unknown Amenity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AmenityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AmenityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmenityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Amenity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AmenityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AmenityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmenityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Amenity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AmenityMutation) ResetField(name string) error {
	switch name {
	case amenity.FieldName:
		m.ResetName()
		return nil
	case amenity.FieldIcon:
		m.ResetIcon()
		return nil
	}
	return fmt.Errorf("unknown Amenity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AmenityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.places != nil {
		edges = append(edges, amenity.EdgePlaces)
	}
	if m.rooms != nil {
		edges = append(edges, amenity.EdgeRooms)
	}
	if m.room_categories != nil {
		edges = append(edges, amenity.EdgeRoomCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AmenityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case amenity.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case amenity.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	case amenity.EdgeRoomCategories:
		ids := make([]ent.Value, 0, len(m.room_categories))
		for id := range m.room_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AmenityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplaces != nil {
		edges = append(edges, amenity.EdgePlaces)
	}
	if m.removedrooms != nil {
		edges = append(edges, amenity.EdgeRooms)
	}
	if m.removedroom_categories != nil {
		edges = append(edges, amenity.EdgeRoomCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AmenityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case amenity.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case amenity.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	case amenity.EdgeRoomCategories:
		ids := make([]ent.Value, 0, len(m.removedroom_categories))
		for id := range m.removedroom_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AmenityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplaces {
		edges = append(edges, amenity.EdgePlaces)
	}
	if m.clearedrooms {
		edges = append(edges, amenity.EdgeRooms)
	}
	if m.clearedroom_categories {
		edges = append(edges, amenity.EdgeRoomCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AmenityMutation) EdgeCleared(name string) bool {
	switch name {
	case amenity.EdgePlaces:
		return m.clearedplaces
	case amenity.EdgeRooms:
		return m.clearedrooms
	case amenity.EdgeRoomCategories:
		return m.clearedroom_categories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AmenityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Amenity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AmenityMutation) ResetEdge(name string) error {
	switch name {
	case amenity.EdgePlaces:
		m.ResetPlaces()
		return nil
	case amenity.EdgeRooms:
		m.ResetRooms()
		return nil
	case amenity.EdgeRoomCategories:
		m.ResetRoomCategories()
		return nil
	}
	return fmt.Errorf("unknown Amenity edge %s", name)
}

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	startDate     *time.Time
	endDate       *time.Time
	status        *string
	bookingDate   *time.Time
	clearedFields map[string]struct{}
	room          *string
	clearedroom   bool
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Booking, error)
	predicates    []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id string) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Booking entities.
func (m *BookingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Booking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartDate sets the "startDate" field.
func (m *BookingMutation) SetStartDate(t time.Time) {
	m.startDate = &t
}

// StartDate returns the value of the "startDate" field in the mutation.
func (m *BookingMutation) StartDate() (r time.Time, exists bool) {
	v := m.startDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "startDate" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "startDate" field.
func (m *BookingMutation) ResetStartDate() {
	m.startDate = nil
}

// SetEndDate sets the "endDate" field.
func (m *BookingMutation) SetEndDate(t time.Time) {
	m.endDate = &t
}

// EndDate returns the value of the "endDate" field in the mutation.
func (m *BookingMutation) EndDate() (r time.Time, exists bool) {
	v := m.endDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "endDate" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "endDate" field.
func (m *BookingMutation) ResetEndDate() {
	m.endDate = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// SetBookingDate sets the "bookingDate" field.
func (m *BookingMutation) SetBookingDate(t time.Time) {
	m.bookingDate = &t
}

// BookingDate returns the value of the "bookingDate" field in the mutation.
func (m *BookingMutation) BookingDate() (r time.Time, exists bool) {
	v := m.bookingDate
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingDate returns the old "bookingDate" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldBookingDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingDate: %w", err)
	}
	return oldValue.BookingDate, nil
}

// ResetBookingDate resets all changes to the "bookingDate" field.
func (m *BookingMutation) ResetBookingDate() {
	m.bookingDate = nil
}

// SetRoomID sets the "room" edge to the Room entity by id.
func (m *BookingMutation) SetRoomID(id string) {
	m.room = &id
}

// ClearRoom clears the "room" edge to the Room entity.
func (m *BookingMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared reports if the "room" edge to the Room entity was cleared.
func (m *BookingMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the "room" edge ID in the mutation.
func (m *BookingMutation) RoomID() (id string, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the "room" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) RoomIDs() (ids []string) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom resets all changes to the "room" edge.
func (m *BookingMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BookingMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BookingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BookingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BookingMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BookingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Booking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.startDate != nil {
		fields = append(fields, booking.FieldStartDate)
	}
	if m.endDate != nil {
		fields = append(fields, booking.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	if m.bookingDate != nil {
		fields = append(fields, booking.FieldBookingDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldStartDate:
		return m.StartDate()
	case booking.FieldEndDate:
		return m.EndDate()
	case booking.FieldStatus:
		return m.Status()
	case booking.FieldBookingDate:
		return m.BookingDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldStartDate:
		return m.OldStartDate(ctx)
	case booking.FieldEndDate:
		return m.OldEndDate(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	case booking.FieldBookingDate:
		return m.OldBookingDate(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case booking.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case booking.FieldBookingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingDate(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldStartDate:
		m.ResetStartDate()
		return nil
	case booking.FieldEndDate:
		m.ResetEndDate()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	case booking.FieldBookingDate:
		m.ResetBookingDate()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.room != nil {
		edges = append(edges, booking.EdgeRoom)
	}
	if m.user != nil {
		edges = append(edges, booking.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroom {
		edges = append(edges, booking.EdgeRoom)
	}
	if m.cleareduser {
		edges = append(edges, booking.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeRoom:
		return m.clearedroom
	case booking.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeRoom:
		m.ClearRoom()
		return nil
	case booking.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeRoom:
		m.ResetRoom()
		return nil
	case booking.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// BusinessMutation represents an operation that mutates the Business nodes in the graph.
type BusinessMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	name                             *string
	description                      *string
	picture                          *string
	cover_image                      *string
	website                          *string
	location                         *string
	longitude                        *string
	map_coordinates                  *map[string]interface{}
	latitude                         *string
	email                            *string
	phone                            *string
	business_settings                *map[string]interface{}
	url                              *string
	search_text                      *string
	relevance_score                  *float64
	addrelevance_score               *float64
	follower_count                   *int
	addfollower_count                *int
	following_count                  *int
	addfollowing_count               *int
	clearedFields                    map[string]struct{}
	userBusinesses                   map[string]struct{}
	removeduserBusinesses            map[string]struct{}
	cleareduserBusinesses            bool
	business_account_settings        *string
	clearedbusiness_account_settings bool
	posts                            map[string]struct{}
	removedposts                     map[string]struct{}
	clearedposts                     bool
	followedUsers                    map[string]struct{}
	removedfollowedUsers             map[string]struct{}
	clearedfollowedUsers             bool
	followerUsers                    map[string]struct{}
	removedfollowerUsers             map[string]struct{}
	clearedfollowerUsers             bool
	followedBusinesses               map[string]struct{}
	removedfollowedBusinesses        map[string]struct{}
	clearedfollowedBusinesses        bool
	followerBusinesses               map[string]struct{}
	removedfollowerBusinesses        map[string]struct{}
	clearedfollowerBusinesses        bool
	places                           map[string]struct{}
	removedplaces                    map[string]struct{}
	clearedplaces                    bool
	categories                       map[string]struct{}
	removedcategories                map[string]struct{}
	clearedcategories                bool
	categoryAssignments              map[string]struct{}
	removedcategoryAssignments       map[string]struct{}
	clearedcategoryAssignments       bool
	events                           map[string]struct{}
	removedevents                    map[string]struct{}
	clearedevents                    bool
	businessFollowEvents             map[string]struct{}
	removedbusinessFollowEvents      map[string]struct{}
	clearedbusinessFollowEvents      bool
	faqs                             map[string]struct{}
	removedfaqs                      map[string]struct{}
	clearedfaqs                      bool
	ratings                          map[string]struct{}
	removedratings                   map[string]struct{}
	clearedratings                   bool
	place_inventories                map[string]struct{}
	removedplace_inventories         map[string]struct{}
	clearedplace_inventories         bool
	websites                         *string
	clearedwebsites                  bool
	notifications                    map[string]struct{}
	removednotifications             map[string]struct{}
	clearednotifications             bool
	wallet                           *string
	clearedwallet                    bool
	staffs                           map[string]struct{}
	removedstaffs                    map[string]struct{}
	clearedstaffs                    bool
	plans                            map[string]struct{}
	removedplans                     map[string]struct{}
	clearedplans                     bool
	done                             bool
	oldValue                         func(context.Context) (*Business, error)
	predicates                       []predicate.Business
}

var _ ent.Mutation = (*BusinessMutation)(nil)

// businessOption allows management of the mutation configuration using functional options.
type businessOption func(*BusinessMutation)

// newBusinessMutation creates new mutation for the Business entity.
func newBusinessMutation(c config, op Op, opts ...businessOption) *BusinessMutation {
	m := &BusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessID sets the ID field of the mutation.
func withBusinessID(id string) businessOption {
	return func(m *BusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *Business
		)
		m.oldValue = func(ctx context.Context) (*Business, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Business.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusiness sets the old Business of the mutation.
func withBusiness(node *Business) businessOption {
	return func(m *BusinessMutation) {
		m.oldValue = func(context.Context) (*Business, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Business entities.
func (m *BusinessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Business.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BusinessMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BusinessMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BusinessMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BusinessMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BusinessMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BusinessMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[business.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BusinessMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[business.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BusinessMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, business.FieldDescription)
}

// SetPicture sets the "picture" field.
func (m *BusinessMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *BusinessMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *BusinessMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[business.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *BusinessMutation) PictureCleared() bool {
	_, ok := m.clearedFields[business.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *BusinessMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, business.FieldPicture)
}

// SetCoverImage sets the "cover_image" field.
func (m *BusinessMutation) SetCoverImage(s string) {
	m.cover_image = &s
}

// CoverImage returns the value of the "cover_image" field in the mutation.
func (m *BusinessMutation) CoverImage() (r string, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "cover_image" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ClearCoverImage clears the value of the "cover_image" field.
func (m *BusinessMutation) ClearCoverImage() {
	m.cover_image = nil
	m.clearedFields[business.FieldCoverImage] = struct{}{}
}

// CoverImageCleared returns if the "cover_image" field was cleared in this mutation.
func (m *BusinessMutation) CoverImageCleared() bool {
	_, ok := m.clearedFields[business.FieldCoverImage]
	return ok
}

// ResetCoverImage resets all changes to the "cover_image" field.
func (m *BusinessMutation) ResetCoverImage() {
	m.cover_image = nil
	delete(m.clearedFields, business.FieldCoverImage)
}

// SetWebsite sets the "website" field.
func (m *BusinessMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *BusinessMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *BusinessMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[business.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *BusinessMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[business.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *BusinessMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, business.FieldWebsite)
}

// SetLocation sets the "location" field.
func (m *BusinessMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *BusinessMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *BusinessMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[business.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *BusinessMutation) LocationCleared() bool {
	_, ok := m.clearedFields[business.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *BusinessMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, business.FieldLocation)
}

// SetLongitude sets the "longitude" field.
func (m *BusinessMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *BusinessMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *BusinessMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[business.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *BusinessMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[business.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *BusinessMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, business.FieldLongitude)
}

// SetMapCoordinates sets the "map_coordinates" field.
func (m *BusinessMutation) SetMapCoordinates(value map[string]interface{}) {
	m.map_coordinates = &value
}

// MapCoordinates returns the value of the "map_coordinates" field in the mutation.
func (m *BusinessMutation) MapCoordinates() (r map[string]interface{}, exists bool) {
	v := m.map_coordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldMapCoordinates returns the old "map_coordinates" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldMapCoordinates(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapCoordinates: %w", err)
	}
	return oldValue.MapCoordinates, nil
}

// ClearMapCoordinates clears the value of the "map_coordinates" field.
func (m *BusinessMutation) ClearMapCoordinates() {
	m.map_coordinates = nil
	m.clearedFields[business.FieldMapCoordinates] = struct{}{}
}

// MapCoordinatesCleared returns if the "map_coordinates" field was cleared in this mutation.
func (m *BusinessMutation) MapCoordinatesCleared() bool {
	_, ok := m.clearedFields[business.FieldMapCoordinates]
	return ok
}

// ResetMapCoordinates resets all changes to the "map_coordinates" field.
func (m *BusinessMutation) ResetMapCoordinates() {
	m.map_coordinates = nil
	delete(m.clearedFields, business.FieldMapCoordinates)
}

// SetLatitude sets the "latitude" field.
func (m *BusinessMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *BusinessMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *BusinessMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[business.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *BusinessMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[business.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *BusinessMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, business.FieldLatitude)
}

// SetEmail sets the "email" field.
func (m *BusinessMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *BusinessMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *BusinessMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[business.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *BusinessMutation) EmailCleared() bool {
	_, ok := m.clearedFields[business.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *BusinessMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, business.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *BusinessMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *BusinessMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *BusinessMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[business.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *BusinessMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[business.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *BusinessMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, business.FieldPhone)
}

// SetBusinessSettings sets the "business_settings" field.
func (m *BusinessMutation) SetBusinessSettings(value map[string]interface{}) {
	m.business_settings = &value
}

// BusinessSettings returns the value of the "business_settings" field in the mutation.
func (m *BusinessMutation) BusinessSettings() (r map[string]interface{}, exists bool) {
	v := m.business_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessSettings returns the old "business_settings" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldBusinessSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessSettings: %w", err)
	}
	return oldValue.BusinessSettings, nil
}

// ClearBusinessSettings clears the value of the "business_settings" field.
func (m *BusinessMutation) ClearBusinessSettings() {
	m.business_settings = nil
	m.clearedFields[business.FieldBusinessSettings] = struct{}{}
}

// BusinessSettingsCleared returns if the "business_settings" field was cleared in this mutation.
func (m *BusinessMutation) BusinessSettingsCleared() bool {
	_, ok := m.clearedFields[business.FieldBusinessSettings]
	return ok
}

// ResetBusinessSettings resets all changes to the "business_settings" field.
func (m *BusinessMutation) ResetBusinessSettings() {
	m.business_settings = nil
	delete(m.clearedFields, business.FieldBusinessSettings)
}

// SetURL sets the "url" field.
func (m *BusinessMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *BusinessMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *BusinessMutation) ClearURL() {
	m.url = nil
	m.clearedFields[business.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *BusinessMutation) URLCleared() bool {
	_, ok := m.clearedFields[business.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *BusinessMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, business.FieldURL)
}

// SetSearchText sets the "search_text" field.
func (m *BusinessMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *BusinessMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *BusinessMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[business.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *BusinessMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[business.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *BusinessMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, business.FieldSearchText)
}

// SetRelevanceScore sets the "relevance_score" field.
func (m *BusinessMutation) SetRelevanceScore(f float64) {
	m.relevance_score = &f
	m.addrelevance_score = nil
}

// RelevanceScore returns the value of the "relevance_score" field in the mutation.
func (m *BusinessMutation) RelevanceScore() (r float64, exists bool) {
	v := m.relevance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "relevance_score" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldRelevanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds f to the "relevance_score" field.
func (m *BusinessMutation) AddRelevanceScore(f float64) {
	if m.addrelevance_score != nil {
		*m.addrelevance_score += f
	} else {
		m.addrelevance_score = &f
	}
}

// AddedRelevanceScore returns the value that was added to the "relevance_score" field in this mutation.
func (m *BusinessMutation) AddedRelevanceScore() (r float64, exists bool) {
	v := m.addrelevance_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelevanceScore clears the value of the "relevance_score" field.
func (m *BusinessMutation) ClearRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	m.clearedFields[business.FieldRelevanceScore] = struct{}{}
}

// RelevanceScoreCleared returns if the "relevance_score" field was cleared in this mutation.
func (m *BusinessMutation) RelevanceScoreCleared() bool {
	_, ok := m.clearedFields[business.FieldRelevanceScore]
	return ok
}

// ResetRelevanceScore resets all changes to the "relevance_score" field.
func (m *BusinessMutation) ResetRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	delete(m.clearedFields, business.FieldRelevanceScore)
}

// SetFollowerCount sets the "follower_count" field.
func (m *BusinessMutation) SetFollowerCount(i int) {
	m.follower_count = &i
	m.addfollower_count = nil
}

// FollowerCount returns the value of the "follower_count" field in the mutation.
func (m *BusinessMutation) FollowerCount() (r int, exists bool) {
	v := m.follower_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerCount returns the old "follower_count" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFollowerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerCount: %w", err)
	}
	return oldValue.FollowerCount, nil
}

// AddFollowerCount adds i to the "follower_count" field.
func (m *BusinessMutation) AddFollowerCount(i int) {
	if m.addfollower_count != nil {
		*m.addfollower_count += i
	} else {
		m.addfollower_count = &i
	}
}

// AddedFollowerCount returns the value that was added to the "follower_count" field in this mutation.
func (m *BusinessMutation) AddedFollowerCount() (r int, exists bool) {
	v := m.addfollower_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowerCount resets all changes to the "follower_count" field.
func (m *BusinessMutation) ResetFollowerCount() {
	m.follower_count = nil
	m.addfollower_count = nil
}

// SetFollowingCount sets the "following_count" field.
func (m *BusinessMutation) SetFollowingCount(i int) {
	m.following_count = &i
	m.addfollowing_count = nil
}

// FollowingCount returns the value of the "following_count" field in the mutation.
func (m *BusinessMutation) FollowingCount() (r int, exists bool) {
	v := m.following_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingCount returns the old "following_count" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFollowingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingCount: %w", err)
	}
	return oldValue.FollowingCount, nil
}

// AddFollowingCount adds i to the "following_count" field.
func (m *BusinessMutation) AddFollowingCount(i int) {
	if m.addfollowing_count != nil {
		*m.addfollowing_count += i
	} else {
		m.addfollowing_count = &i
	}
}

// AddedFollowingCount returns the value that was added to the "following_count" field in this mutation.
func (m *BusinessMutation) AddedFollowingCount() (r int, exists bool) {
	v := m.addfollowing_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowingCount resets all changes to the "following_count" field.
func (m *BusinessMutation) ResetFollowingCount() {
	m.following_count = nil
	m.addfollowing_count = nil
}

// AddUserBusinessIDs adds the "userBusinesses" edge to the UserBusiness entity by ids.
func (m *BusinessMutation) AddUserBusinessIDs(ids ...string) {
	if m.userBusinesses == nil {
		m.userBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.userBusinesses[ids[i]] = struct{}{}
	}
}

// ClearUserBusinesses clears the "userBusinesses" edge to the UserBusiness entity.
func (m *BusinessMutation) ClearUserBusinesses() {
	m.cleareduserBusinesses = true
}

// UserBusinessesCleared reports if the "userBusinesses" edge to the UserBusiness entity was cleared.
func (m *BusinessMutation) UserBusinessesCleared() bool {
	return m.cleareduserBusinesses
}

// RemoveUserBusinessIDs removes the "userBusinesses" edge to the UserBusiness entity by IDs.
func (m *BusinessMutation) RemoveUserBusinessIDs(ids ...string) {
	if m.removeduserBusinesses == nil {
		m.removeduserBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.userBusinesses, ids[i])
		m.removeduserBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedUserBusinesses returns the removed IDs of the "userBusinesses" edge to the UserBusiness entity.
func (m *BusinessMutation) RemovedUserBusinessesIDs() (ids []string) {
	for id := range m.removeduserBusinesses {
		ids = append(ids, id)
	}
	return
}

// UserBusinessesIDs returns the "userBusinesses" edge IDs in the mutation.
func (m *BusinessMutation) UserBusinessesIDs() (ids []string) {
	for id := range m.userBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetUserBusinesses resets all changes to the "userBusinesses" edge.
func (m *BusinessMutation) ResetUserBusinesses() {
	m.userBusinesses = nil
	m.cleareduserBusinesses = false
	m.removeduserBusinesses = nil
}

// SetBusinessAccountSettingsID sets the "business_account_settings" edge to the AccountSettings entity by id.
func (m *BusinessMutation) SetBusinessAccountSettingsID(id string) {
	m.business_account_settings = &id
}

// ClearBusinessAccountSettings clears the "business_account_settings" edge to the AccountSettings entity.
func (m *BusinessMutation) ClearBusinessAccountSettings() {
	m.clearedbusiness_account_settings = true
}

// BusinessAccountSettingsCleared reports if the "business_account_settings" edge to the AccountSettings entity was cleared.
func (m *BusinessMutation) BusinessAccountSettingsCleared() bool {
	return m.clearedbusiness_account_settings
}

// BusinessAccountSettingsID returns the "business_account_settings" edge ID in the mutation.
func (m *BusinessMutation) BusinessAccountSettingsID() (id string, exists bool) {
	if m.business_account_settings != nil {
		return *m.business_account_settings, true
	}
	return
}

// BusinessAccountSettingsIDs returns the "business_account_settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessAccountSettingsID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) BusinessAccountSettingsIDs() (ids []string) {
	if id := m.business_account_settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessAccountSettings resets all changes to the "business_account_settings" edge.
func (m *BusinessMutation) ResetBusinessAccountSettings() {
	m.business_account_settings = nil
	m.clearedbusiness_account_settings = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *BusinessMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *BusinessMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *BusinessMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *BusinessMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *BusinessMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *BusinessMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *BusinessMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddFollowedUserIDs adds the "followedUsers" edge to the BusinessFollowUser entity by ids.
func (m *BusinessMutation) AddFollowedUserIDs(ids ...string) {
	if m.followedUsers == nil {
		m.followedUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followedUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowedUsers clears the "followedUsers" edge to the BusinessFollowUser entity.
func (m *BusinessMutation) ClearFollowedUsers() {
	m.clearedfollowedUsers = true
}

// FollowedUsersCleared reports if the "followedUsers" edge to the BusinessFollowUser entity was cleared.
func (m *BusinessMutation) FollowedUsersCleared() bool {
	return m.clearedfollowedUsers
}

// RemoveFollowedUserIDs removes the "followedUsers" edge to the BusinessFollowUser entity by IDs.
func (m *BusinessMutation) RemoveFollowedUserIDs(ids ...string) {
	if m.removedfollowedUsers == nil {
		m.removedfollowedUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedUsers, ids[i])
		m.removedfollowedUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowedUsers returns the removed IDs of the "followedUsers" edge to the BusinessFollowUser entity.
func (m *BusinessMutation) RemovedFollowedUsersIDs() (ids []string) {
	for id := range m.removedfollowedUsers {
		ids = append(ids, id)
	}
	return
}

// FollowedUsersIDs returns the "followedUsers" edge IDs in the mutation.
func (m *BusinessMutation) FollowedUsersIDs() (ids []string) {
	for id := range m.followedUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedUsers resets all changes to the "followedUsers" edge.
func (m *BusinessMutation) ResetFollowedUsers() {
	m.followedUsers = nil
	m.clearedfollowedUsers = false
	m.removedfollowedUsers = nil
}

// AddFollowerUserIDs adds the "followerUsers" edge to the UserFollowBusiness entity by ids.
func (m *BusinessMutation) AddFollowerUserIDs(ids ...string) {
	if m.followerUsers == nil {
		m.followerUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followerUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowerUsers clears the "followerUsers" edge to the UserFollowBusiness entity.
func (m *BusinessMutation) ClearFollowerUsers() {
	m.clearedfollowerUsers = true
}

// FollowerUsersCleared reports if the "followerUsers" edge to the UserFollowBusiness entity was cleared.
func (m *BusinessMutation) FollowerUsersCleared() bool {
	return m.clearedfollowerUsers
}

// RemoveFollowerUserIDs removes the "followerUsers" edge to the UserFollowBusiness entity by IDs.
func (m *BusinessMutation) RemoveFollowerUserIDs(ids ...string) {
	if m.removedfollowerUsers == nil {
		m.removedfollowerUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerUsers, ids[i])
		m.removedfollowerUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowerUsers returns the removed IDs of the "followerUsers" edge to the UserFollowBusiness entity.
func (m *BusinessMutation) RemovedFollowerUsersIDs() (ids []string) {
	for id := range m.removedfollowerUsers {
		ids = append(ids, id)
	}
	return
}

// FollowerUsersIDs returns the "followerUsers" edge IDs in the mutation.
func (m *BusinessMutation) FollowerUsersIDs() (ids []string) {
	for id := range m.followerUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerUsers resets all changes to the "followerUsers" edge.
func (m *BusinessMutation) ResetFollowerUsers() {
	m.followerUsers = nil
	m.clearedfollowerUsers = false
	m.removedfollowerUsers = nil
}

// AddFollowedBusinessIDs adds the "followedBusinesses" edge to the BusinessFollowBusiness entity by ids.
func (m *BusinessMutation) AddFollowedBusinessIDs(ids ...string) {
	if m.followedBusinesses == nil {
		m.followedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followedBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowedBusinesses clears the "followedBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) ClearFollowedBusinesses() {
	m.clearedfollowedBusinesses = true
}

// FollowedBusinessesCleared reports if the "followedBusinesses" edge to the BusinessFollowBusiness entity was cleared.
func (m *BusinessMutation) FollowedBusinessesCleared() bool {
	return m.clearedfollowedBusinesses
}

// RemoveFollowedBusinessIDs removes the "followedBusinesses" edge to the BusinessFollowBusiness entity by IDs.
func (m *BusinessMutation) RemoveFollowedBusinessIDs(ids ...string) {
	if m.removedfollowedBusinesses == nil {
		m.removedfollowedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedBusinesses, ids[i])
		m.removedfollowedBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBusinesses returns the removed IDs of the "followedBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) RemovedFollowedBusinessesIDs() (ids []string) {
	for id := range m.removedfollowedBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowedBusinessesIDs returns the "followedBusinesses" edge IDs in the mutation.
func (m *BusinessMutation) FollowedBusinessesIDs() (ids []string) {
	for id := range m.followedBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBusinesses resets all changes to the "followedBusinesses" edge.
func (m *BusinessMutation) ResetFollowedBusinesses() {
	m.followedBusinesses = nil
	m.clearedfollowedBusinesses = false
	m.removedfollowedBusinesses = nil
}

// AddFollowerBusinessIDs adds the "followerBusinesses" edge to the BusinessFollowBusiness entity by ids.
func (m *BusinessMutation) AddFollowerBusinessIDs(ids ...string) {
	if m.followerBusinesses == nil {
		m.followerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followerBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowerBusinesses clears the "followerBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) ClearFollowerBusinesses() {
	m.clearedfollowerBusinesses = true
}

// FollowerBusinessesCleared reports if the "followerBusinesses" edge to the BusinessFollowBusiness entity was cleared.
func (m *BusinessMutation) FollowerBusinessesCleared() bool {
	return m.clearedfollowerBusinesses
}

// RemoveFollowerBusinessIDs removes the "followerBusinesses" edge to the BusinessFollowBusiness entity by IDs.
func (m *BusinessMutation) RemoveFollowerBusinessIDs(ids ...string) {
	if m.removedfollowerBusinesses == nil {
		m.removedfollowerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerBusinesses, ids[i])
		m.removedfollowerBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowerBusinesses returns the removed IDs of the "followerBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) RemovedFollowerBusinessesIDs() (ids []string) {
	for id := range m.removedfollowerBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowerBusinessesIDs returns the "followerBusinesses" edge IDs in the mutation.
func (m *BusinessMutation) FollowerBusinessesIDs() (ids []string) {
	for id := range m.followerBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerBusinesses resets all changes to the "followerBusinesses" edge.
func (m *BusinessMutation) ResetFollowerBusinesses() {
	m.followerBusinesses = nil
	m.clearedfollowerBusinesses = false
	m.removedfollowerBusinesses = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *BusinessMutation) AddPlaceIDs(ids ...string) {
	if m.places == nil {
		m.places = make(map[string]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *BusinessMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *BusinessMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *BusinessMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *BusinessMutation) RemovedPlacesIDs() (ids []string) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *BusinessMutation) PlacesIDs() (ids []string) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *BusinessMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *BusinessMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *BusinessMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *BusinessMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *BusinessMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *BusinessMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *BusinessMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *BusinessMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *BusinessMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *BusinessMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *BusinessMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *BusinessMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *BusinessMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *BusinessMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *BusinessMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *BusinessMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *BusinessMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *BusinessMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *BusinessMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *BusinessMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *BusinessMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *BusinessMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddBusinessFollowEventIDs adds the "businessFollowEvents" edge to the BusinessFollowEvent entity by ids.
func (m *BusinessMutation) AddBusinessFollowEventIDs(ids ...string) {
	if m.businessFollowEvents == nil {
		m.businessFollowEvents = make(map[string]struct{})
	}
	for i := range ids {
		m.businessFollowEvents[ids[i]] = struct{}{}
	}
}

// ClearBusinessFollowEvents clears the "businessFollowEvents" edge to the BusinessFollowEvent entity.
func (m *BusinessMutation) ClearBusinessFollowEvents() {
	m.clearedbusinessFollowEvents = true
}

// BusinessFollowEventsCleared reports if the "businessFollowEvents" edge to the BusinessFollowEvent entity was cleared.
func (m *BusinessMutation) BusinessFollowEventsCleared() bool {
	return m.clearedbusinessFollowEvents
}

// RemoveBusinessFollowEventIDs removes the "businessFollowEvents" edge to the BusinessFollowEvent entity by IDs.
func (m *BusinessMutation) RemoveBusinessFollowEventIDs(ids ...string) {
	if m.removedbusinessFollowEvents == nil {
		m.removedbusinessFollowEvents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.businessFollowEvents, ids[i])
		m.removedbusinessFollowEvents[ids[i]] = struct{}{}
	}
}

// RemovedBusinessFollowEvents returns the removed IDs of the "businessFollowEvents" edge to the BusinessFollowEvent entity.
func (m *BusinessMutation) RemovedBusinessFollowEventsIDs() (ids []string) {
	for id := range m.removedbusinessFollowEvents {
		ids = append(ids, id)
	}
	return
}

// BusinessFollowEventsIDs returns the "businessFollowEvents" edge IDs in the mutation.
func (m *BusinessMutation) BusinessFollowEventsIDs() (ids []string) {
	for id := range m.businessFollowEvents {
		ids = append(ids, id)
	}
	return
}

// ResetBusinessFollowEvents resets all changes to the "businessFollowEvents" edge.
func (m *BusinessMutation) ResetBusinessFollowEvents() {
	m.businessFollowEvents = nil
	m.clearedbusinessFollowEvents = false
	m.removedbusinessFollowEvents = nil
}

// AddFaqIDs adds the "faqs" edge to the FAQ entity by ids.
func (m *BusinessMutation) AddFaqIDs(ids ...string) {
	if m.faqs == nil {
		m.faqs = make(map[string]struct{})
	}
	for i := range ids {
		m.faqs[ids[i]] = struct{}{}
	}
}

// ClearFaqs clears the "faqs" edge to the FAQ entity.
func (m *BusinessMutation) ClearFaqs() {
	m.clearedfaqs = true
}

// FaqsCleared reports if the "faqs" edge to the FAQ entity was cleared.
func (m *BusinessMutation) FaqsCleared() bool {
	return m.clearedfaqs
}

// RemoveFaqIDs removes the "faqs" edge to the FAQ entity by IDs.
func (m *BusinessMutation) RemoveFaqIDs(ids ...string) {
	if m.removedfaqs == nil {
		m.removedfaqs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.faqs, ids[i])
		m.removedfaqs[ids[i]] = struct{}{}
	}
}

// RemovedFaqs returns the removed IDs of the "faqs" edge to the FAQ entity.
func (m *BusinessMutation) RemovedFaqsIDs() (ids []string) {
	for id := range m.removedfaqs {
		ids = append(ids, id)
	}
	return
}

// FaqsIDs returns the "faqs" edge IDs in the mutation.
func (m *BusinessMutation) FaqsIDs() (ids []string) {
	for id := range m.faqs {
		ids = append(ids, id)
	}
	return
}

// ResetFaqs resets all changes to the "faqs" edge.
func (m *BusinessMutation) ResetFaqs() {
	m.faqs = nil
	m.clearedfaqs = false
	m.removedfaqs = nil
}

// AddRatingIDs adds the "ratings" edge to the Rating entity by ids.
func (m *BusinessMutation) AddRatingIDs(ids ...string) {
	if m.ratings == nil {
		m.ratings = make(map[string]struct{})
	}
	for i := range ids {
		m.ratings[ids[i]] = struct{}{}
	}
}

// ClearRatings clears the "ratings" edge to the Rating entity.
func (m *BusinessMutation) ClearRatings() {
	m.clearedratings = true
}

// RatingsCleared reports if the "ratings" edge to the Rating entity was cleared.
func (m *BusinessMutation) RatingsCleared() bool {
	return m.clearedratings
}

// RemoveRatingIDs removes the "ratings" edge to the Rating entity by IDs.
func (m *BusinessMutation) RemoveRatingIDs(ids ...string) {
	if m.removedratings == nil {
		m.removedratings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratings, ids[i])
		m.removedratings[ids[i]] = struct{}{}
	}
}

// RemovedRatings returns the removed IDs of the "ratings" edge to the Rating entity.
func (m *BusinessMutation) RemovedRatingsIDs() (ids []string) {
	for id := range m.removedratings {
		ids = append(ids, id)
	}
	return
}

// RatingsIDs returns the "ratings" edge IDs in the mutation.
func (m *BusinessMutation) RatingsIDs() (ids []string) {
	for id := range m.ratings {
		ids = append(ids, id)
	}
	return
}

// ResetRatings resets all changes to the "ratings" edge.
func (m *BusinessMutation) ResetRatings() {
	m.ratings = nil
	m.clearedratings = false
	m.removedratings = nil
}

// AddPlaceInventoryIDs adds the "place_inventories" edge to the PlaceInventory entity by ids.
func (m *BusinessMutation) AddPlaceInventoryIDs(ids ...string) {
	if m.place_inventories == nil {
		m.place_inventories = make(map[string]struct{})
	}
	for i := range ids {
		m.place_inventories[ids[i]] = struct{}{}
	}
}

// ClearPlaceInventories clears the "place_inventories" edge to the PlaceInventory entity.
func (m *BusinessMutation) ClearPlaceInventories() {
	m.clearedplace_inventories = true
}

// PlaceInventoriesCleared reports if the "place_inventories" edge to the PlaceInventory entity was cleared.
func (m *BusinessMutation) PlaceInventoriesCleared() bool {
	return m.clearedplace_inventories
}

// RemovePlaceInventoryIDs removes the "place_inventories" edge to the PlaceInventory entity by IDs.
func (m *BusinessMutation) RemovePlaceInventoryIDs(ids ...string) {
	if m.removedplace_inventories == nil {
		m.removedplace_inventories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place_inventories, ids[i])
		m.removedplace_inventories[ids[i]] = struct{}{}
	}
}

// RemovedPlaceInventories returns the removed IDs of the "place_inventories" edge to the PlaceInventory entity.
func (m *BusinessMutation) RemovedPlaceInventoriesIDs() (ids []string) {
	for id := range m.removedplace_inventories {
		ids = append(ids, id)
	}
	return
}

// PlaceInventoriesIDs returns the "place_inventories" edge IDs in the mutation.
func (m *BusinessMutation) PlaceInventoriesIDs() (ids []string) {
	for id := range m.place_inventories {
		ids = append(ids, id)
	}
	return
}

// ResetPlaceInventories resets all changes to the "place_inventories" edge.
func (m *BusinessMutation) ResetPlaceInventories() {
	m.place_inventories = nil
	m.clearedplace_inventories = false
	m.removedplace_inventories = nil
}

// SetWebsitesID sets the "websites" edge to the Website entity by id.
func (m *BusinessMutation) SetWebsitesID(id string) {
	m.websites = &id
}

// ClearWebsites clears the "websites" edge to the Website entity.
func (m *BusinessMutation) ClearWebsites() {
	m.clearedwebsites = true
}

// WebsitesCleared reports if the "websites" edge to the Website entity was cleared.
func (m *BusinessMutation) WebsitesCleared() bool {
	return m.clearedwebsites
}

// WebsitesID returns the "websites" edge ID in the mutation.
func (m *BusinessMutation) WebsitesID() (id string, exists bool) {
	if m.websites != nil {
		return *m.websites, true
	}
	return
}

// WebsitesIDs returns the "websites" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WebsitesID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) WebsitesIDs() (ids []string) {
	if id := m.websites; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWebsites resets all changes to the "websites" edge.
func (m *BusinessMutation) ResetWebsites() {
	m.websites = nil
	m.clearedwebsites = false
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *BusinessMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *BusinessMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *BusinessMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *BusinessMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *BusinessMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *BusinessMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *BusinessMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// SetWalletID sets the "wallet" edge to the AccountWallet entity by id.
func (m *BusinessMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the AccountWallet entity.
func (m *BusinessMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the AccountWallet entity was cleared.
func (m *BusinessMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *BusinessMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *BusinessMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// AddStaffIDs adds the "staffs" edge to the Staff entity by ids.
func (m *BusinessMutation) AddStaffIDs(ids ...string) {
	if m.staffs == nil {
		m.staffs = make(map[string]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the Staff entity.
func (m *BusinessMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the Staff entity was cleared.
func (m *BusinessMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the Staff entity by IDs.
func (m *BusinessMutation) RemoveStaffIDs(ids ...string) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the Staff entity.
func (m *BusinessMutation) RemovedStaffsIDs() (ids []string) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *BusinessMutation) StaffsIDs() (ids []string) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *BusinessMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *BusinessMutation) AddPlanIDs(ids ...string) {
	if m.plans == nil {
		m.plans = make(map[string]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *BusinessMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *BusinessMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *BusinessMutation) RemovePlanIDs(ids ...string) {
	if m.removedplans == nil {
		m.removedplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *BusinessMutation) RemovedPlansIDs() (ids []string) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *BusinessMutation) PlansIDs() (ids []string) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *BusinessMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// Where appends a list predicates to the BusinessMutation builder.
func (m *BusinessMutation) Where(ps ...predicate.Business) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Business, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Business).
func (m *BusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, business.FieldName)
	}
	if m.description != nil {
		fields = append(fields, business.FieldDescription)
	}
	if m.picture != nil {
		fields = append(fields, business.FieldPicture)
	}
	if m.cover_image != nil {
		fields = append(fields, business.FieldCoverImage)
	}
	if m.website != nil {
		fields = append(fields, business.FieldWebsite)
	}
	if m.location != nil {
		fields = append(fields, business.FieldLocation)
	}
	if m.longitude != nil {
		fields = append(fields, business.FieldLongitude)
	}
	if m.map_coordinates != nil {
		fields = append(fields, business.FieldMapCoordinates)
	}
	if m.latitude != nil {
		fields = append(fields, business.FieldLatitude)
	}
	if m.email != nil {
		fields = append(fields, business.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, business.FieldPhone)
	}
	if m.business_settings != nil {
		fields = append(fields, business.FieldBusinessSettings)
	}
	if m.url != nil {
		fields = append(fields, business.FieldURL)
	}
	if m.search_text != nil {
		fields = append(fields, business.FieldSearchText)
	}
	if m.relevance_score != nil {
		fields = append(fields, business.FieldRelevanceScore)
	}
	if m.follower_count != nil {
		fields = append(fields, business.FieldFollowerCount)
	}
	if m.following_count != nil {
		fields = append(fields, business.FieldFollowingCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case business.FieldName:
		return m.Name()
	case business.FieldDescription:
		return m.Description()
	case business.FieldPicture:
		return m.Picture()
	case business.FieldCoverImage:
		return m.CoverImage()
	case business.FieldWebsite:
		return m.Website()
	case business.FieldLocation:
		return m.Location()
	case business.FieldLongitude:
		return m.Longitude()
	case business.FieldMapCoordinates:
		return m.MapCoordinates()
	case business.FieldLatitude:
		return m.Latitude()
	case business.FieldEmail:
		return m.Email()
	case business.FieldPhone:
		return m.Phone()
	case business.FieldBusinessSettings:
		return m.BusinessSettings()
	case business.FieldURL:
		return m.URL()
	case business.FieldSearchText:
		return m.SearchText()
	case business.FieldRelevanceScore:
		return m.RelevanceScore()
	case business.FieldFollowerCount:
		return m.FollowerCount()
	case business.FieldFollowingCount:
		return m.FollowingCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case business.FieldName:
		return m.OldName(ctx)
	case business.FieldDescription:
		return m.OldDescription(ctx)
	case business.FieldPicture:
		return m.OldPicture(ctx)
	case business.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case business.FieldWebsite:
		return m.OldWebsite(ctx)
	case business.FieldLocation:
		return m.OldLocation(ctx)
	case business.FieldLongitude:
		return m.OldLongitude(ctx)
	case business.FieldMapCoordinates:
		return m.OldMapCoordinates(ctx)
	case business.FieldLatitude:
		return m.OldLatitude(ctx)
	case business.FieldEmail:
		return m.OldEmail(ctx)
	case business.FieldPhone:
		return m.OldPhone(ctx)
	case business.FieldBusinessSettings:
		return m.OldBusinessSettings(ctx)
	case business.FieldURL:
		return m.OldURL(ctx)
	case business.FieldSearchText:
		return m.OldSearchText(ctx)
	case business.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	case business.FieldFollowerCount:
		return m.OldFollowerCount(ctx)
	case business.FieldFollowingCount:
		return m.OldFollowingCount(ctx)
	}
	return nil, fmt.Errorf("unknown Business field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case business.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case business.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case business.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case business.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case business.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case business.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case business.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case business.FieldMapCoordinates:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapCoordinates(v)
		return nil
	case business.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case business.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case business.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case business.FieldBusinessSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessSettings(v)
		return nil
	case business.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case business.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	case business.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	case business.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerCount(v)
		return nil
	case business.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessMutation) AddedFields() []string {
	var fields []string
	if m.addrelevance_score != nil {
		fields = append(fields, business.FieldRelevanceScore)
	}
	if m.addfollower_count != nil {
		fields = append(fields, business.FieldFollowerCount)
	}
	if m.addfollowing_count != nil {
		fields = append(fields, business.FieldFollowingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case business.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	case business.FieldFollowerCount:
		return m.AddedFollowerCount()
	case business.FieldFollowingCount:
		return m.AddedFollowingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case business.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	case business.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowerCount(v)
		return nil
	case business.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Business numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(business.FieldDescription) {
		fields = append(fields, business.FieldDescription)
	}
	if m.FieldCleared(business.FieldPicture) {
		fields = append(fields, business.FieldPicture)
	}
	if m.FieldCleared(business.FieldCoverImage) {
		fields = append(fields, business.FieldCoverImage)
	}
	if m.FieldCleared(business.FieldWebsite) {
		fields = append(fields, business.FieldWebsite)
	}
	if m.FieldCleared(business.FieldLocation) {
		fields = append(fields, business.FieldLocation)
	}
	if m.FieldCleared(business.FieldLongitude) {
		fields = append(fields, business.FieldLongitude)
	}
	if m.FieldCleared(business.FieldMapCoordinates) {
		fields = append(fields, business.FieldMapCoordinates)
	}
	if m.FieldCleared(business.FieldLatitude) {
		fields = append(fields, business.FieldLatitude)
	}
	if m.FieldCleared(business.FieldEmail) {
		fields = append(fields, business.FieldEmail)
	}
	if m.FieldCleared(business.FieldPhone) {
		fields = append(fields, business.FieldPhone)
	}
	if m.FieldCleared(business.FieldBusinessSettings) {
		fields = append(fields, business.FieldBusinessSettings)
	}
	if m.FieldCleared(business.FieldURL) {
		fields = append(fields, business.FieldURL)
	}
	if m.FieldCleared(business.FieldSearchText) {
		fields = append(fields, business.FieldSearchText)
	}
	if m.FieldCleared(business.FieldRelevanceScore) {
		fields = append(fields, business.FieldRelevanceScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessMutation) ClearField(name string) error {
	switch name {
	case business.FieldDescription:
		m.ClearDescription()
		return nil
	case business.FieldPicture:
		m.ClearPicture()
		return nil
	case business.FieldCoverImage:
		m.ClearCoverImage()
		return nil
	case business.FieldWebsite:
		m.ClearWebsite()
		return nil
	case business.FieldLocation:
		m.ClearLocation()
		return nil
	case business.FieldLongitude:
		m.ClearLongitude()
		return nil
	case business.FieldMapCoordinates:
		m.ClearMapCoordinates()
		return nil
	case business.FieldLatitude:
		m.ClearLatitude()
		return nil
	case business.FieldEmail:
		m.ClearEmail()
		return nil
	case business.FieldPhone:
		m.ClearPhone()
		return nil
	case business.FieldBusinessSettings:
		m.ClearBusinessSettings()
		return nil
	case business.FieldURL:
		m.ClearURL()
		return nil
	case business.FieldSearchText:
		m.ClearSearchText()
		return nil
	case business.FieldRelevanceScore:
		m.ClearRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown Business nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessMutation) ResetField(name string) error {
	switch name {
	case business.FieldName:
		m.ResetName()
		return nil
	case business.FieldDescription:
		m.ResetDescription()
		return nil
	case business.FieldPicture:
		m.ResetPicture()
		return nil
	case business.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case business.FieldWebsite:
		m.ResetWebsite()
		return nil
	case business.FieldLocation:
		m.ResetLocation()
		return nil
	case business.FieldLongitude:
		m.ResetLongitude()
		return nil
	case business.FieldMapCoordinates:
		m.ResetMapCoordinates()
		return nil
	case business.FieldLatitude:
		m.ResetLatitude()
		return nil
	case business.FieldEmail:
		m.ResetEmail()
		return nil
	case business.FieldPhone:
		m.ResetPhone()
		return nil
	case business.FieldBusinessSettings:
		m.ResetBusinessSettings()
		return nil
	case business.FieldURL:
		m.ResetURL()
		return nil
	case business.FieldSearchText:
		m.ResetSearchText()
		return nil
	case business.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	case business.FieldFollowerCount:
		m.ResetFollowerCount()
		return nil
	case business.FieldFollowingCount:
		m.ResetFollowingCount()
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 20)
	if m.userBusinesses != nil {
		edges = append(edges, business.EdgeUserBusinesses)
	}
	if m.business_account_settings != nil {
		edges = append(edges, business.EdgeBusinessAccountSettings)
	}
	if m.posts != nil {
		edges = append(edges, business.EdgePosts)
	}
	if m.followedUsers != nil {
		edges = append(edges, business.EdgeFollowedUsers)
	}
	if m.followerUsers != nil {
		edges = append(edges, business.EdgeFollowerUsers)
	}
	if m.followedBusinesses != nil {
		edges = append(edges, business.EdgeFollowedBusinesses)
	}
	if m.followerBusinesses != nil {
		edges = append(edges, business.EdgeFollowerBusinesses)
	}
	if m.places != nil {
		edges = append(edges, business.EdgePlaces)
	}
	if m.categories != nil {
		edges = append(edges, business.EdgeCategories)
	}
	if m.categoryAssignments != nil {
		edges = append(edges, business.EdgeCategoryAssignments)
	}
	if m.events != nil {
		edges = append(edges, business.EdgeEvents)
	}
	if m.businessFollowEvents != nil {
		edges = append(edges, business.EdgeBusinessFollowEvents)
	}
	if m.faqs != nil {
		edges = append(edges, business.EdgeFaqs)
	}
	if m.ratings != nil {
		edges = append(edges, business.EdgeRatings)
	}
	if m.place_inventories != nil {
		edges = append(edges, business.EdgePlaceInventories)
	}
	if m.websites != nil {
		edges = append(edges, business.EdgeWebsites)
	}
	if m.notifications != nil {
		edges = append(edges, business.EdgeNotifications)
	}
	if m.wallet != nil {
		edges = append(edges, business.EdgeWallet)
	}
	if m.staffs != nil {
		edges = append(edges, business.EdgeStaffs)
	}
	if m.plans != nil {
		edges = append(edges, business.EdgePlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.userBusinesses))
		for id := range m.userBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeBusinessAccountSettings:
		if id := m.business_account_settings; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.followedUsers))
		for id := range m.followedUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.followerUsers))
		for id := range m.followerUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.followedBusinesses))
		for id := range m.followedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.followerBusinesses))
		for id := range m.followerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeBusinessFollowEvents:
		ids := make([]ent.Value, 0, len(m.businessFollowEvents))
		for id := range m.businessFollowEvents {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFaqs:
		ids := make([]ent.Value, 0, len(m.faqs))
		for id := range m.faqs {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.ratings))
		for id := range m.ratings {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlaceInventories:
		ids := make([]ent.Value, 0, len(m.place_inventories))
		for id := range m.place_inventories {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeWebsites:
		if id := m.websites; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 20)
	if m.removeduserBusinesses != nil {
		edges = append(edges, business.EdgeUserBusinesses)
	}
	if m.removedposts != nil {
		edges = append(edges, business.EdgePosts)
	}
	if m.removedfollowedUsers != nil {
		edges = append(edges, business.EdgeFollowedUsers)
	}
	if m.removedfollowerUsers != nil {
		edges = append(edges, business.EdgeFollowerUsers)
	}
	if m.removedfollowedBusinesses != nil {
		edges = append(edges, business.EdgeFollowedBusinesses)
	}
	if m.removedfollowerBusinesses != nil {
		edges = append(edges, business.EdgeFollowerBusinesses)
	}
	if m.removedplaces != nil {
		edges = append(edges, business.EdgePlaces)
	}
	if m.removedcategories != nil {
		edges = append(edges, business.EdgeCategories)
	}
	if m.removedcategoryAssignments != nil {
		edges = append(edges, business.EdgeCategoryAssignments)
	}
	if m.removedevents != nil {
		edges = append(edges, business.EdgeEvents)
	}
	if m.removedbusinessFollowEvents != nil {
		edges = append(edges, business.EdgeBusinessFollowEvents)
	}
	if m.removedfaqs != nil {
		edges = append(edges, business.EdgeFaqs)
	}
	if m.removedratings != nil {
		edges = append(edges, business.EdgeRatings)
	}
	if m.removedplace_inventories != nil {
		edges = append(edges, business.EdgePlaceInventories)
	}
	if m.removednotifications != nil {
		edges = append(edges, business.EdgeNotifications)
	}
	if m.removedstaffs != nil {
		edges = append(edges, business.EdgeStaffs)
	}
	if m.removedplans != nil {
		edges = append(edges, business.EdgePlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.removeduserBusinesses))
		for id := range m.removeduserBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowedUsers))
		for id := range m.removedfollowedUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowerUsers))
		for id := range m.removedfollowerUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowedBusinesses))
		for id := range m.removedfollowedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowerBusinesses))
		for id := range m.removedfollowerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeBusinessFollowEvents:
		ids := make([]ent.Value, 0, len(m.removedbusinessFollowEvents))
		for id := range m.removedbusinessFollowEvents {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFaqs:
		ids := make([]ent.Value, 0, len(m.removedfaqs))
		for id := range m.removedfaqs {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.removedratings))
		for id := range m.removedratings {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlaceInventories:
		ids := make([]ent.Value, 0, len(m.removedplace_inventories))
		for id := range m.removedplace_inventories {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 20)
	if m.cleareduserBusinesses {
		edges = append(edges, business.EdgeUserBusinesses)
	}
	if m.clearedbusiness_account_settings {
		edges = append(edges, business.EdgeBusinessAccountSettings)
	}
	if m.clearedposts {
		edges = append(edges, business.EdgePosts)
	}
	if m.clearedfollowedUsers {
		edges = append(edges, business.EdgeFollowedUsers)
	}
	if m.clearedfollowerUsers {
		edges = append(edges, business.EdgeFollowerUsers)
	}
	if m.clearedfollowedBusinesses {
		edges = append(edges, business.EdgeFollowedBusinesses)
	}
	if m.clearedfollowerBusinesses {
		edges = append(edges, business.EdgeFollowerBusinesses)
	}
	if m.clearedplaces {
		edges = append(edges, business.EdgePlaces)
	}
	if m.clearedcategories {
		edges = append(edges, business.EdgeCategories)
	}
	if m.clearedcategoryAssignments {
		edges = append(edges, business.EdgeCategoryAssignments)
	}
	if m.clearedevents {
		edges = append(edges, business.EdgeEvents)
	}
	if m.clearedbusinessFollowEvents {
		edges = append(edges, business.EdgeBusinessFollowEvents)
	}
	if m.clearedfaqs {
		edges = append(edges, business.EdgeFaqs)
	}
	if m.clearedratings {
		edges = append(edges, business.EdgeRatings)
	}
	if m.clearedplace_inventories {
		edges = append(edges, business.EdgePlaceInventories)
	}
	if m.clearedwebsites {
		edges = append(edges, business.EdgeWebsites)
	}
	if m.clearednotifications {
		edges = append(edges, business.EdgeNotifications)
	}
	if m.clearedwallet {
		edges = append(edges, business.EdgeWallet)
	}
	if m.clearedstaffs {
		edges = append(edges, business.EdgeStaffs)
	}
	if m.clearedplans {
		edges = append(edges, business.EdgePlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case business.EdgeUserBusinesses:
		return m.cleareduserBusinesses
	case business.EdgeBusinessAccountSettings:
		return m.clearedbusiness_account_settings
	case business.EdgePosts:
		return m.clearedposts
	case business.EdgeFollowedUsers:
		return m.clearedfollowedUsers
	case business.EdgeFollowerUsers:
		return m.clearedfollowerUsers
	case business.EdgeFollowedBusinesses:
		return m.clearedfollowedBusinesses
	case business.EdgeFollowerBusinesses:
		return m.clearedfollowerBusinesses
	case business.EdgePlaces:
		return m.clearedplaces
	case business.EdgeCategories:
		return m.clearedcategories
	case business.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	case business.EdgeEvents:
		return m.clearedevents
	case business.EdgeBusinessFollowEvents:
		return m.clearedbusinessFollowEvents
	case business.EdgeFaqs:
		return m.clearedfaqs
	case business.EdgeRatings:
		return m.clearedratings
	case business.EdgePlaceInventories:
		return m.clearedplace_inventories
	case business.EdgeWebsites:
		return m.clearedwebsites
	case business.EdgeNotifications:
		return m.clearednotifications
	case business.EdgeWallet:
		return m.clearedwallet
	case business.EdgeStaffs:
		return m.clearedstaffs
	case business.EdgePlans:
		return m.clearedplans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessMutation) ClearEdge(name string) error {
	switch name {
	case business.EdgeBusinessAccountSettings:
		m.ClearBusinessAccountSettings()
		return nil
	case business.EdgeWebsites:
		m.ClearWebsites()
		return nil
	case business.EdgeWallet:
		m.ClearWallet()
		return nil
	}
	return fmt.Errorf("unknown Business unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessMutation) ResetEdge(name string) error {
	switch name {
	case business.EdgeUserBusinesses:
		m.ResetUserBusinesses()
		return nil
	case business.EdgeBusinessAccountSettings:
		m.ResetBusinessAccountSettings()
		return nil
	case business.EdgePosts:
		m.ResetPosts()
		return nil
	case business.EdgeFollowedUsers:
		m.ResetFollowedUsers()
		return nil
	case business.EdgeFollowerUsers:
		m.ResetFollowerUsers()
		return nil
	case business.EdgeFollowedBusinesses:
		m.ResetFollowedBusinesses()
		return nil
	case business.EdgeFollowerBusinesses:
		m.ResetFollowerBusinesses()
		return nil
	case business.EdgePlaces:
		m.ResetPlaces()
		return nil
	case business.EdgeCategories:
		m.ResetCategories()
		return nil
	case business.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	case business.EdgeEvents:
		m.ResetEvents()
		return nil
	case business.EdgeBusinessFollowEvents:
		m.ResetBusinessFollowEvents()
		return nil
	case business.EdgeFaqs:
		m.ResetFaqs()
		return nil
	case business.EdgeRatings:
		m.ResetRatings()
		return nil
	case business.EdgePlaceInventories:
		m.ResetPlaceInventories()
		return nil
	case business.EdgeWebsites:
		m.ResetWebsites()
		return nil
	case business.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case business.EdgeWallet:
		m.ResetWallet()
		return nil
	case business.EdgeStaffs:
		m.ResetStaffs()
		return nil
	case business.EdgePlans:
		m.ResetPlans()
		return nil
	}
	return fmt.Errorf("unknown Business edge %s", name)
}

// BusinessFollowBusinessMutation represents an operation that mutates the BusinessFollowBusiness nodes in the graph.
type BusinessFollowBusinessMutation struct {
	config
	op              Op
	typ             string
	id              *string
	_CreatedAt      *time.Time
	_UpdatedAt      *time.Time
	clearedFields   map[string]struct{}
	follower        *string
	clearedfollower bool
	followed        *string
	clearedfollowed bool
	done            bool
	oldValue        func(context.Context) (*BusinessFollowBusiness, error)
	predicates      []predicate.BusinessFollowBusiness
}

var _ ent.Mutation = (*BusinessFollowBusinessMutation)(nil)

// businessfollowbusinessOption allows management of the mutation configuration using functional options.
type businessfollowbusinessOption func(*BusinessFollowBusinessMutation)

// newBusinessFollowBusinessMutation creates new mutation for the BusinessFollowBusiness entity.
func newBusinessFollowBusinessMutation(c config, op Op, opts ...businessfollowbusinessOption) *BusinessFollowBusinessMutation {
	m := &BusinessFollowBusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessFollowBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessFollowBusinessID sets the ID field of the mutation.
func withBusinessFollowBusinessID(id string) businessfollowbusinessOption {
	return func(m *BusinessFollowBusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessFollowBusiness
		)
		m.oldValue = func(ctx context.Context) (*BusinessFollowBusiness, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessFollowBusiness.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessFollowBusiness sets the old BusinessFollowBusiness of the mutation.
func withBusinessFollowBusiness(node *BusinessFollowBusiness) businessfollowbusinessOption {
	return func(m *BusinessFollowBusinessMutation) {
		m.oldValue = func(context.Context) (*BusinessFollowBusiness, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessFollowBusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessFollowBusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BusinessFollowBusiness entities.
func (m *BusinessFollowBusinessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessFollowBusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessFollowBusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessFollowBusiness.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *BusinessFollowBusinessMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *BusinessFollowBusinessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the BusinessFollowBusiness entity.
// If the BusinessFollowBusiness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessFollowBusinessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *BusinessFollowBusinessMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *BusinessFollowBusinessMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *BusinessFollowBusinessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the BusinessFollowBusiness entity.
// If the BusinessFollowBusiness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessFollowBusinessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *BusinessFollowBusinessMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetFollowerID sets the "follower" edge to the Business entity by id.
func (m *BusinessFollowBusinessMutation) SetFollowerID(id string) {
	m.follower = &id
}

// ClearFollower clears the "follower" edge to the Business entity.
func (m *BusinessFollowBusinessMutation) ClearFollower() {
	m.clearedfollower = true
}

// FollowerCleared reports if the "follower" edge to the Business entity was cleared.
func (m *BusinessFollowBusinessMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// FollowerID returns the "follower" edge ID in the mutation.
func (m *BusinessFollowBusinessMutation) FollowerID() (id string, exists bool) {
	if m.follower != nil {
		return *m.follower, true
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowBusinessMutation) FollowerIDs() (ids []string) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *BusinessFollowBusinessMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFollowedID sets the "followed" edge to the Business entity by id.
func (m *BusinessFollowBusinessMutation) SetFollowedID(id string) {
	m.followed = &id
}

// ClearFollowed clears the "followed" edge to the Business entity.
func (m *BusinessFollowBusinessMutation) ClearFollowed() {
	m.clearedfollowed = true
}

// FollowedCleared reports if the "followed" edge to the Business entity was cleared.
func (m *BusinessFollowBusinessMutation) FollowedCleared() bool {
	return m.clearedfollowed
}

// FollowedID returns the "followed" edge ID in the mutation.
func (m *BusinessFollowBusinessMutation) FollowedID() (id string, exists bool) {
	if m.followed != nil {
		return *m.followed, true
	}
	return
}

// FollowedIDs returns the "followed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowedID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowBusinessMutation) FollowedIDs() (ids []string) {
	if id := m.followed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowed resets all changes to the "followed" edge.
func (m *BusinessFollowBusinessMutation) ResetFollowed() {
	m.followed = nil
	m.clearedfollowed = false
}

// Where appends a list predicates to the BusinessFollowBusinessMutation builder.
func (m *BusinessFollowBusinessMutation) Where(ps ...predicate.BusinessFollowBusiness) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessFollowBusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessFollowBusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessFollowBusiness, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessFollowBusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessFollowBusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessFollowBusiness).
func (m *BusinessFollowBusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessFollowBusinessMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreatedAt != nil {
		fields = append(fields, businessfollowbusiness.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, businessfollowbusiness.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessFollowBusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case businessfollowbusiness.FieldCreatedAt:
		return m.CreatedAt()
	case businessfollowbusiness.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessFollowBusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case businessfollowbusiness.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case businessfollowbusiness.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BusinessFollowBusiness field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowBusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case businessfollowbusiness.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case businessfollowbusiness.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowBusiness field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessFollowBusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessFollowBusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowBusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessFollowBusiness numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessFollowBusinessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessFollowBusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BusinessFollowBusiness nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ResetField(name string) error {
	switch name {
	case businessfollowbusiness.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case businessfollowbusiness.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowBusiness field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessFollowBusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, businessfollowbusiness.EdgeFollower)
	}
	if m.followed != nil {
		edges = append(edges, businessfollowbusiness.EdgeFollowed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessFollowBusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case businessfollowbusiness.EdgeFollowed:
		if id := m.followed; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessFollowBusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessFollowBusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessFollowBusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, businessfollowbusiness.EdgeFollower)
	}
	if m.clearedfollowed {
		edges = append(edges, businessfollowbusiness.EdgeFollowed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessFollowBusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		return m.clearedfollower
	case businessfollowbusiness.EdgeFollowed:
		return m.clearedfollowed
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ClearEdge(name string) error {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		m.ClearFollower()
		return nil
	case businessfollowbusiness.EdgeFollowed:
		m.ClearFollowed()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowBusiness unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ResetEdge(name string) error {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		m.ResetFollower()
		return nil
	case businessfollowbusiness.EdgeFollowed:
		m.ResetFollowed()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowBusiness edge %s", name)
}

// BusinessFollowEventMutation represents an operation that mutates the BusinessFollowEvent nodes in the graph.
type BusinessFollowEventMutation struct {
	config
	op              Op
	typ             string
	id              *string
	createdAt       *time.Time
	updatedAt       *time.Time
	clearedFields   map[string]struct{}
	business        *string
	clearedbusiness bool
	event           *string
	clearedevent    bool
	done            bool
	oldValue        func(context.Context) (*BusinessFollowEvent, error)
	predicates      []predicate.BusinessFollowEvent
}

var _ ent.Mutation = (*BusinessFollowEventMutation)(nil)

// businessfolloweventOption allows management of the mutation configuration using functional options.
type businessfolloweventOption func(*BusinessFollowEventMutation)

// newBusinessFollowEventMutation creates new mutation for the BusinessFollowEvent entity.
func newBusinessFollowEventMutation(c config, op Op, opts ...businessfolloweventOption) *BusinessFollowEventMutation {
	m := &BusinessFollowEventMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessFollowEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessFollowEventID sets the ID field of the mutation.
func withBusinessFollowEventID(id string) businessfolloweventOption {
	return func(m *BusinessFollowEventMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessFollowEvent
		)
		m.oldValue = func(ctx context.Context) (*BusinessFollowEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessFollowEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessFollowEvent sets the old BusinessFollowEvent of the mutation.
func withBusinessFollowEvent(node *BusinessFollowEvent) businessfolloweventOption {
	return func(m *BusinessFollowEventMutation) {
		m.oldValue = func(context.Context) (*BusinessFollowEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessFollowEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessFollowEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BusinessFollowEvent entities.
func (m *BusinessFollowEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessFollowEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessFollowEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessFollowEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *BusinessFollowEventMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *BusinessFollowEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the BusinessFollowEvent entity.
// If the BusinessFollowEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessFollowEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *BusinessFollowEventMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *BusinessFollowEventMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *BusinessFollowEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the BusinessFollowEvent entity.
// If the BusinessFollowEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessFollowEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *BusinessFollowEventMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *BusinessFollowEventMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *BusinessFollowEventMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *BusinessFollowEventMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *BusinessFollowEventMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowEventMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *BusinessFollowEventMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *BusinessFollowEventMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *BusinessFollowEventMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *BusinessFollowEventMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *BusinessFollowEventMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowEventMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *BusinessFollowEventMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the BusinessFollowEventMutation builder.
func (m *BusinessFollowEventMutation) Where(ps ...predicate.BusinessFollowEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessFollowEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessFollowEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessFollowEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessFollowEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessFollowEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessFollowEvent).
func (m *BusinessFollowEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessFollowEventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.createdAt != nil {
		fields = append(fields, businessfollowevent.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, businessfollowevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessFollowEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case businessfollowevent.FieldCreatedAt:
		return m.CreatedAt()
	case businessfollowevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessFollowEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case businessfollowevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case businessfollowevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BusinessFollowEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case businessfollowevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case businessfollowevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessFollowEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessFollowEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessFollowEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessFollowEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessFollowEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessFollowEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BusinessFollowEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessFollowEventMutation) ResetField(name string) error {
	switch name {
	case businessfollowevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case businessfollowevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessFollowEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business != nil {
		edges = append(edges, businessfollowevent.EdgeBusiness)
	}
	if m.event != nil {
		edges = append(edges, businessfollowevent.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessFollowEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessfollowevent.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case businessfollowevent.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessFollowEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessFollowEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessFollowEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness {
		edges = append(edges, businessfollowevent.EdgeBusiness)
	}
	if m.clearedevent {
		edges = append(edges, businessfollowevent.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessFollowEventMutation) EdgeCleared(name string) bool {
	switch name {
	case businessfollowevent.EdgeBusiness:
		return m.clearedbusiness
	case businessfollowevent.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessFollowEventMutation) ClearEdge(name string) error {
	switch name {
	case businessfollowevent.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case businessfollowevent.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessFollowEventMutation) ResetEdge(name string) error {
	switch name {
	case businessfollowevent.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case businessfollowevent.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowEvent edge %s", name)
}

// BusinessFollowUserMutation represents an operation that mutates the BusinessFollowUser nodes in the graph.
type BusinessFollowUserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	_CreatedAt      *time.Time
	_UpdatedAt      *time.Time
	clearedFields   map[string]struct{}
	business        *string
	clearedbusiness bool
	user            *string
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*BusinessFollowUser, error)
	predicates      []predicate.BusinessFollowUser
}

var _ ent.Mutation = (*BusinessFollowUserMutation)(nil)

// businessfollowuserOption allows management of the mutation configuration using functional options.
type businessfollowuserOption func(*BusinessFollowUserMutation)

// newBusinessFollowUserMutation creates new mutation for the BusinessFollowUser entity.
func newBusinessFollowUserMutation(c config, op Op, opts ...businessfollowuserOption) *BusinessFollowUserMutation {
	m := &BusinessFollowUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessFollowUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessFollowUserID sets the ID field of the mutation.
func withBusinessFollowUserID(id string) businessfollowuserOption {
	return func(m *BusinessFollowUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessFollowUser
		)
		m.oldValue = func(ctx context.Context) (*BusinessFollowUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessFollowUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessFollowUser sets the old BusinessFollowUser of the mutation.
func withBusinessFollowUser(node *BusinessFollowUser) businessfollowuserOption {
	return func(m *BusinessFollowUserMutation) {
		m.oldValue = func(context.Context) (*BusinessFollowUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessFollowUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessFollowUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BusinessFollowUser entities.
func (m *BusinessFollowUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessFollowUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessFollowUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessFollowUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *BusinessFollowUserMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *BusinessFollowUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the BusinessFollowUser entity.
// If the BusinessFollowUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessFollowUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *BusinessFollowUserMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *BusinessFollowUserMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *BusinessFollowUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the BusinessFollowUser entity.
// If the BusinessFollowUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessFollowUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *BusinessFollowUserMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *BusinessFollowUserMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *BusinessFollowUserMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *BusinessFollowUserMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *BusinessFollowUserMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowUserMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *BusinessFollowUserMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BusinessFollowUserMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BusinessFollowUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BusinessFollowUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BusinessFollowUserMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowUserMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BusinessFollowUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BusinessFollowUserMutation builder.
func (m *BusinessFollowUserMutation) Where(ps ...predicate.BusinessFollowUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessFollowUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessFollowUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessFollowUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessFollowUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessFollowUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessFollowUser).
func (m *BusinessFollowUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessFollowUserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreatedAt != nil {
		fields = append(fields, businessfollowuser.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, businessfollowuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessFollowUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case businessfollowuser.FieldCreatedAt:
		return m.CreatedAt()
	case businessfollowuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessFollowUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case businessfollowuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case businessfollowuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BusinessFollowUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case businessfollowuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case businessfollowuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessFollowUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessFollowUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessFollowUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessFollowUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessFollowUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessFollowUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BusinessFollowUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessFollowUserMutation) ResetField(name string) error {
	switch name {
	case businessfollowuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case businessfollowuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessFollowUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business != nil {
		edges = append(edges, businessfollowuser.EdgeBusiness)
	}
	if m.user != nil {
		edges = append(edges, businessfollowuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessFollowUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessfollowuser.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case businessfollowuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessFollowUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessFollowUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessFollowUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness {
		edges = append(edges, businessfollowuser.EdgeBusiness)
	}
	if m.cleareduser {
		edges = append(edges, businessfollowuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessFollowUserMutation) EdgeCleared(name string) bool {
	switch name {
	case businessfollowuser.EdgeBusiness:
		return m.clearedbusiness
	case businessfollowuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessFollowUserMutation) ClearEdge(name string) error {
	switch name {
	case businessfollowuser.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case businessfollowuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessFollowUserMutation) ResetEdge(name string) error {
	switch name {
	case businessfollowuser.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case businessfollowuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowUser edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	name                       *string
	image                      *string
	description                *string
	icon                       *string
	_type                      *string
	parent_id                  *string
	parent_name                *string
	parent_image               *string
	parent_description         *string
	clearedFields              map[string]struct{}
	categoryAssignments        map[string]struct{}
	removedcategoryAssignments map[string]struct{}
	clearedcategoryAssignments bool
	place_inventories          map[string]struct{}
	removedplace_inventories   map[string]struct{}
	clearedplace_inventories   bool
	media                      map[string]struct{}
	removedmedia               map[string]struct{}
	clearedmedia               bool
	menus                      map[string]struct{}
	removedmenus               map[string]struct{}
	clearedmenus               bool
	done                       bool
	oldValue                   func(context.Context) (*Category, error)
	predicates                 []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id string) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *CategoryMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CategoryMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *CategoryMutation) ClearImage() {
	m.image = nil
	m.clearedFields[category.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *CategoryMutation) ImageCleared() bool {
	_, ok := m.clearedFields[category.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *CategoryMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, category.FieldImage)
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *CategoryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CategoryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CategoryMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[category.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CategoryMutation) IconCleared() bool {
	_, ok := m.clearedFields[category.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CategoryMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, category.FieldIcon)
}

// SetType sets the "type" field.
func (m *CategoryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CategoryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *CategoryMutation) ClearType() {
	m._type = nil
	m.clearedFields[category.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CategoryMutation) TypeCleared() bool {
	_, ok := m.clearedFields[category.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CategoryMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, category.FieldType)
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(s string) {
	m.parent_id = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r string, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent_id = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent_id = nil
	delete(m.clearedFields, category.FieldParentID)
}

// SetParentName sets the "parent_name" field.
func (m *CategoryMutation) SetParentName(s string) {
	m.parent_name = &s
}

// ParentName returns the value of the "parent_name" field in the mutation.
func (m *CategoryMutation) ParentName() (r string, exists bool) {
	v := m.parent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldParentName returns the old "parent_name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentName: %w", err)
	}
	return oldValue.ParentName, nil
}

// ClearParentName clears the value of the "parent_name" field.
func (m *CategoryMutation) ClearParentName() {
	m.parent_name = nil
	m.clearedFields[category.FieldParentName] = struct{}{}
}

// ParentNameCleared returns if the "parent_name" field was cleared in this mutation.
func (m *CategoryMutation) ParentNameCleared() bool {
	_, ok := m.clearedFields[category.FieldParentName]
	return ok
}

// ResetParentName resets all changes to the "parent_name" field.
func (m *CategoryMutation) ResetParentName() {
	m.parent_name = nil
	delete(m.clearedFields, category.FieldParentName)
}

// SetParentImage sets the "parent_image" field.
func (m *CategoryMutation) SetParentImage(s string) {
	m.parent_image = &s
}

// ParentImage returns the value of the "parent_image" field in the mutation.
func (m *CategoryMutation) ParentImage() (r string, exists bool) {
	v := m.parent_image
	if v == nil {
		return
	}
	return *v, true
}

// OldParentImage returns the old "parent_image" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentImage: %w", err)
	}
	return oldValue.ParentImage, nil
}

// ClearParentImage clears the value of the "parent_image" field.
func (m *CategoryMutation) ClearParentImage() {
	m.parent_image = nil
	m.clearedFields[category.FieldParentImage] = struct{}{}
}

// ParentImageCleared returns if the "parent_image" field was cleared in this mutation.
func (m *CategoryMutation) ParentImageCleared() bool {
	_, ok := m.clearedFields[category.FieldParentImage]
	return ok
}

// ResetParentImage resets all changes to the "parent_image" field.
func (m *CategoryMutation) ResetParentImage() {
	m.parent_image = nil
	delete(m.clearedFields, category.FieldParentImage)
}

// SetParentDescription sets the "parent_description" field.
func (m *CategoryMutation) SetParentDescription(s string) {
	m.parent_description = &s
}

// ParentDescription returns the value of the "parent_description" field in the mutation.
func (m *CategoryMutation) ParentDescription() (r string, exists bool) {
	v := m.parent_description
	if v == nil {
		return
	}
	return *v, true
}

// OldParentDescription returns the old "parent_description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentDescription: %w", err)
	}
	return oldValue.ParentDescription, nil
}

// ClearParentDescription clears the value of the "parent_description" field.
func (m *CategoryMutation) ClearParentDescription() {
	m.parent_description = nil
	m.clearedFields[category.FieldParentDescription] = struct{}{}
}

// ParentDescriptionCleared returns if the "parent_description" field was cleared in this mutation.
func (m *CategoryMutation) ParentDescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldParentDescription]
	return ok
}

// ResetParentDescription resets all changes to the "parent_description" field.
func (m *CategoryMutation) ResetParentDescription() {
	m.parent_description = nil
	delete(m.clearedFields, category.FieldParentDescription)
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *CategoryMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *CategoryMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *CategoryMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *CategoryMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *CategoryMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *CategoryMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *CategoryMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// AddPlaceInventoryIDs adds the "place_inventories" edge to the PlaceInventory entity by ids.
func (m *CategoryMutation) AddPlaceInventoryIDs(ids ...string) {
	if m.place_inventories == nil {
		m.place_inventories = make(map[string]struct{})
	}
	for i := range ids {
		m.place_inventories[ids[i]] = struct{}{}
	}
}

// ClearPlaceInventories clears the "place_inventories" edge to the PlaceInventory entity.
func (m *CategoryMutation) ClearPlaceInventories() {
	m.clearedplace_inventories = true
}

// PlaceInventoriesCleared reports if the "place_inventories" edge to the PlaceInventory entity was cleared.
func (m *CategoryMutation) PlaceInventoriesCleared() bool {
	return m.clearedplace_inventories
}

// RemovePlaceInventoryIDs removes the "place_inventories" edge to the PlaceInventory entity by IDs.
func (m *CategoryMutation) RemovePlaceInventoryIDs(ids ...string) {
	if m.removedplace_inventories == nil {
		m.removedplace_inventories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place_inventories, ids[i])
		m.removedplace_inventories[ids[i]] = struct{}{}
	}
}

// RemovedPlaceInventories returns the removed IDs of the "place_inventories" edge to the PlaceInventory entity.
func (m *CategoryMutation) RemovedPlaceInventoriesIDs() (ids []string) {
	for id := range m.removedplace_inventories {
		ids = append(ids, id)
	}
	return
}

// PlaceInventoriesIDs returns the "place_inventories" edge IDs in the mutation.
func (m *CategoryMutation) PlaceInventoriesIDs() (ids []string) {
	for id := range m.place_inventories {
		ids = append(ids, id)
	}
	return
}

// ResetPlaceInventories resets all changes to the "place_inventories" edge.
func (m *CategoryMutation) ResetPlaceInventories() {
	m.place_inventories = nil
	m.clearedplace_inventories = false
	m.removedplace_inventories = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *CategoryMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *CategoryMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *CategoryMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *CategoryMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *CategoryMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *CategoryMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *CategoryMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *CategoryMutation) AddMenuIDs(ids ...string) {
	if m.menus == nil {
		m.menus = make(map[string]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *CategoryMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *CategoryMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *CategoryMutation) RemoveMenuIDs(ids ...string) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *CategoryMutation) RemovedMenusIDs() (ids []string) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *CategoryMutation) MenusIDs() (ids []string) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *CategoryMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.image != nil {
		fields = append(fields, category.FieldImage)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, category.FieldIcon)
	}
	if m._type != nil {
		fields = append(fields, category.FieldType)
	}
	if m.parent_id != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.parent_name != nil {
		fields = append(fields, category.FieldParentName)
	}
	if m.parent_image != nil {
		fields = append(fields, category.FieldParentImage)
	}
	if m.parent_description != nil {
		fields = append(fields, category.FieldParentDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldImage:
		return m.Image()
	case category.FieldDescription:
		return m.Description()
	case category.FieldIcon:
		return m.Icon()
	case category.FieldType:
		return m.GetType()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldParentName:
		return m.ParentName()
	case category.FieldParentImage:
		return m.ParentImage()
	case category.FieldParentDescription:
		return m.ParentDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldImage:
		return m.OldImage(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldIcon:
		return m.OldIcon(ctx)
	case category.FieldType:
		return m.OldType(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldParentName:
		return m.OldParentName(ctx)
	case category.FieldParentImage:
		return m.OldParentImage(ctx)
	case category.FieldParentDescription:
		return m.OldParentDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case category.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldParentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentName(v)
		return nil
	case category.FieldParentImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentImage(v)
		return nil
	case category.FieldParentDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldImage) {
		fields = append(fields, category.FieldImage)
	}
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	if m.FieldCleared(category.FieldIcon) {
		fields = append(fields, category.FieldIcon)
	}
	if m.FieldCleared(category.FieldType) {
		fields = append(fields, category.FieldType)
	}
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	if m.FieldCleared(category.FieldParentName) {
		fields = append(fields, category.FieldParentName)
	}
	if m.FieldCleared(category.FieldParentImage) {
		fields = append(fields, category.FieldParentImage)
	}
	if m.FieldCleared(category.FieldParentDescription) {
		fields = append(fields, category.FieldParentDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldImage:
		m.ClearImage()
		return nil
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	case category.FieldIcon:
		m.ClearIcon()
		return nil
	case category.FieldType:
		m.ClearType()
		return nil
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	case category.FieldParentName:
		m.ClearParentName()
		return nil
	case category.FieldParentImage:
		m.ClearParentImage()
		return nil
	case category.FieldParentDescription:
		m.ClearParentDescription()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldImage:
		m.ResetImage()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldIcon:
		m.ResetIcon()
		return nil
	case category.FieldType:
		m.ResetType()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldParentName:
		m.ResetParentName()
		return nil
	case category.FieldParentImage:
		m.ResetParentImage()
		return nil
	case category.FieldParentDescription:
		m.ResetParentDescription()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.categoryAssignments != nil {
		edges = append(edges, category.EdgeCategoryAssignments)
	}
	if m.place_inventories != nil {
		edges = append(edges, category.EdgePlaceInventories)
	}
	if m.media != nil {
		edges = append(edges, category.EdgeMedia)
	}
	if m.menus != nil {
		edges = append(edges, category.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case category.EdgePlaceInventories:
		ids := make([]ent.Value, 0, len(m.place_inventories))
		for id := range m.place_inventories {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcategoryAssignments != nil {
		edges = append(edges, category.EdgeCategoryAssignments)
	}
	if m.removedplace_inventories != nil {
		edges = append(edges, category.EdgePlaceInventories)
	}
	if m.removedmedia != nil {
		edges = append(edges, category.EdgeMedia)
	}
	if m.removedmenus != nil {
		edges = append(edges, category.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case category.EdgePlaceInventories:
		ids := make([]ent.Value, 0, len(m.removedplace_inventories))
		for id := range m.removedplace_inventories {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcategoryAssignments {
		edges = append(edges, category.EdgeCategoryAssignments)
	}
	if m.clearedplace_inventories {
		edges = append(edges, category.EdgePlaceInventories)
	}
	if m.clearedmedia {
		edges = append(edges, category.EdgeMedia)
	}
	if m.clearedmenus {
		edges = append(edges, category.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	case category.EdgePlaceInventories:
		return m.clearedplace_inventories
	case category.EdgeMedia:
		return m.clearedmedia
	case category.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	case category.EdgePlaceInventories:
		m.ResetPlaceInventories()
		return nil
	case category.EdgeMedia:
		m.ResetMedia()
		return nil
	case category.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CategoryAssignmentMutation represents an operation that mutates the CategoryAssignment nodes in the graph.
type CategoryAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *string
	entity_type     *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	place           *string
	clearedplace    bool
	category        *string
	clearedcategory bool
	done            bool
	oldValue        func(context.Context) (*CategoryAssignment, error)
	predicates      []predicate.CategoryAssignment
}

var _ ent.Mutation = (*CategoryAssignmentMutation)(nil)

// categoryassignmentOption allows management of the mutation configuration using functional options.
type categoryassignmentOption func(*CategoryAssignmentMutation)

// newCategoryAssignmentMutation creates new mutation for the CategoryAssignment entity.
func newCategoryAssignmentMutation(c config, op Op, opts ...categoryassignmentOption) *CategoryAssignmentMutation {
	m := &CategoryAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeCategoryAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryAssignmentID sets the ID field of the mutation.
func withCategoryAssignmentID(id string) categoryassignmentOption {
	return func(m *CategoryAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *CategoryAssignment
		)
		m.oldValue = func(ctx context.Context) (*CategoryAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CategoryAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategoryAssignment sets the old CategoryAssignment of the mutation.
func withCategoryAssignment(node *CategoryAssignment) categoryassignmentOption {
	return func(m *CategoryAssignmentMutation) {
		m.oldValue = func(context.Context) (*CategoryAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryAssignmentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryAssignmentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CategoryAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *CategoryAssignmentMutation) SetEntityID(s string) {
	m.user = &s
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *CategoryAssignmentMutation) EntityID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the CategoryAssignment entity.
// If the CategoryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryAssignmentMutation) OldEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *CategoryAssignmentMutation) ClearEntityID() {
	m.user = nil
	m.clearedFields[categoryassignment.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *CategoryAssignmentMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[categoryassignment.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *CategoryAssignmentMutation) ResetEntityID() {
	m.user = nil
	delete(m.clearedFields, categoryassignment.FieldEntityID)
}

// SetEntityType sets the "entity_type" field.
func (m *CategoryAssignmentMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *CategoryAssignmentMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the CategoryAssignment entity.
// If the CategoryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryAssignmentMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *CategoryAssignmentMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[categoryassignment.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *CategoryAssignmentMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[categoryassignment.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *CategoryAssignmentMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, categoryassignment.FieldEntityType)
}

// SetCategoryID sets the "category_id" field.
func (m *CategoryAssignmentMutation) SetCategoryID(s string) {
	m.category = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *CategoryAssignmentMutation) CategoryID() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the CategoryAssignment entity.
// If the CategoryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryAssignmentMutation) OldCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *CategoryAssignmentMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[categoryassignment.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *CategoryAssignmentMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[categoryassignment.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *CategoryAssignmentMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, categoryassignment.FieldCategoryID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CategoryAssignmentMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CategoryAssignmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[categoryassignment.FieldEntityID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CategoryAssignmentMutation) UserCleared() bool {
	return m.EntityIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CategoryAssignmentMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CategoryAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *CategoryAssignmentMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *CategoryAssignmentMutation) ClearBusiness() {
	m.clearedbusiness = true
	m.clearedFields[categoryassignment.FieldEntityID] = struct{}{}
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *CategoryAssignmentMutation) BusinessCleared() bool {
	return m.EntityIDCleared() || m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *CategoryAssignmentMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *CategoryAssignmentMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *CategoryAssignmentMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *CategoryAssignmentMutation) ClearPlace() {
	m.clearedplace = true
	m.clearedFields[categoryassignment.FieldEntityID] = struct{}{}
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *CategoryAssignmentMutation) PlaceCleared() bool {
	return m.EntityIDCleared() || m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *CategoryAssignmentMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *CategoryAssignmentMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *CategoryAssignmentMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[categoryassignment.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *CategoryAssignmentMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) CategoryIDs() (ids []string) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *CategoryAssignmentMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the CategoryAssignmentMutation builder.
func (m *CategoryAssignmentMutation) Where(ps ...predicate.CategoryAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CategoryAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CategoryAssignment).
func (m *CategoryAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, categoryassignment.FieldEntityID)
	}
	if m.entity_type != nil {
		fields = append(fields, categoryassignment.FieldEntityType)
	}
	if m.category != nil {
		fields = append(fields, categoryassignment.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case categoryassignment.FieldEntityID:
		return m.EntityID()
	case categoryassignment.FieldEntityType:
		return m.EntityType()
	case categoryassignment.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case categoryassignment.FieldEntityID:
		return m.OldEntityID(ctx)
	case categoryassignment.FieldEntityType:
		return m.OldEntityType(ctx)
	case categoryassignment.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown CategoryAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case categoryassignment.FieldEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case categoryassignment.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case categoryassignment.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CategoryAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(categoryassignment.FieldEntityID) {
		fields = append(fields, categoryassignment.FieldEntityID)
	}
	if m.FieldCleared(categoryassignment.FieldEntityType) {
		fields = append(fields, categoryassignment.FieldEntityType)
	}
	if m.FieldCleared(categoryassignment.FieldCategoryID) {
		fields = append(fields, categoryassignment.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryAssignmentMutation) ClearField(name string) error {
	switch name {
	case categoryassignment.FieldEntityID:
		m.ClearEntityID()
		return nil
	case categoryassignment.FieldEntityType:
		m.ClearEntityType()
		return nil
	case categoryassignment.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryAssignmentMutation) ResetField(name string) error {
	switch name {
	case categoryassignment.FieldEntityID:
		m.ResetEntityID()
		return nil
	case categoryassignment.FieldEntityType:
		m.ResetEntityType()
		return nil
	case categoryassignment.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, categoryassignment.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, categoryassignment.EdgeBusiness)
	}
	if m.place != nil {
		edges = append(edges, categoryassignment.EdgePlace)
	}
	if m.category != nil {
		edges = append(edges, categoryassignment.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case categoryassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case categoryassignment.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case categoryassignment.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case categoryassignment.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, categoryassignment.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, categoryassignment.EdgeBusiness)
	}
	if m.clearedplace {
		edges = append(edges, categoryassignment.EdgePlace)
	}
	if m.clearedcategory {
		edges = append(edges, categoryassignment.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case categoryassignment.EdgeUser:
		return m.cleareduser
	case categoryassignment.EdgeBusiness:
		return m.clearedbusiness
	case categoryassignment.EdgePlace:
		return m.clearedplace
	case categoryassignment.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case categoryassignment.EdgeUser:
		m.ClearUser()
		return nil
	case categoryassignment.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case categoryassignment.EdgePlace:
		m.ClearPlace()
		return nil
	case categoryassignment.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case categoryassignment.EdgeUser:
		m.ResetUser()
		return nil
	case categoryassignment.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case categoryassignment.EdgePlace:
		m.ResetPlace()
		return nil
	case categoryassignment.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Chat, error)
	predicates    []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id string) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Chat edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	_Content             *string
	_CreatedAt           *time.Time
	_UpdatedAt           *time.Time
	clearedFields        map[string]struct{}
	user                 *string
	cleareduser          bool
	post                 *string
	clearedpost          bool
	parentComment        *string
	clearedparentComment bool
	replies              map[string]struct{}
	removedreplies       map[string]struct{}
	clearedreplies       bool
	notifications        map[string]struct{}
	removednotifications map[string]struct{}
	clearednotifications bool
	done                 bool
	oldValue             func(context.Context) (*Comment, error)
	predicates           []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id string) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "Content" field.
func (m *CommentMutation) SetContent(s string) {
	m._Content = &s
}

// Content returns the value of the "Content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m._Content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "Content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "Content" field.
func (m *CommentMutation) ResetContent() {
	m._Content = nil
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *CommentMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetParentCommentID sets the "parentCommentID" field.
func (m *CommentMutation) SetParentCommentID(s string) {
	m.parentComment = &s
}

// ParentCommentID returns the value of the "parentCommentID" field in the mutation.
func (m *CommentMutation) ParentCommentID() (r string, exists bool) {
	v := m.parentComment
	if v == nil {
		return
	}
	return *v, true
}

// OldParentCommentID returns the old "parentCommentID" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentCommentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentCommentID: %w", err)
	}
	return oldValue.ParentCommentID, nil
}

// ClearParentCommentID clears the value of the "parentCommentID" field.
func (m *CommentMutation) ClearParentCommentID() {
	m.parentComment = nil
	m.clearedFields[comment.FieldParentCommentID] = struct{}{}
}

// ParentCommentIDCleared returns if the "parentCommentID" field was cleared in this mutation.
func (m *CommentMutation) ParentCommentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentCommentID]
	return ok
}

// ResetParentCommentID resets all changes to the "parentCommentID" field.
func (m *CommentMutation) ResetParentCommentID() {
	m.parentComment = nil
	delete(m.clearedFields, comment.FieldParentCommentID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CommentMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CommentMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *CommentMutation) SetPostID(id string) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CommentMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CommentMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *CommentMutation) PostID() (id string, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CommentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// ClearParentComment clears the "parentComment" edge to the Comment entity.
func (m *CommentMutation) ClearParentComment() {
	m.clearedparentComment = true
	m.clearedFields[comment.FieldParentCommentID] = struct{}{}
}

// ParentCommentCleared reports if the "parentComment" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCommentCleared() bool {
	return m.ParentCommentIDCleared() || m.clearedparentComment
}

// ParentCommentIDs returns the "parentComment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCommentID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ParentCommentIDs() (ids []string) {
	if id := m.parentComment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentComment resets all changes to the "parentComment" edge.
func (m *CommentMutation) ResetParentComment() {
	m.parentComment = nil
	m.clearedparentComment = false
}

// AddReplyIDs adds the "replies" edge to the Comment entity by ids.
func (m *CommentMutation) AddReplyIDs(ids ...string) {
	if m.replies == nil {
		m.replies = make(map[string]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Comment entity.
func (m *CommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Comment entity was cleared.
func (m *CommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveReplyIDs(ids ...string) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Comment entity.
func (m *CommentMutation) RemovedRepliesIDs() (ids []string) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *CommentMutation) RepliesIDs() (ids []string) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *CommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *CommentMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *CommentMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *CommentMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *CommentMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *CommentMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *CommentMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *CommentMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m._CreatedAt != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.parentComment != nil {
		fields = append(fields, comment.FieldParentCommentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldContent:
		return m.Content()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldParentCommentID:
		return m.ParentCommentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldParentCommentID:
		return m.OldParentCommentID(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldParentCommentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentCommentID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldParentCommentID) {
		fields = append(fields, comment.FieldParentCommentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldParentCommentID:
		m.ClearParentCommentID()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldParentCommentID:
		m.ResetParentCommentID()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, comment.EdgePost)
	}
	if m.parentComment != nil {
		edges = append(edges, comment.EdgeParentComment)
	}
	if m.replies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.notifications != nil {
		edges = append(edges, comment.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParentComment:
		if id := m.parentComment; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedreplies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.removednotifications != nil {
		edges = append(edges, comment.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, comment.EdgePost)
	}
	if m.clearedparentComment {
		edges = append(edges, comment.EdgeParentComment)
	}
	if m.clearedreplies {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.clearednotifications {
		edges = append(edges, comment.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgePost:
		return m.clearedpost
	case comment.EdgeParentComment:
		return m.clearedparentComment
	case comment.EdgeReplies:
		return m.clearedreplies
	case comment.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ClearUser()
		return nil
	case comment.EdgePost:
		m.ClearPost()
		return nil
	case comment.EdgeParentComment:
		m.ClearParentComment()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgePost:
		m.ResetPost()
		return nil
	case comment.EdgeParentComment:
		m.ResetParentComment()
		return nil
	case comment.EdgeReplies:
		m.ResetReplies()
		return nil
	case comment.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CustomBlockMutation represents an operation that mutates the CustomBlock nodes in the graph.
type CustomBlockMutation struct {
	config
	op             Op
	typ            string
	id             *string
	content        *string
	clearedFields  map[string]struct{}
	website        *string
	clearedwebsite bool
	done           bool
	oldValue       func(context.Context) (*CustomBlock, error)
	predicates     []predicate.CustomBlock
}

var _ ent.Mutation = (*CustomBlockMutation)(nil)

// customblockOption allows management of the mutation configuration using functional options.
type customblockOption func(*CustomBlockMutation)

// newCustomBlockMutation creates new mutation for the CustomBlock entity.
func newCustomBlockMutation(c config, op Op, opts ...customblockOption) *CustomBlockMutation {
	m := &CustomBlockMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomBlockID sets the ID field of the mutation.
func withCustomBlockID(id string) customblockOption {
	return func(m *CustomBlockMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomBlock
		)
		m.oldValue = func(ctx context.Context) (*CustomBlock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomBlock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomBlock sets the old CustomBlock of the mutation.
func withCustomBlock(node *CustomBlock) customblockOption {
	return func(m *CustomBlockMutation) {
		m.oldValue = func(context.Context) (*CustomBlock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomBlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomBlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomBlockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomBlockMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomBlock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *CustomBlockMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CustomBlockMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the CustomBlock entity.
// If the CustomBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomBlockMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CustomBlockMutation) ResetContent() {
	m.content = nil
}

// SetWebsiteID sets the "website" edge to the Website entity by id.
func (m *CustomBlockMutation) SetWebsiteID(id string) {
	m.website = &id
}

// ClearWebsite clears the "website" edge to the Website entity.
func (m *CustomBlockMutation) ClearWebsite() {
	m.clearedwebsite = true
}

// WebsiteCleared reports if the "website" edge to the Website entity was cleared.
func (m *CustomBlockMutation) WebsiteCleared() bool {
	return m.clearedwebsite
}

// WebsiteID returns the "website" edge ID in the mutation.
func (m *CustomBlockMutation) WebsiteID() (id string, exists bool) {
	if m.website != nil {
		return *m.website, true
	}
	return
}

// WebsiteIDs returns the "website" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WebsiteID instead. It exists only for internal usage by the builders.
func (m *CustomBlockMutation) WebsiteIDs() (ids []string) {
	if id := m.website; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWebsite resets all changes to the "website" edge.
func (m *CustomBlockMutation) ResetWebsite() {
	m.website = nil
	m.clearedwebsite = false
}

// Where appends a list predicates to the CustomBlockMutation builder.
func (m *CustomBlockMutation) Where(ps ...predicate.CustomBlock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomBlockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomBlockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomBlock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomBlockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomBlockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomBlock).
func (m *CustomBlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomBlockMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.content != nil {
		fields = append(fields, customblock.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomBlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customblock.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomBlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customblock.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown CustomBlock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomBlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customblock.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown CustomBlock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomBlockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomBlockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomBlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomBlock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomBlockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomBlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomBlockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CustomBlock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomBlockMutation) ResetField(name string) error {
	switch name {
	case customblock.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown CustomBlock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomBlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.website != nil {
		edges = append(edges, customblock.EdgeWebsite)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomBlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customblock.EdgeWebsite:
		if id := m.website; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomBlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomBlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomBlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwebsite {
		edges = append(edges, customblock.EdgeWebsite)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomBlockMutation) EdgeCleared(name string) bool {
	switch name {
	case customblock.EdgeWebsite:
		return m.clearedwebsite
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomBlockMutation) ClearEdge(name string) error {
	switch name {
	case customblock.EdgeWebsite:
		m.ClearWebsite()
		return nil
	}
	return fmt.Errorf("unknown CustomBlock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomBlockMutation) ResetEdge(name string) error {
	switch name {
	case customblock.EdgeWebsite:
		m.ResetWebsite()
		return nil
	}
	return fmt.Errorf("unknown CustomBlock edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                                Op
	typ                               string
	id                                *string
	name                              *string
	_EventType                        *event.EventType
	status                            *string
	location                          *string
	url                               *string
	title                             *string
	time_zone                         *string
	start_time                        *time.Time
	end_time                          *time.Time
	start_date                        *string
	end_date                          *string
	frequency                         *event.Frequency
	frequency_interval                *string
	frequency_day_of_week             *string
	frequency_day_of_month            *string
	frequency_month_of_year           *string
	venue_type                        *event.VenueType
	venue_name                        *string
	venue_address                     *string
	venue_city                        *string
	venue_state                       *string
	venue_country                     *string
	venue_zip                         *string
	venue_lat                         *string
	venue_lon                         *string
	venue_url                         *string
	venue_phone                       *string
	venue_email                       *string
	tags                              *[]string
	appendtags                        []string
	description                       *string
	event_settings                    *map[string]interface{}
	cover_image                       *string
	createdAt                         *time.Time
	updatedAt                         *time.Time
	map_coordinates                   *map[string]interface{}
	longitude                         *string
	latitude                          *string
	search_text                       *string
	relevance_score                   *float64
	addrelevance_score                *float64
	follower_count                    *int
	addfollower_count                 *int
	following_count                   *int
	addfollowing_count                *int
	is_Premium                        *bool
	is_published                      *bool
	is_Online                         *bool
	is_Free                           *bool
	is_Paid                           *bool
	is_public                         *bool
	is_Online_Only                    *bool
	is_In_Person_Only                 *bool
	is_Hybrid                         *bool
	is_Online_And_In_Person           *bool
	is_Online_And_In_Person_Only      *bool
	is_Online_And_In_Person_Or_Hybrid *bool
	likedByCurrentUser                *bool
	followedByCurrentUser             *bool
	registration_type                 *event.RegistrationType
	registration_url                  *string
	is_physically_accessible          *bool
	accessibility_info                *string
	is_virtually_accessible           *bool
	clearedFields                     map[string]struct{}
	tickets                           map[string]struct{}
	removedtickets                    map[string]struct{}
	clearedtickets                    bool
	ticket_options                    map[string]struct{}
	removedticket_options             map[string]struct{}
	clearedticket_options             bool
	place                             map[string]struct{}
	removedplace                      map[string]struct{}
	clearedplace                      bool
	event_categories                  map[string]struct{}
	removedevent_categories           map[string]struct{}
	clearedevent_categories           bool
	event_category_assignments        map[string]struct{}
	removedevent_category_assignments map[string]struct{}
	clearedevent_category_assignments bool
	ownerUser                         *string
	clearedownerUser                  bool
	ownerBusiness                     *string
	clearedownerBusiness              bool
	userFollowers                     map[string]struct{}
	removeduserFollowers              map[string]struct{}
	cleareduserFollowers              bool
	businessFollowers                 map[string]struct{}
	removedbusinessFollowers          map[string]struct{}
	clearedbusinessFollowers          bool
	faqs                              map[string]struct{}
	removedfaqs                       map[string]struct{}
	clearedfaqs                       bool
	ratings                           map[string]struct{}
	removedratings                    map[string]struct{}
	clearedratings                    bool
	additional_organizers             map[string]struct{}
	removedadditional_organizers      map[string]struct{}
	clearedadditional_organizers      bool
	media                             map[string]struct{}
	removedmedia                      map[string]struct{}
	clearedmedia                      bool
	event_comments                    map[string]struct{}
	removedevent_comments             map[string]struct{}
	clearedevent_comments             bool
	event_reviews                     map[string]struct{}
	removedevent_reviews              map[string]struct{}
	clearedevent_reviews              bool
	performers                        map[string]struct{}
	removedperformers                 map[string]struct{}
	clearedperformers                 bool
	event_organizers                  map[string]struct{}
	removedevent_organizers           map[string]struct{}
	clearedevent_organizers           bool
	done                              bool
	oldValue                          func(context.Context) (*Event, error)
	predicates                        []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id string) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EventMutation) ClearName() {
	m.name = nil
	m.clearedFields[event.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EventMutation) NameCleared() bool {
	_, ok := m.clearedFields[event.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, event.FieldName)
}

// SetEventType sets the "EventType" field.
func (m *EventMutation) SetEventType(et event.EventType) {
	m._EventType = &et
}

// EventType returns the value of the "EventType" field in the mutation.
func (m *EventMutation) EventType() (r event.EventType, exists bool) {
	v := m._EventType
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "EventType" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v event.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ClearEventType clears the value of the "EventType" field.
func (m *EventMutation) ClearEventType() {
	m._EventType = nil
	m.clearedFields[event.FieldEventType] = struct{}{}
}

// EventTypeCleared returns if the "EventType" field was cleared in this mutation.
func (m *EventMutation) EventTypeCleared() bool {
	_, ok := m.clearedFields[event.FieldEventType]
	return ok
}

// ResetEventType resets all changes to the "EventType" field.
func (m *EventMutation) ResetEventType() {
	m._EventType = nil
	delete(m.clearedFields, event.FieldEventType)
}

// SetStatus sets the "status" field.
func (m *EventMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EventMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EventMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[event.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EventMutation) StatusCleared() bool {
	_, ok := m.clearedFields[event.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EventMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, event.FieldStatus)
}

// SetLocation sets the "location" field.
func (m *EventMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *EventMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *EventMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[event.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *EventMutation) LocationCleared() bool {
	_, ok := m.clearedFields[event.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *EventMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, event.FieldLocation)
}

// SetURL sets the "url" field.
func (m *EventMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EventMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *EventMutation) ClearURL() {
	m.url = nil
	m.clearedFields[event.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *EventMutation) URLCleared() bool {
	_, ok := m.clearedFields[event.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *EventMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, event.FieldURL)
}

// SetTitle sets the "title" field.
func (m *EventMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EventMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *EventMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[event.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *EventMutation) TitleCleared() bool {
	_, ok := m.clearedFields[event.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *EventMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, event.FieldTitle)
}

// SetTimeZone sets the "time_zone" field.
func (m *EventMutation) SetTimeZone(s string) {
	m.time_zone = &s
}

// TimeZone returns the value of the "time_zone" field in the mutation.
func (m *EventMutation) TimeZone() (r string, exists bool) {
	v := m.time_zone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeZone returns the old "time_zone" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTimeZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeZone: %w", err)
	}
	return oldValue.TimeZone, nil
}

// ClearTimeZone clears the value of the "time_zone" field.
func (m *EventMutation) ClearTimeZone() {
	m.time_zone = nil
	m.clearedFields[event.FieldTimeZone] = struct{}{}
}

// TimeZoneCleared returns if the "time_zone" field was cleared in this mutation.
func (m *EventMutation) TimeZoneCleared() bool {
	_, ok := m.clearedFields[event.FieldTimeZone]
	return ok
}

// ResetTimeZone resets all changes to the "time_zone" field.
func (m *EventMutation) ResetTimeZone() {
	m.time_zone = nil
	delete(m.clearedFields, event.FieldTimeZone)
}

// SetStartTime sets the "start_time" field.
func (m *EventMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *EventMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *EventMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[event.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *EventMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *EventMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, event.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *EventMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *EventMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *EventMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[event.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *EventMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *EventMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, event.FieldEndTime)
}

// SetStartDate sets the "start_date" field.
func (m *EventMutation) SetStartDate(s string) {
	m.start_date = &s
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EventMutation) StartDate() (r string, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *EventMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[event.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *EventMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[event.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EventMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, event.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *EventMutation) SetEndDate(s string) {
	m.end_date = &s
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EventMutation) EndDate() (r string, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *EventMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[event.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *EventMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[event.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EventMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, event.FieldEndDate)
}

// SetFrequency sets the "frequency" field.
func (m *EventMutation) SetFrequency(e event.Frequency) {
	m.frequency = &e
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *EventMutation) Frequency() (r event.Frequency, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFrequency(ctx context.Context) (v event.Frequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// ClearFrequency clears the value of the "frequency" field.
func (m *EventMutation) ClearFrequency() {
	m.frequency = nil
	m.clearedFields[event.FieldFrequency] = struct{}{}
}

// FrequencyCleared returns if the "frequency" field was cleared in this mutation.
func (m *EventMutation) FrequencyCleared() bool {
	_, ok := m.clearedFields[event.FieldFrequency]
	return ok
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *EventMutation) ResetFrequency() {
	m.frequency = nil
	delete(m.clearedFields, event.FieldFrequency)
}

// SetFrequencyInterval sets the "frequency_interval" field.
func (m *EventMutation) SetFrequencyInterval(s string) {
	m.frequency_interval = &s
}

// FrequencyInterval returns the value of the "frequency_interval" field in the mutation.
func (m *EventMutation) FrequencyInterval() (r string, exists bool) {
	v := m.frequency_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequencyInterval returns the old "frequency_interval" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFrequencyInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequencyInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequencyInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequencyInterval: %w", err)
	}
	return oldValue.FrequencyInterval, nil
}

// ClearFrequencyInterval clears the value of the "frequency_interval" field.
func (m *EventMutation) ClearFrequencyInterval() {
	m.frequency_interval = nil
	m.clearedFields[event.FieldFrequencyInterval] = struct{}{}
}

// FrequencyIntervalCleared returns if the "frequency_interval" field was cleared in this mutation.
func (m *EventMutation) FrequencyIntervalCleared() bool {
	_, ok := m.clearedFields[event.FieldFrequencyInterval]
	return ok
}

// ResetFrequencyInterval resets all changes to the "frequency_interval" field.
func (m *EventMutation) ResetFrequencyInterval() {
	m.frequency_interval = nil
	delete(m.clearedFields, event.FieldFrequencyInterval)
}

// SetFrequencyDayOfWeek sets the "frequency_day_of_week" field.
func (m *EventMutation) SetFrequencyDayOfWeek(s string) {
	m.frequency_day_of_week = &s
}

// FrequencyDayOfWeek returns the value of the "frequency_day_of_week" field in the mutation.
func (m *EventMutation) FrequencyDayOfWeek() (r string, exists bool) {
	v := m.frequency_day_of_week
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequencyDayOfWeek returns the old "frequency_day_of_week" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFrequencyDayOfWeek(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequencyDayOfWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequencyDayOfWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequencyDayOfWeek: %w", err)
	}
	return oldValue.FrequencyDayOfWeek, nil
}

// ClearFrequencyDayOfWeek clears the value of the "frequency_day_of_week" field.
func (m *EventMutation) ClearFrequencyDayOfWeek() {
	m.frequency_day_of_week = nil
	m.clearedFields[event.FieldFrequencyDayOfWeek] = struct{}{}
}

// FrequencyDayOfWeekCleared returns if the "frequency_day_of_week" field was cleared in this mutation.
func (m *EventMutation) FrequencyDayOfWeekCleared() bool {
	_, ok := m.clearedFields[event.FieldFrequencyDayOfWeek]
	return ok
}

// ResetFrequencyDayOfWeek resets all changes to the "frequency_day_of_week" field.
func (m *EventMutation) ResetFrequencyDayOfWeek() {
	m.frequency_day_of_week = nil
	delete(m.clearedFields, event.FieldFrequencyDayOfWeek)
}

// SetFrequencyDayOfMonth sets the "frequency_day_of_month" field.
func (m *EventMutation) SetFrequencyDayOfMonth(s string) {
	m.frequency_day_of_month = &s
}

// FrequencyDayOfMonth returns the value of the "frequency_day_of_month" field in the mutation.
func (m *EventMutation) FrequencyDayOfMonth() (r string, exists bool) {
	v := m.frequency_day_of_month
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequencyDayOfMonth returns the old "frequency_day_of_month" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFrequencyDayOfMonth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequencyDayOfMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequencyDayOfMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequencyDayOfMonth: %w", err)
	}
	return oldValue.FrequencyDayOfMonth, nil
}

// ClearFrequencyDayOfMonth clears the value of the "frequency_day_of_month" field.
func (m *EventMutation) ClearFrequencyDayOfMonth() {
	m.frequency_day_of_month = nil
	m.clearedFields[event.FieldFrequencyDayOfMonth] = struct{}{}
}

// FrequencyDayOfMonthCleared returns if the "frequency_day_of_month" field was cleared in this mutation.
func (m *EventMutation) FrequencyDayOfMonthCleared() bool {
	_, ok := m.clearedFields[event.FieldFrequencyDayOfMonth]
	return ok
}

// ResetFrequencyDayOfMonth resets all changes to the "frequency_day_of_month" field.
func (m *EventMutation) ResetFrequencyDayOfMonth() {
	m.frequency_day_of_month = nil
	delete(m.clearedFields, event.FieldFrequencyDayOfMonth)
}

// SetFrequencyMonthOfYear sets the "frequency_month_of_year" field.
func (m *EventMutation) SetFrequencyMonthOfYear(s string) {
	m.frequency_month_of_year = &s
}

// FrequencyMonthOfYear returns the value of the "frequency_month_of_year" field in the mutation.
func (m *EventMutation) FrequencyMonthOfYear() (r string, exists bool) {
	v := m.frequency_month_of_year
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequencyMonthOfYear returns the old "frequency_month_of_year" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFrequencyMonthOfYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequencyMonthOfYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequencyMonthOfYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequencyMonthOfYear: %w", err)
	}
	return oldValue.FrequencyMonthOfYear, nil
}

// ClearFrequencyMonthOfYear clears the value of the "frequency_month_of_year" field.
func (m *EventMutation) ClearFrequencyMonthOfYear() {
	m.frequency_month_of_year = nil
	m.clearedFields[event.FieldFrequencyMonthOfYear] = struct{}{}
}

// FrequencyMonthOfYearCleared returns if the "frequency_month_of_year" field was cleared in this mutation.
func (m *EventMutation) FrequencyMonthOfYearCleared() bool {
	_, ok := m.clearedFields[event.FieldFrequencyMonthOfYear]
	return ok
}

// ResetFrequencyMonthOfYear resets all changes to the "frequency_month_of_year" field.
func (m *EventMutation) ResetFrequencyMonthOfYear() {
	m.frequency_month_of_year = nil
	delete(m.clearedFields, event.FieldFrequencyMonthOfYear)
}

// SetVenueType sets the "venue_type" field.
func (m *EventMutation) SetVenueType(et event.VenueType) {
	m.venue_type = &et
}

// VenueType returns the value of the "venue_type" field in the mutation.
func (m *EventMutation) VenueType() (r event.VenueType, exists bool) {
	v := m.venue_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueType returns the old "venue_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueType(ctx context.Context) (v event.VenueType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueType: %w", err)
	}
	return oldValue.VenueType, nil
}

// ClearVenueType clears the value of the "venue_type" field.
func (m *EventMutation) ClearVenueType() {
	m.venue_type = nil
	m.clearedFields[event.FieldVenueType] = struct{}{}
}

// VenueTypeCleared returns if the "venue_type" field was cleared in this mutation.
func (m *EventMutation) VenueTypeCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueType]
	return ok
}

// ResetVenueType resets all changes to the "venue_type" field.
func (m *EventMutation) ResetVenueType() {
	m.venue_type = nil
	delete(m.clearedFields, event.FieldVenueType)
}

// SetVenueName sets the "venue_name" field.
func (m *EventMutation) SetVenueName(s string) {
	m.venue_name = &s
}

// VenueName returns the value of the "venue_name" field in the mutation.
func (m *EventMutation) VenueName() (r string, exists bool) {
	v := m.venue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueName returns the old "venue_name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueName: %w", err)
	}
	return oldValue.VenueName, nil
}

// ClearVenueName clears the value of the "venue_name" field.
func (m *EventMutation) ClearVenueName() {
	m.venue_name = nil
	m.clearedFields[event.FieldVenueName] = struct{}{}
}

// VenueNameCleared returns if the "venue_name" field was cleared in this mutation.
func (m *EventMutation) VenueNameCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueName]
	return ok
}

// ResetVenueName resets all changes to the "venue_name" field.
func (m *EventMutation) ResetVenueName() {
	m.venue_name = nil
	delete(m.clearedFields, event.FieldVenueName)
}

// SetVenueAddress sets the "venue_address" field.
func (m *EventMutation) SetVenueAddress(s string) {
	m.venue_address = &s
}

// VenueAddress returns the value of the "venue_address" field in the mutation.
func (m *EventMutation) VenueAddress() (r string, exists bool) {
	v := m.venue_address
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueAddress returns the old "venue_address" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueAddress: %w", err)
	}
	return oldValue.VenueAddress, nil
}

// ClearVenueAddress clears the value of the "venue_address" field.
func (m *EventMutation) ClearVenueAddress() {
	m.venue_address = nil
	m.clearedFields[event.FieldVenueAddress] = struct{}{}
}

// VenueAddressCleared returns if the "venue_address" field was cleared in this mutation.
func (m *EventMutation) VenueAddressCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueAddress]
	return ok
}

// ResetVenueAddress resets all changes to the "venue_address" field.
func (m *EventMutation) ResetVenueAddress() {
	m.venue_address = nil
	delete(m.clearedFields, event.FieldVenueAddress)
}

// SetVenueCity sets the "venue_city" field.
func (m *EventMutation) SetVenueCity(s string) {
	m.venue_city = &s
}

// VenueCity returns the value of the "venue_city" field in the mutation.
func (m *EventMutation) VenueCity() (r string, exists bool) {
	v := m.venue_city
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueCity returns the old "venue_city" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueCity: %w", err)
	}
	return oldValue.VenueCity, nil
}

// ClearVenueCity clears the value of the "venue_city" field.
func (m *EventMutation) ClearVenueCity() {
	m.venue_city = nil
	m.clearedFields[event.FieldVenueCity] = struct{}{}
}

// VenueCityCleared returns if the "venue_city" field was cleared in this mutation.
func (m *EventMutation) VenueCityCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueCity]
	return ok
}

// ResetVenueCity resets all changes to the "venue_city" field.
func (m *EventMutation) ResetVenueCity() {
	m.venue_city = nil
	delete(m.clearedFields, event.FieldVenueCity)
}

// SetVenueState sets the "venue_state" field.
func (m *EventMutation) SetVenueState(s string) {
	m.venue_state = &s
}

// VenueState returns the value of the "venue_state" field in the mutation.
func (m *EventMutation) VenueState() (r string, exists bool) {
	v := m.venue_state
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueState returns the old "venue_state" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueState: %w", err)
	}
	return oldValue.VenueState, nil
}

// ClearVenueState clears the value of the "venue_state" field.
func (m *EventMutation) ClearVenueState() {
	m.venue_state = nil
	m.clearedFields[event.FieldVenueState] = struct{}{}
}

// VenueStateCleared returns if the "venue_state" field was cleared in this mutation.
func (m *EventMutation) VenueStateCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueState]
	return ok
}

// ResetVenueState resets all changes to the "venue_state" field.
func (m *EventMutation) ResetVenueState() {
	m.venue_state = nil
	delete(m.clearedFields, event.FieldVenueState)
}

// SetVenueCountry sets the "venue_country" field.
func (m *EventMutation) SetVenueCountry(s string) {
	m.venue_country = &s
}

// VenueCountry returns the value of the "venue_country" field in the mutation.
func (m *EventMutation) VenueCountry() (r string, exists bool) {
	v := m.venue_country
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueCountry returns the old "venue_country" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueCountry: %w", err)
	}
	return oldValue.VenueCountry, nil
}

// ClearVenueCountry clears the value of the "venue_country" field.
func (m *EventMutation) ClearVenueCountry() {
	m.venue_country = nil
	m.clearedFields[event.FieldVenueCountry] = struct{}{}
}

// VenueCountryCleared returns if the "venue_country" field was cleared in this mutation.
func (m *EventMutation) VenueCountryCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueCountry]
	return ok
}

// ResetVenueCountry resets all changes to the "venue_country" field.
func (m *EventMutation) ResetVenueCountry() {
	m.venue_country = nil
	delete(m.clearedFields, event.FieldVenueCountry)
}

// SetVenueZip sets the "venue_zip" field.
func (m *EventMutation) SetVenueZip(s string) {
	m.venue_zip = &s
}

// VenueZip returns the value of the "venue_zip" field in the mutation.
func (m *EventMutation) VenueZip() (r string, exists bool) {
	v := m.venue_zip
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueZip returns the old "venue_zip" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueZip(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueZip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueZip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueZip: %w", err)
	}
	return oldValue.VenueZip, nil
}

// ClearVenueZip clears the value of the "venue_zip" field.
func (m *EventMutation) ClearVenueZip() {
	m.venue_zip = nil
	m.clearedFields[event.FieldVenueZip] = struct{}{}
}

// VenueZipCleared returns if the "venue_zip" field was cleared in this mutation.
func (m *EventMutation) VenueZipCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueZip]
	return ok
}

// ResetVenueZip resets all changes to the "venue_zip" field.
func (m *EventMutation) ResetVenueZip() {
	m.venue_zip = nil
	delete(m.clearedFields, event.FieldVenueZip)
}

// SetVenueLat sets the "venue_lat" field.
func (m *EventMutation) SetVenueLat(s string) {
	m.venue_lat = &s
}

// VenueLat returns the value of the "venue_lat" field in the mutation.
func (m *EventMutation) VenueLat() (r string, exists bool) {
	v := m.venue_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueLat returns the old "venue_lat" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueLat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueLat: %w", err)
	}
	return oldValue.VenueLat, nil
}

// ClearVenueLat clears the value of the "venue_lat" field.
func (m *EventMutation) ClearVenueLat() {
	m.venue_lat = nil
	m.clearedFields[event.FieldVenueLat] = struct{}{}
}

// VenueLatCleared returns if the "venue_lat" field was cleared in this mutation.
func (m *EventMutation) VenueLatCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueLat]
	return ok
}

// ResetVenueLat resets all changes to the "venue_lat" field.
func (m *EventMutation) ResetVenueLat() {
	m.venue_lat = nil
	delete(m.clearedFields, event.FieldVenueLat)
}

// SetVenueLon sets the "venue_lon" field.
func (m *EventMutation) SetVenueLon(s string) {
	m.venue_lon = &s
}

// VenueLon returns the value of the "venue_lon" field in the mutation.
func (m *EventMutation) VenueLon() (r string, exists bool) {
	v := m.venue_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueLon returns the old "venue_lon" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueLon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueLon: %w", err)
	}
	return oldValue.VenueLon, nil
}

// ClearVenueLon clears the value of the "venue_lon" field.
func (m *EventMutation) ClearVenueLon() {
	m.venue_lon = nil
	m.clearedFields[event.FieldVenueLon] = struct{}{}
}

// VenueLonCleared returns if the "venue_lon" field was cleared in this mutation.
func (m *EventMutation) VenueLonCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueLon]
	return ok
}

// ResetVenueLon resets all changes to the "venue_lon" field.
func (m *EventMutation) ResetVenueLon() {
	m.venue_lon = nil
	delete(m.clearedFields, event.FieldVenueLon)
}

// SetVenueURL sets the "venue_url" field.
func (m *EventMutation) SetVenueURL(s string) {
	m.venue_url = &s
}

// VenueURL returns the value of the "venue_url" field in the mutation.
func (m *EventMutation) VenueURL() (r string, exists bool) {
	v := m.venue_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueURL returns the old "venue_url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueURL: %w", err)
	}
	return oldValue.VenueURL, nil
}

// ClearVenueURL clears the value of the "venue_url" field.
func (m *EventMutation) ClearVenueURL() {
	m.venue_url = nil
	m.clearedFields[event.FieldVenueURL] = struct{}{}
}

// VenueURLCleared returns if the "venue_url" field was cleared in this mutation.
func (m *EventMutation) VenueURLCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueURL]
	return ok
}

// ResetVenueURL resets all changes to the "venue_url" field.
func (m *EventMutation) ResetVenueURL() {
	m.venue_url = nil
	delete(m.clearedFields, event.FieldVenueURL)
}

// SetVenuePhone sets the "venue_phone" field.
func (m *EventMutation) SetVenuePhone(s string) {
	m.venue_phone = &s
}

// VenuePhone returns the value of the "venue_phone" field in the mutation.
func (m *EventMutation) VenuePhone() (r string, exists bool) {
	v := m.venue_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldVenuePhone returns the old "venue_phone" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenuePhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenuePhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenuePhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenuePhone: %w", err)
	}
	return oldValue.VenuePhone, nil
}

// ClearVenuePhone clears the value of the "venue_phone" field.
func (m *EventMutation) ClearVenuePhone() {
	m.venue_phone = nil
	m.clearedFields[event.FieldVenuePhone] = struct{}{}
}

// VenuePhoneCleared returns if the "venue_phone" field was cleared in this mutation.
func (m *EventMutation) VenuePhoneCleared() bool {
	_, ok := m.clearedFields[event.FieldVenuePhone]
	return ok
}

// ResetVenuePhone resets all changes to the "venue_phone" field.
func (m *EventMutation) ResetVenuePhone() {
	m.venue_phone = nil
	delete(m.clearedFields, event.FieldVenuePhone)
}

// SetVenueEmail sets the "venue_email" field.
func (m *EventMutation) SetVenueEmail(s string) {
	m.venue_email = &s
}

// VenueEmail returns the value of the "venue_email" field in the mutation.
func (m *EventMutation) VenueEmail() (r string, exists bool) {
	v := m.venue_email
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueEmail returns the old "venue_email" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVenueEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueEmail: %w", err)
	}
	return oldValue.VenueEmail, nil
}

// ClearVenueEmail clears the value of the "venue_email" field.
func (m *EventMutation) ClearVenueEmail() {
	m.venue_email = nil
	m.clearedFields[event.FieldVenueEmail] = struct{}{}
}

// VenueEmailCleared returns if the "venue_email" field was cleared in this mutation.
func (m *EventMutation) VenueEmailCleared() bool {
	_, ok := m.clearedFields[event.FieldVenueEmail]
	return ok
}

// ResetVenueEmail resets all changes to the "venue_email" field.
func (m *EventMutation) ResetVenueEmail() {
	m.venue_email = nil
	delete(m.clearedFields, event.FieldVenueEmail)
}

// SetTags sets the "tags" field.
func (m *EventMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EventMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EventMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EventMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EventMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[event.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EventMutation) TagsCleared() bool {
	_, ok := m.clearedFields[event.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EventMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, event.FieldTags)
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[event.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[event.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, event.FieldDescription)
}

// SetEventSettings sets the "event_settings" field.
func (m *EventMutation) SetEventSettings(value map[string]interface{}) {
	m.event_settings = &value
}

// EventSettings returns the value of the "event_settings" field in the mutation.
func (m *EventMutation) EventSettings() (r map[string]interface{}, exists bool) {
	v := m.event_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldEventSettings returns the old "event_settings" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventSettings: %w", err)
	}
	return oldValue.EventSettings, nil
}

// ClearEventSettings clears the value of the "event_settings" field.
func (m *EventMutation) ClearEventSettings() {
	m.event_settings = nil
	m.clearedFields[event.FieldEventSettings] = struct{}{}
}

// EventSettingsCleared returns if the "event_settings" field was cleared in this mutation.
func (m *EventMutation) EventSettingsCleared() bool {
	_, ok := m.clearedFields[event.FieldEventSettings]
	return ok
}

// ResetEventSettings resets all changes to the "event_settings" field.
func (m *EventMutation) ResetEventSettings() {
	m.event_settings = nil
	delete(m.clearedFields, event.FieldEventSettings)
}

// SetCoverImage sets the "cover_image" field.
func (m *EventMutation) SetCoverImage(s string) {
	m.cover_image = &s
}

// CoverImage returns the value of the "cover_image" field in the mutation.
func (m *EventMutation) CoverImage() (r string, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "cover_image" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ClearCoverImage clears the value of the "cover_image" field.
func (m *EventMutation) ClearCoverImage() {
	m.cover_image = nil
	m.clearedFields[event.FieldCoverImage] = struct{}{}
}

// CoverImageCleared returns if the "cover_image" field was cleared in this mutation.
func (m *EventMutation) CoverImageCleared() bool {
	_, ok := m.clearedFields[event.FieldCoverImage]
	return ok
}

// ResetCoverImage resets all changes to the "cover_image" field.
func (m *EventMutation) ResetCoverImage() {
	m.cover_image = nil
	delete(m.clearedFields, event.FieldCoverImage)
}

// SetCreatedAt sets the "createdAt" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *EventMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetMapCoordinates sets the "map_coordinates" field.
func (m *EventMutation) SetMapCoordinates(value map[string]interface{}) {
	m.map_coordinates = &value
}

// MapCoordinates returns the value of the "map_coordinates" field in the mutation.
func (m *EventMutation) MapCoordinates() (r map[string]interface{}, exists bool) {
	v := m.map_coordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldMapCoordinates returns the old "map_coordinates" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMapCoordinates(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapCoordinates: %w", err)
	}
	return oldValue.MapCoordinates, nil
}

// ClearMapCoordinates clears the value of the "map_coordinates" field.
func (m *EventMutation) ClearMapCoordinates() {
	m.map_coordinates = nil
	m.clearedFields[event.FieldMapCoordinates] = struct{}{}
}

// MapCoordinatesCleared returns if the "map_coordinates" field was cleared in this mutation.
func (m *EventMutation) MapCoordinatesCleared() bool {
	_, ok := m.clearedFields[event.FieldMapCoordinates]
	return ok
}

// ResetMapCoordinates resets all changes to the "map_coordinates" field.
func (m *EventMutation) ResetMapCoordinates() {
	m.map_coordinates = nil
	delete(m.clearedFields, event.FieldMapCoordinates)
}

// SetLongitude sets the "longitude" field.
func (m *EventMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *EventMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *EventMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[event.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *EventMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[event.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *EventMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, event.FieldLongitude)
}

// SetLatitude sets the "latitude" field.
func (m *EventMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *EventMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *EventMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[event.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *EventMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[event.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *EventMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, event.FieldLatitude)
}

// SetSearchText sets the "search_text" field.
func (m *EventMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *EventMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *EventMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[event.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *EventMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[event.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *EventMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, event.FieldSearchText)
}

// SetRelevanceScore sets the "relevance_score" field.
func (m *EventMutation) SetRelevanceScore(f float64) {
	m.relevance_score = &f
	m.addrelevance_score = nil
}

// RelevanceScore returns the value of the "relevance_score" field in the mutation.
func (m *EventMutation) RelevanceScore() (r float64, exists bool) {
	v := m.relevance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "relevance_score" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRelevanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds f to the "relevance_score" field.
func (m *EventMutation) AddRelevanceScore(f float64) {
	if m.addrelevance_score != nil {
		*m.addrelevance_score += f
	} else {
		m.addrelevance_score = &f
	}
}

// AddedRelevanceScore returns the value that was added to the "relevance_score" field in this mutation.
func (m *EventMutation) AddedRelevanceScore() (r float64, exists bool) {
	v := m.addrelevance_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelevanceScore clears the value of the "relevance_score" field.
func (m *EventMutation) ClearRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	m.clearedFields[event.FieldRelevanceScore] = struct{}{}
}

// RelevanceScoreCleared returns if the "relevance_score" field was cleared in this mutation.
func (m *EventMutation) RelevanceScoreCleared() bool {
	_, ok := m.clearedFields[event.FieldRelevanceScore]
	return ok
}

// ResetRelevanceScore resets all changes to the "relevance_score" field.
func (m *EventMutation) ResetRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	delete(m.clearedFields, event.FieldRelevanceScore)
}

// SetFollowerCount sets the "follower_count" field.
func (m *EventMutation) SetFollowerCount(i int) {
	m.follower_count = &i
	m.addfollower_count = nil
}

// FollowerCount returns the value of the "follower_count" field in the mutation.
func (m *EventMutation) FollowerCount() (r int, exists bool) {
	v := m.follower_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerCount returns the old "follower_count" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFollowerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerCount: %w", err)
	}
	return oldValue.FollowerCount, nil
}

// AddFollowerCount adds i to the "follower_count" field.
func (m *EventMutation) AddFollowerCount(i int) {
	if m.addfollower_count != nil {
		*m.addfollower_count += i
	} else {
		m.addfollower_count = &i
	}
}

// AddedFollowerCount returns the value that was added to the "follower_count" field in this mutation.
func (m *EventMutation) AddedFollowerCount() (r int, exists bool) {
	v := m.addfollower_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowerCount resets all changes to the "follower_count" field.
func (m *EventMutation) ResetFollowerCount() {
	m.follower_count = nil
	m.addfollower_count = nil
}

// SetFollowingCount sets the "following_count" field.
func (m *EventMutation) SetFollowingCount(i int) {
	m.following_count = &i
	m.addfollowing_count = nil
}

// FollowingCount returns the value of the "following_count" field in the mutation.
func (m *EventMutation) FollowingCount() (r int, exists bool) {
	v := m.following_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingCount returns the old "following_count" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFollowingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingCount: %w", err)
	}
	return oldValue.FollowingCount, nil
}

// AddFollowingCount adds i to the "following_count" field.
func (m *EventMutation) AddFollowingCount(i int) {
	if m.addfollowing_count != nil {
		*m.addfollowing_count += i
	} else {
		m.addfollowing_count = &i
	}
}

// AddedFollowingCount returns the value that was added to the "following_count" field in this mutation.
func (m *EventMutation) AddedFollowingCount() (r int, exists bool) {
	v := m.addfollowing_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowingCount resets all changes to the "following_count" field.
func (m *EventMutation) ResetFollowingCount() {
	m.following_count = nil
	m.addfollowing_count = nil
}

// SetIsPremium sets the "is_Premium" field.
func (m *EventMutation) SetIsPremium(b bool) {
	m.is_Premium = &b
}

// IsPremium returns the value of the "is_Premium" field in the mutation.
func (m *EventMutation) IsPremium() (r bool, exists bool) {
	v := m.is_Premium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old "is_Premium" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium resets all changes to the "is_Premium" field.
func (m *EventMutation) ResetIsPremium() {
	m.is_Premium = nil
}

// SetIsPublished sets the "is_published" field.
func (m *EventMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *EventMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *EventMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetIsOnline sets the "is_Online" field.
func (m *EventMutation) SetIsOnline(b bool) {
	m.is_Online = &b
}

// IsOnline returns the value of the "is_Online" field in the mutation.
func (m *EventMutation) IsOnline() (r bool, exists bool) {
	v := m.is_Online
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnline returns the old "is_Online" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnline: %w", err)
	}
	return oldValue.IsOnline, nil
}

// ResetIsOnline resets all changes to the "is_Online" field.
func (m *EventMutation) ResetIsOnline() {
	m.is_Online = nil
}

// SetIsFree sets the "is_Free" field.
func (m *EventMutation) SetIsFree(b bool) {
	m.is_Free = &b
}

// IsFree returns the value of the "is_Free" field in the mutation.
func (m *EventMutation) IsFree() (r bool, exists bool) {
	v := m.is_Free
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFree returns the old "is_Free" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsFree(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFree: %w", err)
	}
	return oldValue.IsFree, nil
}

// ResetIsFree resets all changes to the "is_Free" field.
func (m *EventMutation) ResetIsFree() {
	m.is_Free = nil
}

// SetIsPaid sets the "is_Paid" field.
func (m *EventMutation) SetIsPaid(b bool) {
	m.is_Paid = &b
}

// IsPaid returns the value of the "is_Paid" field in the mutation.
func (m *EventMutation) IsPaid() (r bool, exists bool) {
	v := m.is_Paid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPaid returns the old "is_Paid" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsPaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPaid: %w", err)
	}
	return oldValue.IsPaid, nil
}

// ResetIsPaid resets all changes to the "is_Paid" field.
func (m *EventMutation) ResetIsPaid() {
	m.is_Paid = nil
}

// SetIsPublic sets the "is_public" field.
func (m *EventMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *EventMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *EventMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetIsOnlineOnly sets the "is_Online_Only" field.
func (m *EventMutation) SetIsOnlineOnly(b bool) {
	m.is_Online_Only = &b
}

// IsOnlineOnly returns the value of the "is_Online_Only" field in the mutation.
func (m *EventMutation) IsOnlineOnly() (r bool, exists bool) {
	v := m.is_Online_Only
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnlineOnly returns the old "is_Online_Only" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsOnlineOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOnlineOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOnlineOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnlineOnly: %w", err)
	}
	return oldValue.IsOnlineOnly, nil
}

// ResetIsOnlineOnly resets all changes to the "is_Online_Only" field.
func (m *EventMutation) ResetIsOnlineOnly() {
	m.is_Online_Only = nil
}

// SetIsInPersonOnly sets the "is_In_Person_Only" field.
func (m *EventMutation) SetIsInPersonOnly(b bool) {
	m.is_In_Person_Only = &b
}

// IsInPersonOnly returns the value of the "is_In_Person_Only" field in the mutation.
func (m *EventMutation) IsInPersonOnly() (r bool, exists bool) {
	v := m.is_In_Person_Only
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInPersonOnly returns the old "is_In_Person_Only" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsInPersonOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInPersonOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInPersonOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInPersonOnly: %w", err)
	}
	return oldValue.IsInPersonOnly, nil
}

// ResetIsInPersonOnly resets all changes to the "is_In_Person_Only" field.
func (m *EventMutation) ResetIsInPersonOnly() {
	m.is_In_Person_Only = nil
}

// SetIsHybrid sets the "is_Hybrid" field.
func (m *EventMutation) SetIsHybrid(b bool) {
	m.is_Hybrid = &b
}

// IsHybrid returns the value of the "is_Hybrid" field in the mutation.
func (m *EventMutation) IsHybrid() (r bool, exists bool) {
	v := m.is_Hybrid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHybrid returns the old "is_Hybrid" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsHybrid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHybrid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHybrid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHybrid: %w", err)
	}
	return oldValue.IsHybrid, nil
}

// ResetIsHybrid resets all changes to the "is_Hybrid" field.
func (m *EventMutation) ResetIsHybrid() {
	m.is_Hybrid = nil
}

// SetIsOnlineAndInPerson sets the "is_Online_And_In_Person" field.
func (m *EventMutation) SetIsOnlineAndInPerson(b bool) {
	m.is_Online_And_In_Person = &b
}

// IsOnlineAndInPerson returns the value of the "is_Online_And_In_Person" field in the mutation.
func (m *EventMutation) IsOnlineAndInPerson() (r bool, exists bool) {
	v := m.is_Online_And_In_Person
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnlineAndInPerson returns the old "is_Online_And_In_Person" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsOnlineAndInPerson(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOnlineAndInPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOnlineAndInPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnlineAndInPerson: %w", err)
	}
	return oldValue.IsOnlineAndInPerson, nil
}

// ResetIsOnlineAndInPerson resets all changes to the "is_Online_And_In_Person" field.
func (m *EventMutation) ResetIsOnlineAndInPerson() {
	m.is_Online_And_In_Person = nil
}

// SetIsOnlineAndInPersonOnly sets the "is_Online_And_In_Person_Only" field.
func (m *EventMutation) SetIsOnlineAndInPersonOnly(b bool) {
	m.is_Online_And_In_Person_Only = &b
}

// IsOnlineAndInPersonOnly returns the value of the "is_Online_And_In_Person_Only" field in the mutation.
func (m *EventMutation) IsOnlineAndInPersonOnly() (r bool, exists bool) {
	v := m.is_Online_And_In_Person_Only
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnlineAndInPersonOnly returns the old "is_Online_And_In_Person_Only" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsOnlineAndInPersonOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOnlineAndInPersonOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOnlineAndInPersonOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnlineAndInPersonOnly: %w", err)
	}
	return oldValue.IsOnlineAndInPersonOnly, nil
}

// ResetIsOnlineAndInPersonOnly resets all changes to the "is_Online_And_In_Person_Only" field.
func (m *EventMutation) ResetIsOnlineAndInPersonOnly() {
	m.is_Online_And_In_Person_Only = nil
}

// SetIsOnlineAndInPersonOrHybrid sets the "is_Online_And_In_Person_Or_Hybrid" field.
func (m *EventMutation) SetIsOnlineAndInPersonOrHybrid(b bool) {
	m.is_Online_And_In_Person_Or_Hybrid = &b
}

// IsOnlineAndInPersonOrHybrid returns the value of the "is_Online_And_In_Person_Or_Hybrid" field in the mutation.
func (m *EventMutation) IsOnlineAndInPersonOrHybrid() (r bool, exists bool) {
	v := m.is_Online_And_In_Person_Or_Hybrid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnlineAndInPersonOrHybrid returns the old "is_Online_And_In_Person_Or_Hybrid" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsOnlineAndInPersonOrHybrid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOnlineAndInPersonOrHybrid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOnlineAndInPersonOrHybrid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnlineAndInPersonOrHybrid: %w", err)
	}
	return oldValue.IsOnlineAndInPersonOrHybrid, nil
}

// ResetIsOnlineAndInPersonOrHybrid resets all changes to the "is_Online_And_In_Person_Or_Hybrid" field.
func (m *EventMutation) ResetIsOnlineAndInPersonOrHybrid() {
	m.is_Online_And_In_Person_Or_Hybrid = nil
}

// SetLikedByCurrentUser sets the "likedByCurrentUser" field.
func (m *EventMutation) SetLikedByCurrentUser(b bool) {
	m.likedByCurrentUser = &b
}

// LikedByCurrentUser returns the value of the "likedByCurrentUser" field in the mutation.
func (m *EventMutation) LikedByCurrentUser() (r bool, exists bool) {
	v := m.likedByCurrentUser
	if v == nil {
		return
	}
	return *v, true
}

// OldLikedByCurrentUser returns the old "likedByCurrentUser" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLikedByCurrentUser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikedByCurrentUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikedByCurrentUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikedByCurrentUser: %w", err)
	}
	return oldValue.LikedByCurrentUser, nil
}

// ResetLikedByCurrentUser resets all changes to the "likedByCurrentUser" field.
func (m *EventMutation) ResetLikedByCurrentUser() {
	m.likedByCurrentUser = nil
}

// SetFollowedByCurrentUser sets the "followedByCurrentUser" field.
func (m *EventMutation) SetFollowedByCurrentUser(b bool) {
	m.followedByCurrentUser = &b
}

// FollowedByCurrentUser returns the value of the "followedByCurrentUser" field in the mutation.
func (m *EventMutation) FollowedByCurrentUser() (r bool, exists bool) {
	v := m.followedByCurrentUser
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowedByCurrentUser returns the old "followedByCurrentUser" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFollowedByCurrentUser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowedByCurrentUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowedByCurrentUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowedByCurrentUser: %w", err)
	}
	return oldValue.FollowedByCurrentUser, nil
}

// ResetFollowedByCurrentUser resets all changes to the "followedByCurrentUser" field.
func (m *EventMutation) ResetFollowedByCurrentUser() {
	m.followedByCurrentUser = nil
}

// SetRegistrationType sets the "registration_type" field.
func (m *EventMutation) SetRegistrationType(et event.RegistrationType) {
	m.registration_type = &et
}

// RegistrationType returns the value of the "registration_type" field in the mutation.
func (m *EventMutation) RegistrationType() (r event.RegistrationType, exists bool) {
	v := m.registration_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationType returns the old "registration_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRegistrationType(ctx context.Context) (v event.RegistrationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationType: %w", err)
	}
	return oldValue.RegistrationType, nil
}

// ClearRegistrationType clears the value of the "registration_type" field.
func (m *EventMutation) ClearRegistrationType() {
	m.registration_type = nil
	m.clearedFields[event.FieldRegistrationType] = struct{}{}
}

// RegistrationTypeCleared returns if the "registration_type" field was cleared in this mutation.
func (m *EventMutation) RegistrationTypeCleared() bool {
	_, ok := m.clearedFields[event.FieldRegistrationType]
	return ok
}

// ResetRegistrationType resets all changes to the "registration_type" field.
func (m *EventMutation) ResetRegistrationType() {
	m.registration_type = nil
	delete(m.clearedFields, event.FieldRegistrationType)
}

// SetRegistrationURL sets the "registration_url" field.
func (m *EventMutation) SetRegistrationURL(s string) {
	m.registration_url = &s
}

// RegistrationURL returns the value of the "registration_url" field in the mutation.
func (m *EventMutation) RegistrationURL() (r string, exists bool) {
	v := m.registration_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationURL returns the old "registration_url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRegistrationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationURL: %w", err)
	}
	return oldValue.RegistrationURL, nil
}

// ClearRegistrationURL clears the value of the "registration_url" field.
func (m *EventMutation) ClearRegistrationURL() {
	m.registration_url = nil
	m.clearedFields[event.FieldRegistrationURL] = struct{}{}
}

// RegistrationURLCleared returns if the "registration_url" field was cleared in this mutation.
func (m *EventMutation) RegistrationURLCleared() bool {
	_, ok := m.clearedFields[event.FieldRegistrationURL]
	return ok
}

// ResetRegistrationURL resets all changes to the "registration_url" field.
func (m *EventMutation) ResetRegistrationURL() {
	m.registration_url = nil
	delete(m.clearedFields, event.FieldRegistrationURL)
}

// SetIsPhysicallyAccessible sets the "is_physically_accessible" field.
func (m *EventMutation) SetIsPhysicallyAccessible(b bool) {
	m.is_physically_accessible = &b
}

// IsPhysicallyAccessible returns the value of the "is_physically_accessible" field in the mutation.
func (m *EventMutation) IsPhysicallyAccessible() (r bool, exists bool) {
	v := m.is_physically_accessible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPhysicallyAccessible returns the old "is_physically_accessible" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsPhysicallyAccessible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPhysicallyAccessible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPhysicallyAccessible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPhysicallyAccessible: %w", err)
	}
	return oldValue.IsPhysicallyAccessible, nil
}

// ResetIsPhysicallyAccessible resets all changes to the "is_physically_accessible" field.
func (m *EventMutation) ResetIsPhysicallyAccessible() {
	m.is_physically_accessible = nil
}

// SetAccessibilityInfo sets the "accessibility_info" field.
func (m *EventMutation) SetAccessibilityInfo(s string) {
	m.accessibility_info = &s
}

// AccessibilityInfo returns the value of the "accessibility_info" field in the mutation.
func (m *EventMutation) AccessibilityInfo() (r string, exists bool) {
	v := m.accessibility_info
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessibilityInfo returns the old "accessibility_info" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAccessibilityInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessibilityInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessibilityInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessibilityInfo: %w", err)
	}
	return oldValue.AccessibilityInfo, nil
}

// ClearAccessibilityInfo clears the value of the "accessibility_info" field.
func (m *EventMutation) ClearAccessibilityInfo() {
	m.accessibility_info = nil
	m.clearedFields[event.FieldAccessibilityInfo] = struct{}{}
}

// AccessibilityInfoCleared returns if the "accessibility_info" field was cleared in this mutation.
func (m *EventMutation) AccessibilityInfoCleared() bool {
	_, ok := m.clearedFields[event.FieldAccessibilityInfo]
	return ok
}

// ResetAccessibilityInfo resets all changes to the "accessibility_info" field.
func (m *EventMutation) ResetAccessibilityInfo() {
	m.accessibility_info = nil
	delete(m.clearedFields, event.FieldAccessibilityInfo)
}

// SetIsVirtuallyAccessible sets the "is_virtually_accessible" field.
func (m *EventMutation) SetIsVirtuallyAccessible(b bool) {
	m.is_virtually_accessible = &b
}

// IsVirtuallyAccessible returns the value of the "is_virtually_accessible" field in the mutation.
func (m *EventMutation) IsVirtuallyAccessible() (r bool, exists bool) {
	v := m.is_virtually_accessible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVirtuallyAccessible returns the old "is_virtually_accessible" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsVirtuallyAccessible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVirtuallyAccessible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVirtuallyAccessible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVirtuallyAccessible: %w", err)
	}
	return oldValue.IsVirtuallyAccessible, nil
}

// ResetIsVirtuallyAccessible resets all changes to the "is_virtually_accessible" field.
func (m *EventMutation) ResetIsVirtuallyAccessible() {
	m.is_virtually_accessible = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *EventMutation) AddTicketIDs(ids ...string) {
	if m.tickets == nil {
		m.tickets = make(map[string]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *EventMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *EventMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *EventMutation) RemoveTicketIDs(ids ...string) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *EventMutation) RemovedTicketsIDs() (ids []string) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *EventMutation) TicketsIDs() (ids []string) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *EventMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddTicketOptionIDs adds the "ticket_options" edge to the TicketOption entity by ids.
func (m *EventMutation) AddTicketOptionIDs(ids ...string) {
	if m.ticket_options == nil {
		m.ticket_options = make(map[string]struct{})
	}
	for i := range ids {
		m.ticket_options[ids[i]] = struct{}{}
	}
}

// ClearTicketOptions clears the "ticket_options" edge to the TicketOption entity.
func (m *EventMutation) ClearTicketOptions() {
	m.clearedticket_options = true
}

// TicketOptionsCleared reports if the "ticket_options" edge to the TicketOption entity was cleared.
func (m *EventMutation) TicketOptionsCleared() bool {
	return m.clearedticket_options
}

// RemoveTicketOptionIDs removes the "ticket_options" edge to the TicketOption entity by IDs.
func (m *EventMutation) RemoveTicketOptionIDs(ids ...string) {
	if m.removedticket_options == nil {
		m.removedticket_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ticket_options, ids[i])
		m.removedticket_options[ids[i]] = struct{}{}
	}
}

// RemovedTicketOptions returns the removed IDs of the "ticket_options" edge to the TicketOption entity.
func (m *EventMutation) RemovedTicketOptionsIDs() (ids []string) {
	for id := range m.removedticket_options {
		ids = append(ids, id)
	}
	return
}

// TicketOptionsIDs returns the "ticket_options" edge IDs in the mutation.
func (m *EventMutation) TicketOptionsIDs() (ids []string) {
	for id := range m.ticket_options {
		ids = append(ids, id)
	}
	return
}

// ResetTicketOptions resets all changes to the "ticket_options" edge.
func (m *EventMutation) ResetTicketOptions() {
	m.ticket_options = nil
	m.clearedticket_options = false
	m.removedticket_options = nil
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *EventMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *EventMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *EventMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *EventMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *EventMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *EventMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *EventMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddEventCategoryIDs adds the "event_categories" edge to the Category entity by ids.
func (m *EventMutation) AddEventCategoryIDs(ids ...string) {
	if m.event_categories == nil {
		m.event_categories = make(map[string]struct{})
	}
	for i := range ids {
		m.event_categories[ids[i]] = struct{}{}
	}
}

// ClearEventCategories clears the "event_categories" edge to the Category entity.
func (m *EventMutation) ClearEventCategories() {
	m.clearedevent_categories = true
}

// EventCategoriesCleared reports if the "event_categories" edge to the Category entity was cleared.
func (m *EventMutation) EventCategoriesCleared() bool {
	return m.clearedevent_categories
}

// RemoveEventCategoryIDs removes the "event_categories" edge to the Category entity by IDs.
func (m *EventMutation) RemoveEventCategoryIDs(ids ...string) {
	if m.removedevent_categories == nil {
		m.removedevent_categories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.event_categories, ids[i])
		m.removedevent_categories[ids[i]] = struct{}{}
	}
}

// RemovedEventCategories returns the removed IDs of the "event_categories" edge to the Category entity.
func (m *EventMutation) RemovedEventCategoriesIDs() (ids []string) {
	for id := range m.removedevent_categories {
		ids = append(ids, id)
	}
	return
}

// EventCategoriesIDs returns the "event_categories" edge IDs in the mutation.
func (m *EventMutation) EventCategoriesIDs() (ids []string) {
	for id := range m.event_categories {
		ids = append(ids, id)
	}
	return
}

// ResetEventCategories resets all changes to the "event_categories" edge.
func (m *EventMutation) ResetEventCategories() {
	m.event_categories = nil
	m.clearedevent_categories = false
	m.removedevent_categories = nil
}

// AddEventCategoryAssignmentIDs adds the "event_category_assignments" edge to the CategoryAssignment entity by ids.
func (m *EventMutation) AddEventCategoryAssignmentIDs(ids ...string) {
	if m.event_category_assignments == nil {
		m.event_category_assignments = make(map[string]struct{})
	}
	for i := range ids {
		m.event_category_assignments[ids[i]] = struct{}{}
	}
}

// ClearEventCategoryAssignments clears the "event_category_assignments" edge to the CategoryAssignment entity.
func (m *EventMutation) ClearEventCategoryAssignments() {
	m.clearedevent_category_assignments = true
}

// EventCategoryAssignmentsCleared reports if the "event_category_assignments" edge to the CategoryAssignment entity was cleared.
func (m *EventMutation) EventCategoryAssignmentsCleared() bool {
	return m.clearedevent_category_assignments
}

// RemoveEventCategoryAssignmentIDs removes the "event_category_assignments" edge to the CategoryAssignment entity by IDs.
func (m *EventMutation) RemoveEventCategoryAssignmentIDs(ids ...string) {
	if m.removedevent_category_assignments == nil {
		m.removedevent_category_assignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.event_category_assignments, ids[i])
		m.removedevent_category_assignments[ids[i]] = struct{}{}
	}
}

// RemovedEventCategoryAssignments returns the removed IDs of the "event_category_assignments" edge to the CategoryAssignment entity.
func (m *EventMutation) RemovedEventCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedevent_category_assignments {
		ids = append(ids, id)
	}
	return
}

// EventCategoryAssignmentsIDs returns the "event_category_assignments" edge IDs in the mutation.
func (m *EventMutation) EventCategoryAssignmentsIDs() (ids []string) {
	for id := range m.event_category_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetEventCategoryAssignments resets all changes to the "event_category_assignments" edge.
func (m *EventMutation) ResetEventCategoryAssignments() {
	m.event_category_assignments = nil
	m.clearedevent_category_assignments = false
	m.removedevent_category_assignments = nil
}

// SetOwnerUserID sets the "ownerUser" edge to the User entity by id.
func (m *EventMutation) SetOwnerUserID(id string) {
	m.ownerUser = &id
}

// ClearOwnerUser clears the "ownerUser" edge to the User entity.
func (m *EventMutation) ClearOwnerUser() {
	m.clearedownerUser = true
}

// OwnerUserCleared reports if the "ownerUser" edge to the User entity was cleared.
func (m *EventMutation) OwnerUserCleared() bool {
	return m.clearedownerUser
}

// OwnerUserID returns the "ownerUser" edge ID in the mutation.
func (m *EventMutation) OwnerUserID() (id string, exists bool) {
	if m.ownerUser != nil {
		return *m.ownerUser, true
	}
	return
}

// OwnerUserIDs returns the "ownerUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerUserID instead. It exists only for internal usage by the builders.
func (m *EventMutation) OwnerUserIDs() (ids []string) {
	if id := m.ownerUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerUser resets all changes to the "ownerUser" edge.
func (m *EventMutation) ResetOwnerUser() {
	m.ownerUser = nil
	m.clearedownerUser = false
}

// SetOwnerBusinessID sets the "ownerBusiness" edge to the Business entity by id.
func (m *EventMutation) SetOwnerBusinessID(id string) {
	m.ownerBusiness = &id
}

// ClearOwnerBusiness clears the "ownerBusiness" edge to the Business entity.
func (m *EventMutation) ClearOwnerBusiness() {
	m.clearedownerBusiness = true
}

// OwnerBusinessCleared reports if the "ownerBusiness" edge to the Business entity was cleared.
func (m *EventMutation) OwnerBusinessCleared() bool {
	return m.clearedownerBusiness
}

// OwnerBusinessID returns the "ownerBusiness" edge ID in the mutation.
func (m *EventMutation) OwnerBusinessID() (id string, exists bool) {
	if m.ownerBusiness != nil {
		return *m.ownerBusiness, true
	}
	return
}

// OwnerBusinessIDs returns the "ownerBusiness" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerBusinessID instead. It exists only for internal usage by the builders.
func (m *EventMutation) OwnerBusinessIDs() (ids []string) {
	if id := m.ownerBusiness; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerBusiness resets all changes to the "ownerBusiness" edge.
func (m *EventMutation) ResetOwnerBusiness() {
	m.ownerBusiness = nil
	m.clearedownerBusiness = false
}

// AddUserFollowerIDs adds the "userFollowers" edge to the UserFollowEvent entity by ids.
func (m *EventMutation) AddUserFollowerIDs(ids ...string) {
	if m.userFollowers == nil {
		m.userFollowers = make(map[string]struct{})
	}
	for i := range ids {
		m.userFollowers[ids[i]] = struct{}{}
	}
}

// ClearUserFollowers clears the "userFollowers" edge to the UserFollowEvent entity.
func (m *EventMutation) ClearUserFollowers() {
	m.cleareduserFollowers = true
}

// UserFollowersCleared reports if the "userFollowers" edge to the UserFollowEvent entity was cleared.
func (m *EventMutation) UserFollowersCleared() bool {
	return m.cleareduserFollowers
}

// RemoveUserFollowerIDs removes the "userFollowers" edge to the UserFollowEvent entity by IDs.
func (m *EventMutation) RemoveUserFollowerIDs(ids ...string) {
	if m.removeduserFollowers == nil {
		m.removeduserFollowers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.userFollowers, ids[i])
		m.removeduserFollowers[ids[i]] = struct{}{}
	}
}

// RemovedUserFollowers returns the removed IDs of the "userFollowers" edge to the UserFollowEvent entity.
func (m *EventMutation) RemovedUserFollowersIDs() (ids []string) {
	for id := range m.removeduserFollowers {
		ids = append(ids, id)
	}
	return
}

// UserFollowersIDs returns the "userFollowers" edge IDs in the mutation.
func (m *EventMutation) UserFollowersIDs() (ids []string) {
	for id := range m.userFollowers {
		ids = append(ids, id)
	}
	return
}

// ResetUserFollowers resets all changes to the "userFollowers" edge.
func (m *EventMutation) ResetUserFollowers() {
	m.userFollowers = nil
	m.cleareduserFollowers = false
	m.removeduserFollowers = nil
}

// AddBusinessFollowerIDs adds the "businessFollowers" edge to the BusinessFollowEvent entity by ids.
func (m *EventMutation) AddBusinessFollowerIDs(ids ...string) {
	if m.businessFollowers == nil {
		m.businessFollowers = make(map[string]struct{})
	}
	for i := range ids {
		m.businessFollowers[ids[i]] = struct{}{}
	}
}

// ClearBusinessFollowers clears the "businessFollowers" edge to the BusinessFollowEvent entity.
func (m *EventMutation) ClearBusinessFollowers() {
	m.clearedbusinessFollowers = true
}

// BusinessFollowersCleared reports if the "businessFollowers" edge to the BusinessFollowEvent entity was cleared.
func (m *EventMutation) BusinessFollowersCleared() bool {
	return m.clearedbusinessFollowers
}

// RemoveBusinessFollowerIDs removes the "businessFollowers" edge to the BusinessFollowEvent entity by IDs.
func (m *EventMutation) RemoveBusinessFollowerIDs(ids ...string) {
	if m.removedbusinessFollowers == nil {
		m.removedbusinessFollowers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.businessFollowers, ids[i])
		m.removedbusinessFollowers[ids[i]] = struct{}{}
	}
}

// RemovedBusinessFollowers returns the removed IDs of the "businessFollowers" edge to the BusinessFollowEvent entity.
func (m *EventMutation) RemovedBusinessFollowersIDs() (ids []string) {
	for id := range m.removedbusinessFollowers {
		ids = append(ids, id)
	}
	return
}

// BusinessFollowersIDs returns the "businessFollowers" edge IDs in the mutation.
func (m *EventMutation) BusinessFollowersIDs() (ids []string) {
	for id := range m.businessFollowers {
		ids = append(ids, id)
	}
	return
}

// ResetBusinessFollowers resets all changes to the "businessFollowers" edge.
func (m *EventMutation) ResetBusinessFollowers() {
	m.businessFollowers = nil
	m.clearedbusinessFollowers = false
	m.removedbusinessFollowers = nil
}

// AddFaqIDs adds the "faqs" edge to the FAQ entity by ids.
func (m *EventMutation) AddFaqIDs(ids ...string) {
	if m.faqs == nil {
		m.faqs = make(map[string]struct{})
	}
	for i := range ids {
		m.faqs[ids[i]] = struct{}{}
	}
}

// ClearFaqs clears the "faqs" edge to the FAQ entity.
func (m *EventMutation) ClearFaqs() {
	m.clearedfaqs = true
}

// FaqsCleared reports if the "faqs" edge to the FAQ entity was cleared.
func (m *EventMutation) FaqsCleared() bool {
	return m.clearedfaqs
}

// RemoveFaqIDs removes the "faqs" edge to the FAQ entity by IDs.
func (m *EventMutation) RemoveFaqIDs(ids ...string) {
	if m.removedfaqs == nil {
		m.removedfaqs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.faqs, ids[i])
		m.removedfaqs[ids[i]] = struct{}{}
	}
}

// RemovedFaqs returns the removed IDs of the "faqs" edge to the FAQ entity.
func (m *EventMutation) RemovedFaqsIDs() (ids []string) {
	for id := range m.removedfaqs {
		ids = append(ids, id)
	}
	return
}

// FaqsIDs returns the "faqs" edge IDs in the mutation.
func (m *EventMutation) FaqsIDs() (ids []string) {
	for id := range m.faqs {
		ids = append(ids, id)
	}
	return
}

// ResetFaqs resets all changes to the "faqs" edge.
func (m *EventMutation) ResetFaqs() {
	m.faqs = nil
	m.clearedfaqs = false
	m.removedfaqs = nil
}

// AddRatingIDs adds the "ratings" edge to the Rating entity by ids.
func (m *EventMutation) AddRatingIDs(ids ...string) {
	if m.ratings == nil {
		m.ratings = make(map[string]struct{})
	}
	for i := range ids {
		m.ratings[ids[i]] = struct{}{}
	}
}

// ClearRatings clears the "ratings" edge to the Rating entity.
func (m *EventMutation) ClearRatings() {
	m.clearedratings = true
}

// RatingsCleared reports if the "ratings" edge to the Rating entity was cleared.
func (m *EventMutation) RatingsCleared() bool {
	return m.clearedratings
}

// RemoveRatingIDs removes the "ratings" edge to the Rating entity by IDs.
func (m *EventMutation) RemoveRatingIDs(ids ...string) {
	if m.removedratings == nil {
		m.removedratings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratings, ids[i])
		m.removedratings[ids[i]] = struct{}{}
	}
}

// RemovedRatings returns the removed IDs of the "ratings" edge to the Rating entity.
func (m *EventMutation) RemovedRatingsIDs() (ids []string) {
	for id := range m.removedratings {
		ids = append(ids, id)
	}
	return
}

// RatingsIDs returns the "ratings" edge IDs in the mutation.
func (m *EventMutation) RatingsIDs() (ids []string) {
	for id := range m.ratings {
		ids = append(ids, id)
	}
	return
}

// ResetRatings resets all changes to the "ratings" edge.
func (m *EventMutation) ResetRatings() {
	m.ratings = nil
	m.clearedratings = false
	m.removedratings = nil
}

// AddAdditionalOrganizerIDs adds the "additional_organizers" edge to the User entity by ids.
func (m *EventMutation) AddAdditionalOrganizerIDs(ids ...string) {
	if m.additional_organizers == nil {
		m.additional_organizers = make(map[string]struct{})
	}
	for i := range ids {
		m.additional_organizers[ids[i]] = struct{}{}
	}
}

// ClearAdditionalOrganizers clears the "additional_organizers" edge to the User entity.
func (m *EventMutation) ClearAdditionalOrganizers() {
	m.clearedadditional_organizers = true
}

// AdditionalOrganizersCleared reports if the "additional_organizers" edge to the User entity was cleared.
func (m *EventMutation) AdditionalOrganizersCleared() bool {
	return m.clearedadditional_organizers
}

// RemoveAdditionalOrganizerIDs removes the "additional_organizers" edge to the User entity by IDs.
func (m *EventMutation) RemoveAdditionalOrganizerIDs(ids ...string) {
	if m.removedadditional_organizers == nil {
		m.removedadditional_organizers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.additional_organizers, ids[i])
		m.removedadditional_organizers[ids[i]] = struct{}{}
	}
}

// RemovedAdditionalOrganizers returns the removed IDs of the "additional_organizers" edge to the User entity.
func (m *EventMutation) RemovedAdditionalOrganizersIDs() (ids []string) {
	for id := range m.removedadditional_organizers {
		ids = append(ids, id)
	}
	return
}

// AdditionalOrganizersIDs returns the "additional_organizers" edge IDs in the mutation.
func (m *EventMutation) AdditionalOrganizersIDs() (ids []string) {
	for id := range m.additional_organizers {
		ids = append(ids, id)
	}
	return
}

// ResetAdditionalOrganizers resets all changes to the "additional_organizers" edge.
func (m *EventMutation) ResetAdditionalOrganizers() {
	m.additional_organizers = nil
	m.clearedadditional_organizers = false
	m.removedadditional_organizers = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *EventMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *EventMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *EventMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *EventMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *EventMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *EventMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *EventMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddEventCommentIDs adds the "event_comments" edge to the Comment entity by ids.
func (m *EventMutation) AddEventCommentIDs(ids ...string) {
	if m.event_comments == nil {
		m.event_comments = make(map[string]struct{})
	}
	for i := range ids {
		m.event_comments[ids[i]] = struct{}{}
	}
}

// ClearEventComments clears the "event_comments" edge to the Comment entity.
func (m *EventMutation) ClearEventComments() {
	m.clearedevent_comments = true
}

// EventCommentsCleared reports if the "event_comments" edge to the Comment entity was cleared.
func (m *EventMutation) EventCommentsCleared() bool {
	return m.clearedevent_comments
}

// RemoveEventCommentIDs removes the "event_comments" edge to the Comment entity by IDs.
func (m *EventMutation) RemoveEventCommentIDs(ids ...string) {
	if m.removedevent_comments == nil {
		m.removedevent_comments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.event_comments, ids[i])
		m.removedevent_comments[ids[i]] = struct{}{}
	}
}

// RemovedEventComments returns the removed IDs of the "event_comments" edge to the Comment entity.
func (m *EventMutation) RemovedEventCommentsIDs() (ids []string) {
	for id := range m.removedevent_comments {
		ids = append(ids, id)
	}
	return
}

// EventCommentsIDs returns the "event_comments" edge IDs in the mutation.
func (m *EventMutation) EventCommentsIDs() (ids []string) {
	for id := range m.event_comments {
		ids = append(ids, id)
	}
	return
}

// ResetEventComments resets all changes to the "event_comments" edge.
func (m *EventMutation) ResetEventComments() {
	m.event_comments = nil
	m.clearedevent_comments = false
	m.removedevent_comments = nil
}

// AddEventReviewIDs adds the "event_reviews" edge to the Review entity by ids.
func (m *EventMutation) AddEventReviewIDs(ids ...string) {
	if m.event_reviews == nil {
		m.event_reviews = make(map[string]struct{})
	}
	for i := range ids {
		m.event_reviews[ids[i]] = struct{}{}
	}
}

// ClearEventReviews clears the "event_reviews" edge to the Review entity.
func (m *EventMutation) ClearEventReviews() {
	m.clearedevent_reviews = true
}

// EventReviewsCleared reports if the "event_reviews" edge to the Review entity was cleared.
func (m *EventMutation) EventReviewsCleared() bool {
	return m.clearedevent_reviews
}

// RemoveEventReviewIDs removes the "event_reviews" edge to the Review entity by IDs.
func (m *EventMutation) RemoveEventReviewIDs(ids ...string) {
	if m.removedevent_reviews == nil {
		m.removedevent_reviews = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.event_reviews, ids[i])
		m.removedevent_reviews[ids[i]] = struct{}{}
	}
}

// RemovedEventReviews returns the removed IDs of the "event_reviews" edge to the Review entity.
func (m *EventMutation) RemovedEventReviewsIDs() (ids []string) {
	for id := range m.removedevent_reviews {
		ids = append(ids, id)
	}
	return
}

// EventReviewsIDs returns the "event_reviews" edge IDs in the mutation.
func (m *EventMutation) EventReviewsIDs() (ids []string) {
	for id := range m.event_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetEventReviews resets all changes to the "event_reviews" edge.
func (m *EventMutation) ResetEventReviews() {
	m.event_reviews = nil
	m.clearedevent_reviews = false
	m.removedevent_reviews = nil
}

// AddPerformerIDs adds the "performers" edge to the User entity by ids.
func (m *EventMutation) AddPerformerIDs(ids ...string) {
	if m.performers == nil {
		m.performers = make(map[string]struct{})
	}
	for i := range ids {
		m.performers[ids[i]] = struct{}{}
	}
}

// ClearPerformers clears the "performers" edge to the User entity.
func (m *EventMutation) ClearPerformers() {
	m.clearedperformers = true
}

// PerformersCleared reports if the "performers" edge to the User entity was cleared.
func (m *EventMutation) PerformersCleared() bool {
	return m.clearedperformers
}

// RemovePerformerIDs removes the "performers" edge to the User entity by IDs.
func (m *EventMutation) RemovePerformerIDs(ids ...string) {
	if m.removedperformers == nil {
		m.removedperformers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.performers, ids[i])
		m.removedperformers[ids[i]] = struct{}{}
	}
}

// RemovedPerformers returns the removed IDs of the "performers" edge to the User entity.
func (m *EventMutation) RemovedPerformersIDs() (ids []string) {
	for id := range m.removedperformers {
		ids = append(ids, id)
	}
	return
}

// PerformersIDs returns the "performers" edge IDs in the mutation.
func (m *EventMutation) PerformersIDs() (ids []string) {
	for id := range m.performers {
		ids = append(ids, id)
	}
	return
}

// ResetPerformers resets all changes to the "performers" edge.
func (m *EventMutation) ResetPerformers() {
	m.performers = nil
	m.clearedperformers = false
	m.removedperformers = nil
}

// AddEventOrganizerIDs adds the "event_organizers" edge to the EventOrganizer entity by ids.
func (m *EventMutation) AddEventOrganizerIDs(ids ...string) {
	if m.event_organizers == nil {
		m.event_organizers = make(map[string]struct{})
	}
	for i := range ids {
		m.event_organizers[ids[i]] = struct{}{}
	}
}

// ClearEventOrganizers clears the "event_organizers" edge to the EventOrganizer entity.
func (m *EventMutation) ClearEventOrganizers() {
	m.clearedevent_organizers = true
}

// EventOrganizersCleared reports if the "event_organizers" edge to the EventOrganizer entity was cleared.
func (m *EventMutation) EventOrganizersCleared() bool {
	return m.clearedevent_organizers
}

// RemoveEventOrganizerIDs removes the "event_organizers" edge to the EventOrganizer entity by IDs.
func (m *EventMutation) RemoveEventOrganizerIDs(ids ...string) {
	if m.removedevent_organizers == nil {
		m.removedevent_organizers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.event_organizers, ids[i])
		m.removedevent_organizers[ids[i]] = struct{}{}
	}
}

// RemovedEventOrganizers returns the removed IDs of the "event_organizers" edge to the EventOrganizer entity.
func (m *EventMutation) RemovedEventOrganizersIDs() (ids []string) {
	for id := range m.removedevent_organizers {
		ids = append(ids, id)
	}
	return
}

// EventOrganizersIDs returns the "event_organizers" edge IDs in the mutation.
func (m *EventMutation) EventOrganizersIDs() (ids []string) {
	for id := range m.event_organizers {
		ids = append(ids, id)
	}
	return
}

// ResetEventOrganizers resets all changes to the "event_organizers" edge.
func (m *EventMutation) ResetEventOrganizers() {
	m.event_organizers = nil
	m.clearedevent_organizers = false
	m.removedevent_organizers = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 60)
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	if m._EventType != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.status != nil {
		fields = append(fields, event.FieldStatus)
	}
	if m.location != nil {
		fields = append(fields, event.FieldLocation)
	}
	if m.url != nil {
		fields = append(fields, event.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, event.FieldTitle)
	}
	if m.time_zone != nil {
		fields = append(fields, event.FieldTimeZone)
	}
	if m.start_time != nil {
		fields = append(fields, event.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, event.FieldEndTime)
	}
	if m.start_date != nil {
		fields = append(fields, event.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, event.FieldEndDate)
	}
	if m.frequency != nil {
		fields = append(fields, event.FieldFrequency)
	}
	if m.frequency_interval != nil {
		fields = append(fields, event.FieldFrequencyInterval)
	}
	if m.frequency_day_of_week != nil {
		fields = append(fields, event.FieldFrequencyDayOfWeek)
	}
	if m.frequency_day_of_month != nil {
		fields = append(fields, event.FieldFrequencyDayOfMonth)
	}
	if m.frequency_month_of_year != nil {
		fields = append(fields, event.FieldFrequencyMonthOfYear)
	}
	if m.venue_type != nil {
		fields = append(fields, event.FieldVenueType)
	}
	if m.venue_name != nil {
		fields = append(fields, event.FieldVenueName)
	}
	if m.venue_address != nil {
		fields = append(fields, event.FieldVenueAddress)
	}
	if m.venue_city != nil {
		fields = append(fields, event.FieldVenueCity)
	}
	if m.venue_state != nil {
		fields = append(fields, event.FieldVenueState)
	}
	if m.venue_country != nil {
		fields = append(fields, event.FieldVenueCountry)
	}
	if m.venue_zip != nil {
		fields = append(fields, event.FieldVenueZip)
	}
	if m.venue_lat != nil {
		fields = append(fields, event.FieldVenueLat)
	}
	if m.venue_lon != nil {
		fields = append(fields, event.FieldVenueLon)
	}
	if m.venue_url != nil {
		fields = append(fields, event.FieldVenueURL)
	}
	if m.venue_phone != nil {
		fields = append(fields, event.FieldVenuePhone)
	}
	if m.venue_email != nil {
		fields = append(fields, event.FieldVenueEmail)
	}
	if m.tags != nil {
		fields = append(fields, event.FieldTags)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.event_settings != nil {
		fields = append(fields, event.FieldEventSettings)
	}
	if m.cover_image != nil {
		fields = append(fields, event.FieldCoverImage)
	}
	if m.createdAt != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.map_coordinates != nil {
		fields = append(fields, event.FieldMapCoordinates)
	}
	if m.longitude != nil {
		fields = append(fields, event.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, event.FieldLatitude)
	}
	if m.search_text != nil {
		fields = append(fields, event.FieldSearchText)
	}
	if m.relevance_score != nil {
		fields = append(fields, event.FieldRelevanceScore)
	}
	if m.follower_count != nil {
		fields = append(fields, event.FieldFollowerCount)
	}
	if m.following_count != nil {
		fields = append(fields, event.FieldFollowingCount)
	}
	if m.is_Premium != nil {
		fields = append(fields, event.FieldIsPremium)
	}
	if m.is_published != nil {
		fields = append(fields, event.FieldIsPublished)
	}
	if m.is_Online != nil {
		fields = append(fields, event.FieldIsOnline)
	}
	if m.is_Free != nil {
		fields = append(fields, event.FieldIsFree)
	}
	if m.is_Paid != nil {
		fields = append(fields, event.FieldIsPaid)
	}
	if m.is_public != nil {
		fields = append(fields, event.FieldIsPublic)
	}
	if m.is_Online_Only != nil {
		fields = append(fields, event.FieldIsOnlineOnly)
	}
	if m.is_In_Person_Only != nil {
		fields = append(fields, event.FieldIsInPersonOnly)
	}
	if m.is_Hybrid != nil {
		fields = append(fields, event.FieldIsHybrid)
	}
	if m.is_Online_And_In_Person != nil {
		fields = append(fields, event.FieldIsOnlineAndInPerson)
	}
	if m.is_Online_And_In_Person_Only != nil {
		fields = append(fields, event.FieldIsOnlineAndInPersonOnly)
	}
	if m.is_Online_And_In_Person_Or_Hybrid != nil {
		fields = append(fields, event.FieldIsOnlineAndInPersonOrHybrid)
	}
	if m.likedByCurrentUser != nil {
		fields = append(fields, event.FieldLikedByCurrentUser)
	}
	if m.followedByCurrentUser != nil {
		fields = append(fields, event.FieldFollowedByCurrentUser)
	}
	if m.registration_type != nil {
		fields = append(fields, event.FieldRegistrationType)
	}
	if m.registration_url != nil {
		fields = append(fields, event.FieldRegistrationURL)
	}
	if m.is_physically_accessible != nil {
		fields = append(fields, event.FieldIsPhysicallyAccessible)
	}
	if m.accessibility_info != nil {
		fields = append(fields, event.FieldAccessibilityInfo)
	}
	if m.is_virtually_accessible != nil {
		fields = append(fields, event.FieldIsVirtuallyAccessible)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldName:
		return m.Name()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldStatus:
		return m.Status()
	case event.FieldLocation:
		return m.Location()
	case event.FieldURL:
		return m.URL()
	case event.FieldTitle:
		return m.Title()
	case event.FieldTimeZone:
		return m.TimeZone()
	case event.FieldStartTime:
		return m.StartTime()
	case event.FieldEndTime:
		return m.EndTime()
	case event.FieldStartDate:
		return m.StartDate()
	case event.FieldEndDate:
		return m.EndDate()
	case event.FieldFrequency:
		return m.Frequency()
	case event.FieldFrequencyInterval:
		return m.FrequencyInterval()
	case event.FieldFrequencyDayOfWeek:
		return m.FrequencyDayOfWeek()
	case event.FieldFrequencyDayOfMonth:
		return m.FrequencyDayOfMonth()
	case event.FieldFrequencyMonthOfYear:
		return m.FrequencyMonthOfYear()
	case event.FieldVenueType:
		return m.VenueType()
	case event.FieldVenueName:
		return m.VenueName()
	case event.FieldVenueAddress:
		return m.VenueAddress()
	case event.FieldVenueCity:
		return m.VenueCity()
	case event.FieldVenueState:
		return m.VenueState()
	case event.FieldVenueCountry:
		return m.VenueCountry()
	case event.FieldVenueZip:
		return m.VenueZip()
	case event.FieldVenueLat:
		return m.VenueLat()
	case event.FieldVenueLon:
		return m.VenueLon()
	case event.FieldVenueURL:
		return m.VenueURL()
	case event.FieldVenuePhone:
		return m.VenuePhone()
	case event.FieldVenueEmail:
		return m.VenueEmail()
	case event.FieldTags:
		return m.Tags()
	case event.FieldDescription:
		return m.Description()
	case event.FieldEventSettings:
		return m.EventSettings()
	case event.FieldCoverImage:
		return m.CoverImage()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldMapCoordinates:
		return m.MapCoordinates()
	case event.FieldLongitude:
		return m.Longitude()
	case event.FieldLatitude:
		return m.Latitude()
	case event.FieldSearchText:
		return m.SearchText()
	case event.FieldRelevanceScore:
		return m.RelevanceScore()
	case event.FieldFollowerCount:
		return m.FollowerCount()
	case event.FieldFollowingCount:
		return m.FollowingCount()
	case event.FieldIsPremium:
		return m.IsPremium()
	case event.FieldIsPublished:
		return m.IsPublished()
	case event.FieldIsOnline:
		return m.IsOnline()
	case event.FieldIsFree:
		return m.IsFree()
	case event.FieldIsPaid:
		return m.IsPaid()
	case event.FieldIsPublic:
		return m.IsPublic()
	case event.FieldIsOnlineOnly:
		return m.IsOnlineOnly()
	case event.FieldIsInPersonOnly:
		return m.IsInPersonOnly()
	case event.FieldIsHybrid:
		return m.IsHybrid()
	case event.FieldIsOnlineAndInPerson:
		return m.IsOnlineAndInPerson()
	case event.FieldIsOnlineAndInPersonOnly:
		return m.IsOnlineAndInPersonOnly()
	case event.FieldIsOnlineAndInPersonOrHybrid:
		return m.IsOnlineAndInPersonOrHybrid()
	case event.FieldLikedByCurrentUser:
		return m.LikedByCurrentUser()
	case event.FieldFollowedByCurrentUser:
		return m.FollowedByCurrentUser()
	case event.FieldRegistrationType:
		return m.RegistrationType()
	case event.FieldRegistrationURL:
		return m.RegistrationURL()
	case event.FieldIsPhysicallyAccessible:
		return m.IsPhysicallyAccessible()
	case event.FieldAccessibilityInfo:
		return m.AccessibilityInfo()
	case event.FieldIsVirtuallyAccessible:
		return m.IsVirtuallyAccessible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldName:
		return m.OldName(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldStatus:
		return m.OldStatus(ctx)
	case event.FieldLocation:
		return m.OldLocation(ctx)
	case event.FieldURL:
		return m.OldURL(ctx)
	case event.FieldTitle:
		return m.OldTitle(ctx)
	case event.FieldTimeZone:
		return m.OldTimeZone(ctx)
	case event.FieldStartTime:
		return m.OldStartTime(ctx)
	case event.FieldEndTime:
		return m.OldEndTime(ctx)
	case event.FieldStartDate:
		return m.OldStartDate(ctx)
	case event.FieldEndDate:
		return m.OldEndDate(ctx)
	case event.FieldFrequency:
		return m.OldFrequency(ctx)
	case event.FieldFrequencyInterval:
		return m.OldFrequencyInterval(ctx)
	case event.FieldFrequencyDayOfWeek:
		return m.OldFrequencyDayOfWeek(ctx)
	case event.FieldFrequencyDayOfMonth:
		return m.OldFrequencyDayOfMonth(ctx)
	case event.FieldFrequencyMonthOfYear:
		return m.OldFrequencyMonthOfYear(ctx)
	case event.FieldVenueType:
		return m.OldVenueType(ctx)
	case event.FieldVenueName:
		return m.OldVenueName(ctx)
	case event.FieldVenueAddress:
		return m.OldVenueAddress(ctx)
	case event.FieldVenueCity:
		return m.OldVenueCity(ctx)
	case event.FieldVenueState:
		return m.OldVenueState(ctx)
	case event.FieldVenueCountry:
		return m.OldVenueCountry(ctx)
	case event.FieldVenueZip:
		return m.OldVenueZip(ctx)
	case event.FieldVenueLat:
		return m.OldVenueLat(ctx)
	case event.FieldVenueLon:
		return m.OldVenueLon(ctx)
	case event.FieldVenueURL:
		return m.OldVenueURL(ctx)
	case event.FieldVenuePhone:
		return m.OldVenuePhone(ctx)
	case event.FieldVenueEmail:
		return m.OldVenueEmail(ctx)
	case event.FieldTags:
		return m.OldTags(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldEventSettings:
		return m.OldEventSettings(ctx)
	case event.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldMapCoordinates:
		return m.OldMapCoordinates(ctx)
	case event.FieldLongitude:
		return m.OldLongitude(ctx)
	case event.FieldLatitude:
		return m.OldLatitude(ctx)
	case event.FieldSearchText:
		return m.OldSearchText(ctx)
	case event.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	case event.FieldFollowerCount:
		return m.OldFollowerCount(ctx)
	case event.FieldFollowingCount:
		return m.OldFollowingCount(ctx)
	case event.FieldIsPremium:
		return m.OldIsPremium(ctx)
	case event.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case event.FieldIsOnline:
		return m.OldIsOnline(ctx)
	case event.FieldIsFree:
		return m.OldIsFree(ctx)
	case event.FieldIsPaid:
		return m.OldIsPaid(ctx)
	case event.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case event.FieldIsOnlineOnly:
		return m.OldIsOnlineOnly(ctx)
	case event.FieldIsInPersonOnly:
		return m.OldIsInPersonOnly(ctx)
	case event.FieldIsHybrid:
		return m.OldIsHybrid(ctx)
	case event.FieldIsOnlineAndInPerson:
		return m.OldIsOnlineAndInPerson(ctx)
	case event.FieldIsOnlineAndInPersonOnly:
		return m.OldIsOnlineAndInPersonOnly(ctx)
	case event.FieldIsOnlineAndInPersonOrHybrid:
		return m.OldIsOnlineAndInPersonOrHybrid(ctx)
	case event.FieldLikedByCurrentUser:
		return m.OldLikedByCurrentUser(ctx)
	case event.FieldFollowedByCurrentUser:
		return m.OldFollowedByCurrentUser(ctx)
	case event.FieldRegistrationType:
		return m.OldRegistrationType(ctx)
	case event.FieldRegistrationURL:
		return m.OldRegistrationURL(ctx)
	case event.FieldIsPhysicallyAccessible:
		return m.OldIsPhysicallyAccessible(ctx)
	case event.FieldAccessibilityInfo:
		return m.OldAccessibilityInfo(ctx)
	case event.FieldIsVirtuallyAccessible:
		return m.OldIsVirtuallyAccessible(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(event.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case event.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case event.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case event.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case event.FieldTimeZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeZone(v)
		return nil
	case event.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case event.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case event.FieldStartDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case event.FieldEndDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case event.FieldFrequency:
		v, ok := value.(event.Frequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case event.FieldFrequencyInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequencyInterval(v)
		return nil
	case event.FieldFrequencyDayOfWeek:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequencyDayOfWeek(v)
		return nil
	case event.FieldFrequencyDayOfMonth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequencyDayOfMonth(v)
		return nil
	case event.FieldFrequencyMonthOfYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequencyMonthOfYear(v)
		return nil
	case event.FieldVenueType:
		v, ok := value.(event.VenueType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueType(v)
		return nil
	case event.FieldVenueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueName(v)
		return nil
	case event.FieldVenueAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueAddress(v)
		return nil
	case event.FieldVenueCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueCity(v)
		return nil
	case event.FieldVenueState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueState(v)
		return nil
	case event.FieldVenueCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueCountry(v)
		return nil
	case event.FieldVenueZip:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueZip(v)
		return nil
	case event.FieldVenueLat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueLat(v)
		return nil
	case event.FieldVenueLon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueLon(v)
		return nil
	case event.FieldVenueURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueURL(v)
		return nil
	case event.FieldVenuePhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenuePhone(v)
		return nil
	case event.FieldVenueEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueEmail(v)
		return nil
	case event.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldEventSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventSettings(v)
		return nil
	case event.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldMapCoordinates:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapCoordinates(v)
		return nil
	case event.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case event.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case event.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	case event.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	case event.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerCount(v)
		return nil
	case event.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingCount(v)
		return nil
	case event.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	case event.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case event.FieldIsOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnline(v)
		return nil
	case event.FieldIsFree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFree(v)
		return nil
	case event.FieldIsPaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPaid(v)
		return nil
	case event.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case event.FieldIsOnlineOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnlineOnly(v)
		return nil
	case event.FieldIsInPersonOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInPersonOnly(v)
		return nil
	case event.FieldIsHybrid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHybrid(v)
		return nil
	case event.FieldIsOnlineAndInPerson:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnlineAndInPerson(v)
		return nil
	case event.FieldIsOnlineAndInPersonOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnlineAndInPersonOnly(v)
		return nil
	case event.FieldIsOnlineAndInPersonOrHybrid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnlineAndInPersonOrHybrid(v)
		return nil
	case event.FieldLikedByCurrentUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedByCurrentUser(v)
		return nil
	case event.FieldFollowedByCurrentUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowedByCurrentUser(v)
		return nil
	case event.FieldRegistrationType:
		v, ok := value.(event.RegistrationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationType(v)
		return nil
	case event.FieldRegistrationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationURL(v)
		return nil
	case event.FieldIsPhysicallyAccessible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPhysicallyAccessible(v)
		return nil
	case event.FieldAccessibilityInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessibilityInfo(v)
		return nil
	case event.FieldIsVirtuallyAccessible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVirtuallyAccessible(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addrelevance_score != nil {
		fields = append(fields, event.FieldRelevanceScore)
	}
	if m.addfollower_count != nil {
		fields = append(fields, event.FieldFollowerCount)
	}
	if m.addfollowing_count != nil {
		fields = append(fields, event.FieldFollowingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	case event.FieldFollowerCount:
		return m.AddedFollowerCount()
	case event.FieldFollowingCount:
		return m.AddedFollowingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	case event.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowerCount(v)
		return nil
	case event.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldName) {
		fields = append(fields, event.FieldName)
	}
	if m.FieldCleared(event.FieldEventType) {
		fields = append(fields, event.FieldEventType)
	}
	if m.FieldCleared(event.FieldStatus) {
		fields = append(fields, event.FieldStatus)
	}
	if m.FieldCleared(event.FieldLocation) {
		fields = append(fields, event.FieldLocation)
	}
	if m.FieldCleared(event.FieldURL) {
		fields = append(fields, event.FieldURL)
	}
	if m.FieldCleared(event.FieldTitle) {
		fields = append(fields, event.FieldTitle)
	}
	if m.FieldCleared(event.FieldTimeZone) {
		fields = append(fields, event.FieldTimeZone)
	}
	if m.FieldCleared(event.FieldStartTime) {
		fields = append(fields, event.FieldStartTime)
	}
	if m.FieldCleared(event.FieldEndTime) {
		fields = append(fields, event.FieldEndTime)
	}
	if m.FieldCleared(event.FieldStartDate) {
		fields = append(fields, event.FieldStartDate)
	}
	if m.FieldCleared(event.FieldEndDate) {
		fields = append(fields, event.FieldEndDate)
	}
	if m.FieldCleared(event.FieldFrequency) {
		fields = append(fields, event.FieldFrequency)
	}
	if m.FieldCleared(event.FieldFrequencyInterval) {
		fields = append(fields, event.FieldFrequencyInterval)
	}
	if m.FieldCleared(event.FieldFrequencyDayOfWeek) {
		fields = append(fields, event.FieldFrequencyDayOfWeek)
	}
	if m.FieldCleared(event.FieldFrequencyDayOfMonth) {
		fields = append(fields, event.FieldFrequencyDayOfMonth)
	}
	if m.FieldCleared(event.FieldFrequencyMonthOfYear) {
		fields = append(fields, event.FieldFrequencyMonthOfYear)
	}
	if m.FieldCleared(event.FieldVenueType) {
		fields = append(fields, event.FieldVenueType)
	}
	if m.FieldCleared(event.FieldVenueName) {
		fields = append(fields, event.FieldVenueName)
	}
	if m.FieldCleared(event.FieldVenueAddress) {
		fields = append(fields, event.FieldVenueAddress)
	}
	if m.FieldCleared(event.FieldVenueCity) {
		fields = append(fields, event.FieldVenueCity)
	}
	if m.FieldCleared(event.FieldVenueState) {
		fields = append(fields, event.FieldVenueState)
	}
	if m.FieldCleared(event.FieldVenueCountry) {
		fields = append(fields, event.FieldVenueCountry)
	}
	if m.FieldCleared(event.FieldVenueZip) {
		fields = append(fields, event.FieldVenueZip)
	}
	if m.FieldCleared(event.FieldVenueLat) {
		fields = append(fields, event.FieldVenueLat)
	}
	if m.FieldCleared(event.FieldVenueLon) {
		fields = append(fields, event.FieldVenueLon)
	}
	if m.FieldCleared(event.FieldVenueURL) {
		fields = append(fields, event.FieldVenueURL)
	}
	if m.FieldCleared(event.FieldVenuePhone) {
		fields = append(fields, event.FieldVenuePhone)
	}
	if m.FieldCleared(event.FieldVenueEmail) {
		fields = append(fields, event.FieldVenueEmail)
	}
	if m.FieldCleared(event.FieldTags) {
		fields = append(fields, event.FieldTags)
	}
	if m.FieldCleared(event.FieldDescription) {
		fields = append(fields, event.FieldDescription)
	}
	if m.FieldCleared(event.FieldEventSettings) {
		fields = append(fields, event.FieldEventSettings)
	}
	if m.FieldCleared(event.FieldCoverImage) {
		fields = append(fields, event.FieldCoverImage)
	}
	if m.FieldCleared(event.FieldMapCoordinates) {
		fields = append(fields, event.FieldMapCoordinates)
	}
	if m.FieldCleared(event.FieldLongitude) {
		fields = append(fields, event.FieldLongitude)
	}
	if m.FieldCleared(event.FieldLatitude) {
		fields = append(fields, event.FieldLatitude)
	}
	if m.FieldCleared(event.FieldSearchText) {
		fields = append(fields, event.FieldSearchText)
	}
	if m.FieldCleared(event.FieldRelevanceScore) {
		fields = append(fields, event.FieldRelevanceScore)
	}
	if m.FieldCleared(event.FieldRegistrationType) {
		fields = append(fields, event.FieldRegistrationType)
	}
	if m.FieldCleared(event.FieldRegistrationURL) {
		fields = append(fields, event.FieldRegistrationURL)
	}
	if m.FieldCleared(event.FieldAccessibilityInfo) {
		fields = append(fields, event.FieldAccessibilityInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldName:
		m.ClearName()
		return nil
	case event.FieldEventType:
		m.ClearEventType()
		return nil
	case event.FieldStatus:
		m.ClearStatus()
		return nil
	case event.FieldLocation:
		m.ClearLocation()
		return nil
	case event.FieldURL:
		m.ClearURL()
		return nil
	case event.FieldTitle:
		m.ClearTitle()
		return nil
	case event.FieldTimeZone:
		m.ClearTimeZone()
		return nil
	case event.FieldStartTime:
		m.ClearStartTime()
		return nil
	case event.FieldEndTime:
		m.ClearEndTime()
		return nil
	case event.FieldStartDate:
		m.ClearStartDate()
		return nil
	case event.FieldEndDate:
		m.ClearEndDate()
		return nil
	case event.FieldFrequency:
		m.ClearFrequency()
		return nil
	case event.FieldFrequencyInterval:
		m.ClearFrequencyInterval()
		return nil
	case event.FieldFrequencyDayOfWeek:
		m.ClearFrequencyDayOfWeek()
		return nil
	case event.FieldFrequencyDayOfMonth:
		m.ClearFrequencyDayOfMonth()
		return nil
	case event.FieldFrequencyMonthOfYear:
		m.ClearFrequencyMonthOfYear()
		return nil
	case event.FieldVenueType:
		m.ClearVenueType()
		return nil
	case event.FieldVenueName:
		m.ClearVenueName()
		return nil
	case event.FieldVenueAddress:
		m.ClearVenueAddress()
		return nil
	case event.FieldVenueCity:
		m.ClearVenueCity()
		return nil
	case event.FieldVenueState:
		m.ClearVenueState()
		return nil
	case event.FieldVenueCountry:
		m.ClearVenueCountry()
		return nil
	case event.FieldVenueZip:
		m.ClearVenueZip()
		return nil
	case event.FieldVenueLat:
		m.ClearVenueLat()
		return nil
	case event.FieldVenueLon:
		m.ClearVenueLon()
		return nil
	case event.FieldVenueURL:
		m.ClearVenueURL()
		return nil
	case event.FieldVenuePhone:
		m.ClearVenuePhone()
		return nil
	case event.FieldVenueEmail:
		m.ClearVenueEmail()
		return nil
	case event.FieldTags:
		m.ClearTags()
		return nil
	case event.FieldDescription:
		m.ClearDescription()
		return nil
	case event.FieldEventSettings:
		m.ClearEventSettings()
		return nil
	case event.FieldCoverImage:
		m.ClearCoverImage()
		return nil
	case event.FieldMapCoordinates:
		m.ClearMapCoordinates()
		return nil
	case event.FieldLongitude:
		m.ClearLongitude()
		return nil
	case event.FieldLatitude:
		m.ClearLatitude()
		return nil
	case event.FieldSearchText:
		m.ClearSearchText()
		return nil
	case event.FieldRelevanceScore:
		m.ClearRelevanceScore()
		return nil
	case event.FieldRegistrationType:
		m.ClearRegistrationType()
		return nil
	case event.FieldRegistrationURL:
		m.ClearRegistrationURL()
		return nil
	case event.FieldAccessibilityInfo:
		m.ClearAccessibilityInfo()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldName:
		m.ResetName()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldStatus:
		m.ResetStatus()
		return nil
	case event.FieldLocation:
		m.ResetLocation()
		return nil
	case event.FieldURL:
		m.ResetURL()
		return nil
	case event.FieldTitle:
		m.ResetTitle()
		return nil
	case event.FieldTimeZone:
		m.ResetTimeZone()
		return nil
	case event.FieldStartTime:
		m.ResetStartTime()
		return nil
	case event.FieldEndTime:
		m.ResetEndTime()
		return nil
	case event.FieldStartDate:
		m.ResetStartDate()
		return nil
	case event.FieldEndDate:
		m.ResetEndDate()
		return nil
	case event.FieldFrequency:
		m.ResetFrequency()
		return nil
	case event.FieldFrequencyInterval:
		m.ResetFrequencyInterval()
		return nil
	case event.FieldFrequencyDayOfWeek:
		m.ResetFrequencyDayOfWeek()
		return nil
	case event.FieldFrequencyDayOfMonth:
		m.ResetFrequencyDayOfMonth()
		return nil
	case event.FieldFrequencyMonthOfYear:
		m.ResetFrequencyMonthOfYear()
		return nil
	case event.FieldVenueType:
		m.ResetVenueType()
		return nil
	case event.FieldVenueName:
		m.ResetVenueName()
		return nil
	case event.FieldVenueAddress:
		m.ResetVenueAddress()
		return nil
	case event.FieldVenueCity:
		m.ResetVenueCity()
		return nil
	case event.FieldVenueState:
		m.ResetVenueState()
		return nil
	case event.FieldVenueCountry:
		m.ResetVenueCountry()
		return nil
	case event.FieldVenueZip:
		m.ResetVenueZip()
		return nil
	case event.FieldVenueLat:
		m.ResetVenueLat()
		return nil
	case event.FieldVenueLon:
		m.ResetVenueLon()
		return nil
	case event.FieldVenueURL:
		m.ResetVenueURL()
		return nil
	case event.FieldVenuePhone:
		m.ResetVenuePhone()
		return nil
	case event.FieldVenueEmail:
		m.ResetVenueEmail()
		return nil
	case event.FieldTags:
		m.ResetTags()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldEventSettings:
		m.ResetEventSettings()
		return nil
	case event.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldMapCoordinates:
		m.ResetMapCoordinates()
		return nil
	case event.FieldLongitude:
		m.ResetLongitude()
		return nil
	case event.FieldLatitude:
		m.ResetLatitude()
		return nil
	case event.FieldSearchText:
		m.ResetSearchText()
		return nil
	case event.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	case event.FieldFollowerCount:
		m.ResetFollowerCount()
		return nil
	case event.FieldFollowingCount:
		m.ResetFollowingCount()
		return nil
	case event.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	case event.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case event.FieldIsOnline:
		m.ResetIsOnline()
		return nil
	case event.FieldIsFree:
		m.ResetIsFree()
		return nil
	case event.FieldIsPaid:
		m.ResetIsPaid()
		return nil
	case event.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case event.FieldIsOnlineOnly:
		m.ResetIsOnlineOnly()
		return nil
	case event.FieldIsInPersonOnly:
		m.ResetIsInPersonOnly()
		return nil
	case event.FieldIsHybrid:
		m.ResetIsHybrid()
		return nil
	case event.FieldIsOnlineAndInPerson:
		m.ResetIsOnlineAndInPerson()
		return nil
	case event.FieldIsOnlineAndInPersonOnly:
		m.ResetIsOnlineAndInPersonOnly()
		return nil
	case event.FieldIsOnlineAndInPersonOrHybrid:
		m.ResetIsOnlineAndInPersonOrHybrid()
		return nil
	case event.FieldLikedByCurrentUser:
		m.ResetLikedByCurrentUser()
		return nil
	case event.FieldFollowedByCurrentUser:
		m.ResetFollowedByCurrentUser()
		return nil
	case event.FieldRegistrationType:
		m.ResetRegistrationType()
		return nil
	case event.FieldRegistrationURL:
		m.ResetRegistrationURL()
		return nil
	case event.FieldIsPhysicallyAccessible:
		m.ResetIsPhysicallyAccessible()
		return nil
	case event.FieldAccessibilityInfo:
		m.ResetAccessibilityInfo()
		return nil
	case event.FieldIsVirtuallyAccessible:
		m.ResetIsVirtuallyAccessible()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.tickets != nil {
		edges = append(edges, event.EdgeTickets)
	}
	if m.ticket_options != nil {
		edges = append(edges, event.EdgeTicketOptions)
	}
	if m.place != nil {
		edges = append(edges, event.EdgePlace)
	}
	if m.event_categories != nil {
		edges = append(edges, event.EdgeEventCategories)
	}
	if m.event_category_assignments != nil {
		edges = append(edges, event.EdgeEventCategoryAssignments)
	}
	if m.ownerUser != nil {
		edges = append(edges, event.EdgeOwnerUser)
	}
	if m.ownerBusiness != nil {
		edges = append(edges, event.EdgeOwnerBusiness)
	}
	if m.userFollowers != nil {
		edges = append(edges, event.EdgeUserFollowers)
	}
	if m.businessFollowers != nil {
		edges = append(edges, event.EdgeBusinessFollowers)
	}
	if m.faqs != nil {
		edges = append(edges, event.EdgeFaqs)
	}
	if m.ratings != nil {
		edges = append(edges, event.EdgeRatings)
	}
	if m.additional_organizers != nil {
		edges = append(edges, event.EdgeAdditionalOrganizers)
	}
	if m.media != nil {
		edges = append(edges, event.EdgeMedia)
	}
	if m.event_comments != nil {
		edges = append(edges, event.EdgeEventComments)
	}
	if m.event_reviews != nil {
		edges = append(edges, event.EdgeEventReviews)
	}
	if m.performers != nil {
		edges = append(edges, event.EdgePerformers)
	}
	if m.event_organizers != nil {
		edges = append(edges, event.EdgeEventOrganizers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.ticket_options))
		for id := range m.ticket_options {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventCategories:
		ids := make([]ent.Value, 0, len(m.event_categories))
		for id := range m.event_categories {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.event_category_assignments))
		for id := range m.event_category_assignments {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOwnerUser:
		if id := m.ownerUser; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeOwnerBusiness:
		if id := m.ownerBusiness; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeUserFollowers:
		ids := make([]ent.Value, 0, len(m.userFollowers))
		for id := range m.userFollowers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeBusinessFollowers:
		ids := make([]ent.Value, 0, len(m.businessFollowers))
		for id := range m.businessFollowers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeFaqs:
		ids := make([]ent.Value, 0, len(m.faqs))
		for id := range m.faqs {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.ratings))
		for id := range m.ratings {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeAdditionalOrganizers:
		ids := make([]ent.Value, 0, len(m.additional_organizers))
		for id := range m.additional_organizers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventComments:
		ids := make([]ent.Value, 0, len(m.event_comments))
		for id := range m.event_comments {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventReviews:
		ids := make([]ent.Value, 0, len(m.event_reviews))
		for id := range m.event_reviews {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePerformers:
		ids := make([]ent.Value, 0, len(m.performers))
		for id := range m.performers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventOrganizers:
		ids := make([]ent.Value, 0, len(m.event_organizers))
		for id := range m.event_organizers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedtickets != nil {
		edges = append(edges, event.EdgeTickets)
	}
	if m.removedticket_options != nil {
		edges = append(edges, event.EdgeTicketOptions)
	}
	if m.removedplace != nil {
		edges = append(edges, event.EdgePlace)
	}
	if m.removedevent_categories != nil {
		edges = append(edges, event.EdgeEventCategories)
	}
	if m.removedevent_category_assignments != nil {
		edges = append(edges, event.EdgeEventCategoryAssignments)
	}
	if m.removeduserFollowers != nil {
		edges = append(edges, event.EdgeUserFollowers)
	}
	if m.removedbusinessFollowers != nil {
		edges = append(edges, event.EdgeBusinessFollowers)
	}
	if m.removedfaqs != nil {
		edges = append(edges, event.EdgeFaqs)
	}
	if m.removedratings != nil {
		edges = append(edges, event.EdgeRatings)
	}
	if m.removedadditional_organizers != nil {
		edges = append(edges, event.EdgeAdditionalOrganizers)
	}
	if m.removedmedia != nil {
		edges = append(edges, event.EdgeMedia)
	}
	if m.removedevent_comments != nil {
		edges = append(edges, event.EdgeEventComments)
	}
	if m.removedevent_reviews != nil {
		edges = append(edges, event.EdgeEventReviews)
	}
	if m.removedperformers != nil {
		edges = append(edges, event.EdgePerformers)
	}
	if m.removedevent_organizers != nil {
		edges = append(edges, event.EdgeEventOrganizers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.removedticket_options))
		for id := range m.removedticket_options {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventCategories:
		ids := make([]ent.Value, 0, len(m.removedevent_categories))
		for id := range m.removedevent_categories {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedevent_category_assignments))
		for id := range m.removedevent_category_assignments {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeUserFollowers:
		ids := make([]ent.Value, 0, len(m.removeduserFollowers))
		for id := range m.removeduserFollowers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeBusinessFollowers:
		ids := make([]ent.Value, 0, len(m.removedbusinessFollowers))
		for id := range m.removedbusinessFollowers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeFaqs:
		ids := make([]ent.Value, 0, len(m.removedfaqs))
		for id := range m.removedfaqs {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.removedratings))
		for id := range m.removedratings {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeAdditionalOrganizers:
		ids := make([]ent.Value, 0, len(m.removedadditional_organizers))
		for id := range m.removedadditional_organizers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventComments:
		ids := make([]ent.Value, 0, len(m.removedevent_comments))
		for id := range m.removedevent_comments {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventReviews:
		ids := make([]ent.Value, 0, len(m.removedevent_reviews))
		for id := range m.removedevent_reviews {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePerformers:
		ids := make([]ent.Value, 0, len(m.removedperformers))
		for id := range m.removedperformers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventOrganizers:
		ids := make([]ent.Value, 0, len(m.removedevent_organizers))
		for id := range m.removedevent_organizers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedtickets {
		edges = append(edges, event.EdgeTickets)
	}
	if m.clearedticket_options {
		edges = append(edges, event.EdgeTicketOptions)
	}
	if m.clearedplace {
		edges = append(edges, event.EdgePlace)
	}
	if m.clearedevent_categories {
		edges = append(edges, event.EdgeEventCategories)
	}
	if m.clearedevent_category_assignments {
		edges = append(edges, event.EdgeEventCategoryAssignments)
	}
	if m.clearedownerUser {
		edges = append(edges, event.EdgeOwnerUser)
	}
	if m.clearedownerBusiness {
		edges = append(edges, event.EdgeOwnerBusiness)
	}
	if m.cleareduserFollowers {
		edges = append(edges, event.EdgeUserFollowers)
	}
	if m.clearedbusinessFollowers {
		edges = append(edges, event.EdgeBusinessFollowers)
	}
	if m.clearedfaqs {
		edges = append(edges, event.EdgeFaqs)
	}
	if m.clearedratings {
		edges = append(edges, event.EdgeRatings)
	}
	if m.clearedadditional_organizers {
		edges = append(edges, event.EdgeAdditionalOrganizers)
	}
	if m.clearedmedia {
		edges = append(edges, event.EdgeMedia)
	}
	if m.clearedevent_comments {
		edges = append(edges, event.EdgeEventComments)
	}
	if m.clearedevent_reviews {
		edges = append(edges, event.EdgeEventReviews)
	}
	if m.clearedperformers {
		edges = append(edges, event.EdgePerformers)
	}
	if m.clearedevent_organizers {
		edges = append(edges, event.EdgeEventOrganizers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeTickets:
		return m.clearedtickets
	case event.EdgeTicketOptions:
		return m.clearedticket_options
	case event.EdgePlace:
		return m.clearedplace
	case event.EdgeEventCategories:
		return m.clearedevent_categories
	case event.EdgeEventCategoryAssignments:
		return m.clearedevent_category_assignments
	case event.EdgeOwnerUser:
		return m.clearedownerUser
	case event.EdgeOwnerBusiness:
		return m.clearedownerBusiness
	case event.EdgeUserFollowers:
		return m.cleareduserFollowers
	case event.EdgeBusinessFollowers:
		return m.clearedbusinessFollowers
	case event.EdgeFaqs:
		return m.clearedfaqs
	case event.EdgeRatings:
		return m.clearedratings
	case event.EdgeAdditionalOrganizers:
		return m.clearedadditional_organizers
	case event.EdgeMedia:
		return m.clearedmedia
	case event.EdgeEventComments:
		return m.clearedevent_comments
	case event.EdgeEventReviews:
		return m.clearedevent_reviews
	case event.EdgePerformers:
		return m.clearedperformers
	case event.EdgeEventOrganizers:
		return m.clearedevent_organizers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeOwnerUser:
		m.ClearOwnerUser()
		return nil
	case event.EdgeOwnerBusiness:
		m.ClearOwnerBusiness()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeTickets:
		m.ResetTickets()
		return nil
	case event.EdgeTicketOptions:
		m.ResetTicketOptions()
		return nil
	case event.EdgePlace:
		m.ResetPlace()
		return nil
	case event.EdgeEventCategories:
		m.ResetEventCategories()
		return nil
	case event.EdgeEventCategoryAssignments:
		m.ResetEventCategoryAssignments()
		return nil
	case event.EdgeOwnerUser:
		m.ResetOwnerUser()
		return nil
	case event.EdgeOwnerBusiness:
		m.ResetOwnerBusiness()
		return nil
	case event.EdgeUserFollowers:
		m.ResetUserFollowers()
		return nil
	case event.EdgeBusinessFollowers:
		m.ResetBusinessFollowers()
		return nil
	case event.EdgeFaqs:
		m.ResetFaqs()
		return nil
	case event.EdgeRatings:
		m.ResetRatings()
		return nil
	case event.EdgeAdditionalOrganizers:
		m.ResetAdditionalOrganizers()
		return nil
	case event.EdgeMedia:
		m.ResetMedia()
		return nil
	case event.EdgeEventComments:
		m.ResetEventComments()
		return nil
	case event.EdgeEventReviews:
		m.ResetEventReviews()
		return nil
	case event.EdgePerformers:
		m.ResetPerformers()
		return nil
	case event.EdgeEventOrganizers:
		m.ResetEventOrganizers()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventOrganizerMutation represents an operation that mutates the EventOrganizer nodes in the graph.
type EventOrganizerMutation struct {
	config
	op            Op
	typ           string
	id            *string
	organizerID   *string
	organizerType *string
	clearedFields map[string]struct{}
	event         *string
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*EventOrganizer, error)
	predicates    []predicate.EventOrganizer
}

var _ ent.Mutation = (*EventOrganizerMutation)(nil)

// eventorganizerOption allows management of the mutation configuration using functional options.
type eventorganizerOption func(*EventOrganizerMutation)

// newEventOrganizerMutation creates new mutation for the EventOrganizer entity.
func newEventOrganizerMutation(c config, op Op, opts ...eventorganizerOption) *EventOrganizerMutation {
	m := &EventOrganizerMutation{
		config:        c,
		op:            op,
		typ:           TypeEventOrganizer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventOrganizerID sets the ID field of the mutation.
func withEventOrganizerID(id string) eventorganizerOption {
	return func(m *EventOrganizerMutation) {
		var (
			err   error
			once  sync.Once
			value *EventOrganizer
		)
		m.oldValue = func(ctx context.Context) (*EventOrganizer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventOrganizer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventOrganizer sets the old EventOrganizer of the mutation.
func withEventOrganizer(node *EventOrganizer) eventorganizerOption {
	return func(m *EventOrganizerMutation) {
		m.oldValue = func(context.Context) (*EventOrganizer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventOrganizerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventOrganizerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventOrganizerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventOrganizerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventOrganizer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizerID sets the "organizerID" field.
func (m *EventOrganizerMutation) SetOrganizerID(s string) {
	m.organizerID = &s
}

// OrganizerID returns the value of the "organizerID" field in the mutation.
func (m *EventOrganizerMutation) OrganizerID() (r string, exists bool) {
	v := m.organizerID
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizerID returns the old "organizerID" field's value of the EventOrganizer entity.
// If the EventOrganizer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventOrganizerMutation) OldOrganizerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizerID: %w", err)
	}
	return oldValue.OrganizerID, nil
}

// ResetOrganizerID resets all changes to the "organizerID" field.
func (m *EventOrganizerMutation) ResetOrganizerID() {
	m.organizerID = nil
}

// SetOrganizerType sets the "organizerType" field.
func (m *EventOrganizerMutation) SetOrganizerType(s string) {
	m.organizerType = &s
}

// OrganizerType returns the value of the "organizerType" field in the mutation.
func (m *EventOrganizerMutation) OrganizerType() (r string, exists bool) {
	v := m.organizerType
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizerType returns the old "organizerType" field's value of the EventOrganizer entity.
// If the EventOrganizer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventOrganizerMutation) OldOrganizerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizerType: %w", err)
	}
	return oldValue.OrganizerType, nil
}

// ResetOrganizerType resets all changes to the "organizerType" field.
func (m *EventOrganizerMutation) ResetOrganizerType() {
	m.organizerType = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *EventOrganizerMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventOrganizerMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventOrganizerMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *EventOrganizerMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventOrganizerMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventOrganizerMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the EventOrganizerMutation builder.
func (m *EventOrganizerMutation) Where(ps ...predicate.EventOrganizer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventOrganizerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventOrganizerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventOrganizer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventOrganizerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventOrganizerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventOrganizer).
func (m *EventOrganizerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventOrganizerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.organizerID != nil {
		fields = append(fields, eventorganizer.FieldOrganizerID)
	}
	if m.organizerType != nil {
		fields = append(fields, eventorganizer.FieldOrganizerType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventOrganizerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventorganizer.FieldOrganizerID:
		return m.OrganizerID()
	case eventorganizer.FieldOrganizerType:
		return m.OrganizerType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventOrganizerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventorganizer.FieldOrganizerID:
		return m.OldOrganizerID(ctx)
	case eventorganizer.FieldOrganizerType:
		return m.OldOrganizerType(ctx)
	}
	return nil, fmt.Errorf("unknown EventOrganizer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventOrganizerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventorganizer.FieldOrganizerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizerID(v)
		return nil
	case eventorganizer.FieldOrganizerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizerType(v)
		return nil
	}
	return fmt.Errorf("unknown EventOrganizer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventOrganizerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventOrganizerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventOrganizerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventOrganizer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventOrganizerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventOrganizerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventOrganizerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventOrganizer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventOrganizerMutation) ResetField(name string) error {
	switch name {
	case eventorganizer.FieldOrganizerID:
		m.ResetOrganizerID()
		return nil
	case eventorganizer.FieldOrganizerType:
		m.ResetOrganizerType()
		return nil
	}
	return fmt.Errorf("unknown EventOrganizer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventOrganizerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, eventorganizer.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventOrganizerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventorganizer.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventOrganizerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventOrganizerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventOrganizerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, eventorganizer.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventOrganizerMutation) EdgeCleared(name string) bool {
	switch name {
	case eventorganizer.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventOrganizerMutation) ClearEdge(name string) error {
	switch name {
	case eventorganizer.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown EventOrganizer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventOrganizerMutation) ResetEdge(name string) error {
	switch name {
	case eventorganizer.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown EventOrganizer edge %s", name)
}

// FAQMutation represents an operation that mutates the FAQ nodes in the graph.
type FAQMutation struct {
	config
	op              Op
	typ             string
	id              *string
	question        *string
	answer          *string
	clearedFields   map[string]struct{}
	business        *string
	clearedbusiness bool
	place           map[string]struct{}
	removedplace    map[string]struct{}
	clearedplace    bool
	event           map[string]struct{}
	removedevent    map[string]struct{}
	clearedevent    bool
	done            bool
	oldValue        func(context.Context) (*FAQ, error)
	predicates      []predicate.FAQ
}

var _ ent.Mutation = (*FAQMutation)(nil)

// faqOption allows management of the mutation configuration using functional options.
type faqOption func(*FAQMutation)

// newFAQMutation creates new mutation for the FAQ entity.
func newFAQMutation(c config, op Op, opts ...faqOption) *FAQMutation {
	m := &FAQMutation{
		config:        c,
		op:            op,
		typ:           TypeFAQ,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFAQID sets the ID field of the mutation.
func withFAQID(id string) faqOption {
	return func(m *FAQMutation) {
		var (
			err   error
			once  sync.Once
			value *FAQ
		)
		m.oldValue = func(ctx context.Context) (*FAQ, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FAQ.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFAQ sets the old FAQ of the mutation.
func withFAQ(node *FAQ) faqOption {
	return func(m *FAQMutation) {
		m.oldValue = func(context.Context) (*FAQ, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FAQMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FAQMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FAQ entities.
func (m *FAQMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FAQMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FAQMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FAQ.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuestion sets the "question" field.
func (m *FAQMutation) SetQuestion(s string) {
	m.question = &s
}

// Question returns the value of the "question" field in the mutation.
func (m *FAQMutation) Question() (r string, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestion returns the old "question" field's value of the FAQ entity.
// If the FAQ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FAQMutation) OldQuestion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestion: %w", err)
	}
	return oldValue.Question, nil
}

// ResetQuestion resets all changes to the "question" field.
func (m *FAQMutation) ResetQuestion() {
	m.question = nil
}

// SetAnswer sets the "answer" field.
func (m *FAQMutation) SetAnswer(s string) {
	m.answer = &s
}

// Answer returns the value of the "answer" field in the mutation.
func (m *FAQMutation) Answer() (r string, exists bool) {
	v := m.answer
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswer returns the old "answer" field's value of the FAQ entity.
// If the FAQ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FAQMutation) OldAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswer: %w", err)
	}
	return oldValue.Answer, nil
}

// ResetAnswer resets all changes to the "answer" field.
func (m *FAQMutation) ResetAnswer() {
	m.answer = nil
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *FAQMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *FAQMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *FAQMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *FAQMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *FAQMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *FAQMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *FAQMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *FAQMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *FAQMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *FAQMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *FAQMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *FAQMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *FAQMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *FAQMutation) AddEventIDs(ids ...string) {
	if m.event == nil {
		m.event = make(map[string]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *FAQMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *FAQMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *FAQMutation) RemoveEventIDs(ids ...string) {
	if m.removedevent == nil {
		m.removedevent = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *FAQMutation) RemovedEventIDs() (ids []string) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *FAQMutation) EventIDs() (ids []string) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *FAQMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// Where appends a list predicates to the FAQMutation builder.
func (m *FAQMutation) Where(ps ...predicate.FAQ) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FAQMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FAQMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FAQ, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FAQMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FAQMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FAQ).
func (m *FAQMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FAQMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.question != nil {
		fields = append(fields, faq.FieldQuestion)
	}
	if m.answer != nil {
		fields = append(fields, faq.FieldAnswer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FAQMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faq.FieldQuestion:
		return m.Question()
	case faq.FieldAnswer:
		return m.Answer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FAQMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faq.FieldQuestion:
		return m.OldQuestion(ctx)
	case faq.FieldAnswer:
		return m.OldAnswer(ctx)
	}
	return nil, fmt.Errorf("unknown FAQ field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FAQMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faq.FieldQuestion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestion(v)
		return nil
	case faq.FieldAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswer(v)
		return nil
	}
	return fmt.Errorf("unknown FAQ field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FAQMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FAQMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FAQMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FAQ numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FAQMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FAQMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FAQMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FAQ nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FAQMutation) ResetField(name string) error {
	switch name {
	case faq.FieldQuestion:
		m.ResetQuestion()
		return nil
	case faq.FieldAnswer:
		m.ResetAnswer()
		return nil
	}
	return fmt.Errorf("unknown FAQ field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FAQMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business != nil {
		edges = append(edges, faq.EdgeBusiness)
	}
	if m.place != nil {
		edges = append(edges, faq.EdgePlace)
	}
	if m.event != nil {
		edges = append(edges, faq.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FAQMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case faq.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case faq.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case faq.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FAQMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplace != nil {
		edges = append(edges, faq.EdgePlace)
	}
	if m.removedevent != nil {
		edges = append(edges, faq.EdgeEvent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FAQMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case faq.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case faq.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FAQMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness {
		edges = append(edges, faq.EdgeBusiness)
	}
	if m.clearedplace {
		edges = append(edges, faq.EdgePlace)
	}
	if m.clearedevent {
		edges = append(edges, faq.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FAQMutation) EdgeCleared(name string) bool {
	switch name {
	case faq.EdgeBusiness:
		return m.clearedbusiness
	case faq.EdgePlace:
		return m.clearedplace
	case faq.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FAQMutation) ClearEdge(name string) error {
	switch name {
	case faq.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown FAQ unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FAQMutation) ResetEdge(name string) error {
	switch name {
	case faq.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case faq.EdgePlace:
		m.ResetPlace()
		return nil
	case faq.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown FAQ edge %s", name)
}

// FeatureReleaseMutation represents an operation that mutates the FeatureRelease nodes in the graph.
type FeatureReleaseMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	feature_name       *string
	description        *string
	state              *featurerelease.State
	release_date       *time.Time
	eligibility_rules  *map[string]interface{}
	documentation_link *string
	metadata           *map[string]interface{}
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*FeatureRelease, error)
	predicates         []predicate.FeatureRelease
}

var _ ent.Mutation = (*FeatureReleaseMutation)(nil)

// featurereleaseOption allows management of the mutation configuration using functional options.
type featurereleaseOption func(*FeatureReleaseMutation)

// newFeatureReleaseMutation creates new mutation for the FeatureRelease entity.
func newFeatureReleaseMutation(c config, op Op, opts ...featurereleaseOption) *FeatureReleaseMutation {
	m := &FeatureReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureReleaseID sets the ID field of the mutation.
func withFeatureReleaseID(id string) featurereleaseOption {
	return func(m *FeatureReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureRelease
		)
		m.oldValue = func(ctx context.Context) (*FeatureRelease, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureRelease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureRelease sets the old FeatureRelease of the mutation.
func withFeatureRelease(node *FeatureRelease) featurereleaseOption {
	return func(m *FeatureReleaseMutation) {
		m.oldValue = func(context.Context) (*FeatureRelease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureRelease entities.
func (m *FeatureReleaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureReleaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureReleaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureRelease.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeatureName sets the "feature_name" field.
func (m *FeatureReleaseMutation) SetFeatureName(s string) {
	m.feature_name = &s
}

// FeatureName returns the value of the "feature_name" field in the mutation.
func (m *FeatureReleaseMutation) FeatureName() (r string, exists bool) {
	v := m.feature_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureName returns the old "feature_name" field's value of the FeatureRelease entity.
// If the FeatureRelease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureReleaseMutation) OldFeatureName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureName: %w", err)
	}
	return oldValue.FeatureName, nil
}

// ResetFeatureName resets all changes to the "feature_name" field.
func (m *FeatureReleaseMutation) ResetFeatureName() {
	m.feature_name = nil
}

// SetDescription sets the "description" field.
func (m *FeatureReleaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeatureReleaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeatureRelease entity.
// If the FeatureRelease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureReleaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeatureReleaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[featurerelease.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeatureReleaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[featurerelease.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeatureReleaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, featurerelease.FieldDescription)
}

// SetState sets the "state" field.
func (m *FeatureReleaseMutation) SetState(f featurerelease.State) {
	m.state = &f
}

// State returns the value of the "state" field in the mutation.
func (m *FeatureReleaseMutation) State() (r featurerelease.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the FeatureRelease entity.
// If the FeatureRelease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureReleaseMutation) OldState(ctx context.Context) (v featurerelease.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *FeatureReleaseMutation) ResetState() {
	m.state = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *FeatureReleaseMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *FeatureReleaseMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the FeatureRelease entity.
// If the FeatureRelease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureReleaseMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *FeatureReleaseMutation) ResetReleaseDate() {
	m.release_date = nil
}

// SetEligibilityRules sets the "eligibility_rules" field.
func (m *FeatureReleaseMutation) SetEligibilityRules(value map[string]interface{}) {
	m.eligibility_rules = &value
}

// EligibilityRules returns the value of the "eligibility_rules" field in the mutation.
func (m *FeatureReleaseMutation) EligibilityRules() (r map[string]interface{}, exists bool) {
	v := m.eligibility_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibilityRules returns the old "eligibility_rules" field's value of the FeatureRelease entity.
// If the FeatureRelease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureReleaseMutation) OldEligibilityRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibilityRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibilityRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibilityRules: %w", err)
	}
	return oldValue.EligibilityRules, nil
}

// ClearEligibilityRules clears the value of the "eligibility_rules" field.
func (m *FeatureReleaseMutation) ClearEligibilityRules() {
	m.eligibility_rules = nil
	m.clearedFields[featurerelease.FieldEligibilityRules] = struct{}{}
}

// EligibilityRulesCleared returns if the "eligibility_rules" field was cleared in this mutation.
func (m *FeatureReleaseMutation) EligibilityRulesCleared() bool {
	_, ok := m.clearedFields[featurerelease.FieldEligibilityRules]
	return ok
}

// ResetEligibilityRules resets all changes to the "eligibility_rules" field.
func (m *FeatureReleaseMutation) ResetEligibilityRules() {
	m.eligibility_rules = nil
	delete(m.clearedFields, featurerelease.FieldEligibilityRules)
}

// SetDocumentationLink sets the "documentation_link" field.
func (m *FeatureReleaseMutation) SetDocumentationLink(s string) {
	m.documentation_link = &s
}

// DocumentationLink returns the value of the "documentation_link" field in the mutation.
func (m *FeatureReleaseMutation) DocumentationLink() (r string, exists bool) {
	v := m.documentation_link
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentationLink returns the old "documentation_link" field's value of the FeatureRelease entity.
// If the FeatureRelease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureReleaseMutation) OldDocumentationLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentationLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentationLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentationLink: %w", err)
	}
	return oldValue.DocumentationLink, nil
}

// ClearDocumentationLink clears the value of the "documentation_link" field.
func (m *FeatureReleaseMutation) ClearDocumentationLink() {
	m.documentation_link = nil
	m.clearedFields[featurerelease.FieldDocumentationLink] = struct{}{}
}

// DocumentationLinkCleared returns if the "documentation_link" field was cleared in this mutation.
func (m *FeatureReleaseMutation) DocumentationLinkCleared() bool {
	_, ok := m.clearedFields[featurerelease.FieldDocumentationLink]
	return ok
}

// ResetDocumentationLink resets all changes to the "documentation_link" field.
func (m *FeatureReleaseMutation) ResetDocumentationLink() {
	m.documentation_link = nil
	delete(m.clearedFields, featurerelease.FieldDocumentationLink)
}

// SetMetadata sets the "metadata" field.
func (m *FeatureReleaseMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FeatureReleaseMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the FeatureRelease entity.
// If the FeatureRelease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureReleaseMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FeatureReleaseMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[featurerelease.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FeatureReleaseMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[featurerelease.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FeatureReleaseMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, featurerelease.FieldMetadata)
}

// Where appends a list predicates to the FeatureReleaseMutation builder.
func (m *FeatureReleaseMutation) Where(ps ...predicate.FeatureRelease) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureReleaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureReleaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureRelease, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureReleaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureReleaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureRelease).
func (m *FeatureReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureReleaseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.feature_name != nil {
		fields = append(fields, featurerelease.FieldFeatureName)
	}
	if m.description != nil {
		fields = append(fields, featurerelease.FieldDescription)
	}
	if m.state != nil {
		fields = append(fields, featurerelease.FieldState)
	}
	if m.release_date != nil {
		fields = append(fields, featurerelease.FieldReleaseDate)
	}
	if m.eligibility_rules != nil {
		fields = append(fields, featurerelease.FieldEligibilityRules)
	}
	if m.documentation_link != nil {
		fields = append(fields, featurerelease.FieldDocumentationLink)
	}
	if m.metadata != nil {
		fields = append(fields, featurerelease.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featurerelease.FieldFeatureName:
		return m.FeatureName()
	case featurerelease.FieldDescription:
		return m.Description()
	case featurerelease.FieldState:
		return m.State()
	case featurerelease.FieldReleaseDate:
		return m.ReleaseDate()
	case featurerelease.FieldEligibilityRules:
		return m.EligibilityRules()
	case featurerelease.FieldDocumentationLink:
		return m.DocumentationLink()
	case featurerelease.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featurerelease.FieldFeatureName:
		return m.OldFeatureName(ctx)
	case featurerelease.FieldDescription:
		return m.OldDescription(ctx)
	case featurerelease.FieldState:
		return m.OldState(ctx)
	case featurerelease.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case featurerelease.FieldEligibilityRules:
		return m.OldEligibilityRules(ctx)
	case featurerelease.FieldDocumentationLink:
		return m.OldDocumentationLink(ctx)
	case featurerelease.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureRelease field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featurerelease.FieldFeatureName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureName(v)
		return nil
	case featurerelease.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case featurerelease.FieldState:
		v, ok := value.(featurerelease.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case featurerelease.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case featurerelease.FieldEligibilityRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibilityRules(v)
		return nil
	case featurerelease.FieldDocumentationLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentationLink(v)
		return nil
	case featurerelease.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureRelease field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureReleaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureReleaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureRelease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureReleaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featurerelease.FieldDescription) {
		fields = append(fields, featurerelease.FieldDescription)
	}
	if m.FieldCleared(featurerelease.FieldEligibilityRules) {
		fields = append(fields, featurerelease.FieldEligibilityRules)
	}
	if m.FieldCleared(featurerelease.FieldDocumentationLink) {
		fields = append(fields, featurerelease.FieldDocumentationLink)
	}
	if m.FieldCleared(featurerelease.FieldMetadata) {
		fields = append(fields, featurerelease.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureReleaseMutation) ClearField(name string) error {
	switch name {
	case featurerelease.FieldDescription:
		m.ClearDescription()
		return nil
	case featurerelease.FieldEligibilityRules:
		m.ClearEligibilityRules()
		return nil
	case featurerelease.FieldDocumentationLink:
		m.ClearDocumentationLink()
		return nil
	case featurerelease.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown FeatureRelease nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureReleaseMutation) ResetField(name string) error {
	switch name {
	case featurerelease.FieldFeatureName:
		m.ResetFeatureName()
		return nil
	case featurerelease.FieldDescription:
		m.ResetDescription()
		return nil
	case featurerelease.FieldState:
		m.ResetState()
		return nil
	case featurerelease.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case featurerelease.FieldEligibilityRules:
		m.ResetEligibilityRules()
		return nil
	case featurerelease.FieldDocumentationLink:
		m.ResetDocumentationLink()
		return nil
	case featurerelease.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown FeatureRelease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureReleaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureReleaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureReleaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureReleaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeatureRelease unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureReleaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeatureRelease edge %s", name)
}

// FitnessMutation represents an operation that mutates the Fitness nodes in the graph.
type FitnessMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Fitness, error)
	predicates    []predicate.Fitness
}

var _ ent.Mutation = (*FitnessMutation)(nil)

// fitnessOption allows management of the mutation configuration using functional options.
type fitnessOption func(*FitnessMutation)

// newFitnessMutation creates new mutation for the Fitness entity.
func newFitnessMutation(c config, op Op, opts ...fitnessOption) *FitnessMutation {
	m := &FitnessMutation{
		config:        c,
		op:            op,
		typ:           TypeFitness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFitnessID sets the ID field of the mutation.
func withFitnessID(id string) fitnessOption {
	return func(m *FitnessMutation) {
		var (
			err   error
			once  sync.Once
			value *Fitness
		)
		m.oldValue = func(ctx context.Context) (*Fitness, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fitness.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFitness sets the old Fitness of the mutation.
func withFitness(node *Fitness) fitnessOption {
	return func(m *FitnessMutation) {
		m.oldValue = func(context.Context) (*Fitness, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FitnessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FitnessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Fitness entities.
func (m *FitnessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FitnessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FitnessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fitness.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FitnessMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FitnessMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Fitness entity.
// If the Fitness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FitnessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FitnessMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the FitnessMutation builder.
func (m *FitnessMutation) Where(ps ...predicate.Fitness) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FitnessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FitnessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fitness, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FitnessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FitnessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fitness).
func (m *FitnessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FitnessMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, fitness.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FitnessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fitness.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FitnessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fitness.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Fitness field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FitnessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fitness.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Fitness field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FitnessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FitnessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FitnessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Fitness numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FitnessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FitnessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FitnessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Fitness nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FitnessMutation) ResetField(name string) error {
	switch name {
	case fitness.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Fitness field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FitnessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FitnessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FitnessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FitnessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FitnessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FitnessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FitnessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Fitness unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FitnessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Fitness edge %s", name)
}

// HelpMutation represents an operation that mutates the Help nodes in the graph.
type HelpMutation struct {
	config
	op            Op
	typ           string
	id            *string
	category      *string
	subject       *string
	body          *string
	media         *string
	status        *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Help, error)
	predicates    []predicate.Help
}

var _ ent.Mutation = (*HelpMutation)(nil)

// helpOption allows management of the mutation configuration using functional options.
type helpOption func(*HelpMutation)

// newHelpMutation creates new mutation for the Help entity.
func newHelpMutation(c config, op Op, opts ...helpOption) *HelpMutation {
	m := &HelpMutation{
		config:        c,
		op:            op,
		typ:           TypeHelp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHelpID sets the ID field of the mutation.
func withHelpID(id string) helpOption {
	return func(m *HelpMutation) {
		var (
			err   error
			once  sync.Once
			value *Help
		)
		m.oldValue = func(ctx context.Context) (*Help, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Help.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHelp sets the old Help of the mutation.
func withHelp(node *Help) helpOption {
	return func(m *HelpMutation) {
		m.oldValue = func(context.Context) (*Help, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HelpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HelpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Help entities.
func (m *HelpMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HelpMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HelpMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Help.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategory sets the "category" field.
func (m *HelpMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *HelpMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *HelpMutation) ResetCategory() {
	m.category = nil
}

// SetSubject sets the "subject" field.
func (m *HelpMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *HelpMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *HelpMutation) ResetSubject() {
	m.subject = nil
}

// SetBody sets the "body" field.
func (m *HelpMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *HelpMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *HelpMutation) ResetBody() {
	m.body = nil
}

// SetMedia sets the "media" field.
func (m *HelpMutation) SetMedia(s string) {
	m.media = &s
}

// Media returns the value of the "media" field in the mutation.
func (m *HelpMutation) Media() (r string, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMedia returns the old "media" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldMedia(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedia: %w", err)
	}
	return oldValue.Media, nil
}

// ClearMedia clears the value of the "media" field.
func (m *HelpMutation) ClearMedia() {
	m.media = nil
	m.clearedFields[help.FieldMedia] = struct{}{}
}

// MediaCleared returns if the "media" field was cleared in this mutation.
func (m *HelpMutation) MediaCleared() bool {
	_, ok := m.clearedFields[help.FieldMedia]
	return ok
}

// ResetMedia resets all changes to the "media" field.
func (m *HelpMutation) ResetMedia() {
	m.media = nil
	delete(m.clearedFields, help.FieldMedia)
}

// SetStatus sets the "status" field.
func (m *HelpMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *HelpMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HelpMutation) ResetStatus() {
	m.status = nil
}

// SetUserID sets the "user_id" field.
func (m *HelpMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *HelpMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *HelpMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *HelpMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[help.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *HelpMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *HelpMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *HelpMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the HelpMutation builder.
func (m *HelpMutation) Where(ps ...predicate.Help) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HelpMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HelpMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Help, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HelpMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HelpMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Help).
func (m *HelpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HelpMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.category != nil {
		fields = append(fields, help.FieldCategory)
	}
	if m.subject != nil {
		fields = append(fields, help.FieldSubject)
	}
	if m.body != nil {
		fields = append(fields, help.FieldBody)
	}
	if m.media != nil {
		fields = append(fields, help.FieldMedia)
	}
	if m.status != nil {
		fields = append(fields, help.FieldStatus)
	}
	if m.user != nil {
		fields = append(fields, help.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HelpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case help.FieldCategory:
		return m.Category()
	case help.FieldSubject:
		return m.Subject()
	case help.FieldBody:
		return m.Body()
	case help.FieldMedia:
		return m.Media()
	case help.FieldStatus:
		return m.Status()
	case help.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HelpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case help.FieldCategory:
		return m.OldCategory(ctx)
	case help.FieldSubject:
		return m.OldSubject(ctx)
	case help.FieldBody:
		return m.OldBody(ctx)
	case help.FieldMedia:
		return m.OldMedia(ctx)
	case help.FieldStatus:
		return m.OldStatus(ctx)
	case help.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Help field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HelpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case help.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case help.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case help.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case help.FieldMedia:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedia(v)
		return nil
	case help.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case help.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Help field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HelpMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HelpMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HelpMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Help numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HelpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(help.FieldMedia) {
		fields = append(fields, help.FieldMedia)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HelpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HelpMutation) ClearField(name string) error {
	switch name {
	case help.FieldMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown Help nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HelpMutation) ResetField(name string) error {
	switch name {
	case help.FieldCategory:
		m.ResetCategory()
		return nil
	case help.FieldSubject:
		m.ResetSubject()
		return nil
	case help.FieldBody:
		m.ResetBody()
		return nil
	case help.FieldMedia:
		m.ResetMedia()
		return nil
	case help.FieldStatus:
		m.ResetStatus()
		return nil
	case help.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Help field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HelpMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, help.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HelpMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case help.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HelpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HelpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HelpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, help.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HelpMutation) EdgeCleared(name string) bool {
	switch name {
	case help.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HelpMutation) ClearEdge(name string) error {
	switch name {
	case help.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Help unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HelpMutation) ResetEdge(name string) error {
	switch name {
	case help.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Help edge %s", name)
}

// InventoryAttributeMutation represents an operation that mutates the InventoryAttribute nodes in the graph.
type InventoryAttributeMutation struct {
	config
	op                                Op
	typ                               string
	id                                *string
	name                              *string
	image_url                         *string
	icon_url                          *string
	is_mandatory                      *bool
	data_type                         *inventoryattribute.DataType
	clearedFields                     map[string]struct{}
	inventory_type                    *string
	clearedinventory_type             bool
	place_inventory_attributes        map[string]struct{}
	removedplace_inventory_attributes map[string]struct{}
	clearedplace_inventory_attributes bool
	done                              bool
	oldValue                          func(context.Context) (*InventoryAttribute, error)
	predicates                        []predicate.InventoryAttribute
}

var _ ent.Mutation = (*InventoryAttributeMutation)(nil)

// inventoryattributeOption allows management of the mutation configuration using functional options.
type inventoryattributeOption func(*InventoryAttributeMutation)

// newInventoryAttributeMutation creates new mutation for the InventoryAttribute entity.
func newInventoryAttributeMutation(c config, op Op, opts ...inventoryattributeOption) *InventoryAttributeMutation {
	m := &InventoryAttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryAttributeID sets the ID field of the mutation.
func withInventoryAttributeID(id string) inventoryattributeOption {
	return func(m *InventoryAttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryAttribute
		)
		m.oldValue = func(ctx context.Context) (*InventoryAttribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryAttribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryAttribute sets the old InventoryAttribute of the mutation.
func withInventoryAttribute(node *InventoryAttribute) inventoryattributeOption {
	return func(m *InventoryAttributeMutation) {
		m.oldValue = func(context.Context) (*InventoryAttribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryAttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryAttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InventoryAttribute entities.
func (m *InventoryAttributeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryAttributeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryAttributeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryAttribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *InventoryAttributeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InventoryAttributeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InventoryAttribute entity.
// If the InventoryAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryAttributeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InventoryAttributeMutation) ResetName() {
	m.name = nil
}

// SetImageURL sets the "image_url" field.
func (m *InventoryAttributeMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *InventoryAttributeMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the InventoryAttribute entity.
// If the InventoryAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryAttributeMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *InventoryAttributeMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[inventoryattribute.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *InventoryAttributeMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[inventoryattribute.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *InventoryAttributeMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, inventoryattribute.FieldImageURL)
}

// SetIconURL sets the "icon_url" field.
func (m *InventoryAttributeMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *InventoryAttributeMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the InventoryAttribute entity.
// If the InventoryAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryAttributeMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *InventoryAttributeMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[inventoryattribute.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *InventoryAttributeMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[inventoryattribute.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *InventoryAttributeMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, inventoryattribute.FieldIconURL)
}

// SetIsMandatory sets the "is_mandatory" field.
func (m *InventoryAttributeMutation) SetIsMandatory(b bool) {
	m.is_mandatory = &b
}

// IsMandatory returns the value of the "is_mandatory" field in the mutation.
func (m *InventoryAttributeMutation) IsMandatory() (r bool, exists bool) {
	v := m.is_mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMandatory returns the old "is_mandatory" field's value of the InventoryAttribute entity.
// If the InventoryAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryAttributeMutation) OldIsMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMandatory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMandatory: %w", err)
	}
	return oldValue.IsMandatory, nil
}

// ResetIsMandatory resets all changes to the "is_mandatory" field.
func (m *InventoryAttributeMutation) ResetIsMandatory() {
	m.is_mandatory = nil
}

// SetDataType sets the "data_type" field.
func (m *InventoryAttributeMutation) SetDataType(it inventoryattribute.DataType) {
	m.data_type = &it
}

// DataType returns the value of the "data_type" field in the mutation.
func (m *InventoryAttributeMutation) DataType() (r inventoryattribute.DataType, exists bool) {
	v := m.data_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "data_type" field's value of the InventoryAttribute entity.
// If the InventoryAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryAttributeMutation) OldDataType(ctx context.Context) (v inventoryattribute.DataType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ClearDataType clears the value of the "data_type" field.
func (m *InventoryAttributeMutation) ClearDataType() {
	m.data_type = nil
	m.clearedFields[inventoryattribute.FieldDataType] = struct{}{}
}

// DataTypeCleared returns if the "data_type" field was cleared in this mutation.
func (m *InventoryAttributeMutation) DataTypeCleared() bool {
	_, ok := m.clearedFields[inventoryattribute.FieldDataType]
	return ok
}

// ResetDataType resets all changes to the "data_type" field.
func (m *InventoryAttributeMutation) ResetDataType() {
	m.data_type = nil
	delete(m.clearedFields, inventoryattribute.FieldDataType)
}

// SetInventoryTypeID sets the "inventory_type" edge to the InventoryType entity by id.
func (m *InventoryAttributeMutation) SetInventoryTypeID(id string) {
	m.inventory_type = &id
}

// ClearInventoryType clears the "inventory_type" edge to the InventoryType entity.
func (m *InventoryAttributeMutation) ClearInventoryType() {
	m.clearedinventory_type = true
}

// InventoryTypeCleared reports if the "inventory_type" edge to the InventoryType entity was cleared.
func (m *InventoryAttributeMutation) InventoryTypeCleared() bool {
	return m.clearedinventory_type
}

// InventoryTypeID returns the "inventory_type" edge ID in the mutation.
func (m *InventoryAttributeMutation) InventoryTypeID() (id string, exists bool) {
	if m.inventory_type != nil {
		return *m.inventory_type, true
	}
	return
}

// InventoryTypeIDs returns the "inventory_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryTypeID instead. It exists only for internal usage by the builders.
func (m *InventoryAttributeMutation) InventoryTypeIDs() (ids []string) {
	if id := m.inventory_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventoryType resets all changes to the "inventory_type" edge.
func (m *InventoryAttributeMutation) ResetInventoryType() {
	m.inventory_type = nil
	m.clearedinventory_type = false
}

// AddPlaceInventoryAttributeIDs adds the "place_inventory_attributes" edge to the PlaceInventoryAttribute entity by ids.
func (m *InventoryAttributeMutation) AddPlaceInventoryAttributeIDs(ids ...string) {
	if m.place_inventory_attributes == nil {
		m.place_inventory_attributes = make(map[string]struct{})
	}
	for i := range ids {
		m.place_inventory_attributes[ids[i]] = struct{}{}
	}
}

// ClearPlaceInventoryAttributes clears the "place_inventory_attributes" edge to the PlaceInventoryAttribute entity.
func (m *InventoryAttributeMutation) ClearPlaceInventoryAttributes() {
	m.clearedplace_inventory_attributes = true
}

// PlaceInventoryAttributesCleared reports if the "place_inventory_attributes" edge to the PlaceInventoryAttribute entity was cleared.
func (m *InventoryAttributeMutation) PlaceInventoryAttributesCleared() bool {
	return m.clearedplace_inventory_attributes
}

// RemovePlaceInventoryAttributeIDs removes the "place_inventory_attributes" edge to the PlaceInventoryAttribute entity by IDs.
func (m *InventoryAttributeMutation) RemovePlaceInventoryAttributeIDs(ids ...string) {
	if m.removedplace_inventory_attributes == nil {
		m.removedplace_inventory_attributes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place_inventory_attributes, ids[i])
		m.removedplace_inventory_attributes[ids[i]] = struct{}{}
	}
}

// RemovedPlaceInventoryAttributes returns the removed IDs of the "place_inventory_attributes" edge to the PlaceInventoryAttribute entity.
func (m *InventoryAttributeMutation) RemovedPlaceInventoryAttributesIDs() (ids []string) {
	for id := range m.removedplace_inventory_attributes {
		ids = append(ids, id)
	}
	return
}

// PlaceInventoryAttributesIDs returns the "place_inventory_attributes" edge IDs in the mutation.
func (m *InventoryAttributeMutation) PlaceInventoryAttributesIDs() (ids []string) {
	for id := range m.place_inventory_attributes {
		ids = append(ids, id)
	}
	return
}

// ResetPlaceInventoryAttributes resets all changes to the "place_inventory_attributes" edge.
func (m *InventoryAttributeMutation) ResetPlaceInventoryAttributes() {
	m.place_inventory_attributes = nil
	m.clearedplace_inventory_attributes = false
	m.removedplace_inventory_attributes = nil
}

// Where appends a list predicates to the InventoryAttributeMutation builder.
func (m *InventoryAttributeMutation) Where(ps ...predicate.InventoryAttribute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryAttributeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryAttributeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryAttribute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryAttributeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryAttributeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryAttribute).
func (m *InventoryAttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryAttributeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, inventoryattribute.FieldName)
	}
	if m.image_url != nil {
		fields = append(fields, inventoryattribute.FieldImageURL)
	}
	if m.icon_url != nil {
		fields = append(fields, inventoryattribute.FieldIconURL)
	}
	if m.is_mandatory != nil {
		fields = append(fields, inventoryattribute.FieldIsMandatory)
	}
	if m.data_type != nil {
		fields = append(fields, inventoryattribute.FieldDataType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryAttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryattribute.FieldName:
		return m.Name()
	case inventoryattribute.FieldImageURL:
		return m.ImageURL()
	case inventoryattribute.FieldIconURL:
		return m.IconURL()
	case inventoryattribute.FieldIsMandatory:
		return m.IsMandatory()
	case inventoryattribute.FieldDataType:
		return m.DataType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryAttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryattribute.FieldName:
		return m.OldName(ctx)
	case inventoryattribute.FieldImageURL:
		return m.OldImageURL(ctx)
	case inventoryattribute.FieldIconURL:
		return m.OldIconURL(ctx)
	case inventoryattribute.FieldIsMandatory:
		return m.OldIsMandatory(ctx)
	case inventoryattribute.FieldDataType:
		return m.OldDataType(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryAttribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryAttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryattribute.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inventoryattribute.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case inventoryattribute.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case inventoryattribute.FieldIsMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMandatory(v)
		return nil
	case inventoryattribute.FieldDataType:
		v, ok := value.(inventoryattribute.DataType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryAttribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryAttributeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryAttributeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryAttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InventoryAttribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryAttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventoryattribute.FieldImageURL) {
		fields = append(fields, inventoryattribute.FieldImageURL)
	}
	if m.FieldCleared(inventoryattribute.FieldIconURL) {
		fields = append(fields, inventoryattribute.FieldIconURL)
	}
	if m.FieldCleared(inventoryattribute.FieldDataType) {
		fields = append(fields, inventoryattribute.FieldDataType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryAttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryAttributeMutation) ClearField(name string) error {
	switch name {
	case inventoryattribute.FieldImageURL:
		m.ClearImageURL()
		return nil
	case inventoryattribute.FieldIconURL:
		m.ClearIconURL()
		return nil
	case inventoryattribute.FieldDataType:
		m.ClearDataType()
		return nil
	}
	return fmt.Errorf("unknown InventoryAttribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryAttributeMutation) ResetField(name string) error {
	switch name {
	case inventoryattribute.FieldName:
		m.ResetName()
		return nil
	case inventoryattribute.FieldImageURL:
		m.ResetImageURL()
		return nil
	case inventoryattribute.FieldIconURL:
		m.ResetIconURL()
		return nil
	case inventoryattribute.FieldIsMandatory:
		m.ResetIsMandatory()
		return nil
	case inventoryattribute.FieldDataType:
		m.ResetDataType()
		return nil
	}
	return fmt.Errorf("unknown InventoryAttribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryAttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.inventory_type != nil {
		edges = append(edges, inventoryattribute.EdgeInventoryType)
	}
	if m.place_inventory_attributes != nil {
		edges = append(edges, inventoryattribute.EdgePlaceInventoryAttributes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryAttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryattribute.EdgeInventoryType:
		if id := m.inventory_type; id != nil {
			return []ent.Value{*id}
		}
	case inventoryattribute.EdgePlaceInventoryAttributes:
		ids := make([]ent.Value, 0, len(m.place_inventory_attributes))
		for id := range m.place_inventory_attributes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryAttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedplace_inventory_attributes != nil {
		edges = append(edges, inventoryattribute.EdgePlaceInventoryAttributes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryAttributeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inventoryattribute.EdgePlaceInventoryAttributes:
		ids := make([]ent.Value, 0, len(m.removedplace_inventory_attributes))
		for id := range m.removedplace_inventory_attributes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryAttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinventory_type {
		edges = append(edges, inventoryattribute.EdgeInventoryType)
	}
	if m.clearedplace_inventory_attributes {
		edges = append(edges, inventoryattribute.EdgePlaceInventoryAttributes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryAttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryattribute.EdgeInventoryType:
		return m.clearedinventory_type
	case inventoryattribute.EdgePlaceInventoryAttributes:
		return m.clearedplace_inventory_attributes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryAttributeMutation) ClearEdge(name string) error {
	switch name {
	case inventoryattribute.EdgeInventoryType:
		m.ClearInventoryType()
		return nil
	}
	return fmt.Errorf("unknown InventoryAttribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryAttributeMutation) ResetEdge(name string) error {
	switch name {
	case inventoryattribute.EdgeInventoryType:
		m.ResetInventoryType()
		return nil
	case inventoryattribute.EdgePlaceInventoryAttributes:
		m.ResetPlaceInventoryAttributes()
		return nil
	}
	return fmt.Errorf("unknown InventoryAttribute edge %s", name)
}

// InventoryTypeMutation represents an operation that mutates the InventoryType nodes in the graph.
type InventoryTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	description              *string
	image_url                *string
	icon_url                 *string
	industry_type            *inventorytype.IndustryType
	measurement_unit         *string
	clearedFields            map[string]struct{}
	attributes               map[string]struct{}
	removedattributes        map[string]struct{}
	clearedattributes        bool
	place_inventories        map[string]struct{}
	removedplace_inventories map[string]struct{}
	clearedplace_inventories bool
	done                     bool
	oldValue                 func(context.Context) (*InventoryType, error)
	predicates               []predicate.InventoryType
}

var _ ent.Mutation = (*InventoryTypeMutation)(nil)

// inventorytypeOption allows management of the mutation configuration using functional options.
type inventorytypeOption func(*InventoryTypeMutation)

// newInventoryTypeMutation creates new mutation for the InventoryType entity.
func newInventoryTypeMutation(c config, op Op, opts ...inventorytypeOption) *InventoryTypeMutation {
	m := &InventoryTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryTypeID sets the ID field of the mutation.
func withInventoryTypeID(id string) inventorytypeOption {
	return func(m *InventoryTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryType
		)
		m.oldValue = func(ctx context.Context) (*InventoryType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryType sets the old InventoryType of the mutation.
func withInventoryType(node *InventoryType) inventorytypeOption {
	return func(m *InventoryTypeMutation) {
		m.oldValue = func(context.Context) (*InventoryType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InventoryType entities.
func (m *InventoryTypeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryTypeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryTypeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *InventoryTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InventoryTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InventoryType entity.
// If the InventoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InventoryTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *InventoryTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InventoryTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InventoryType entity.
// If the InventoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *InventoryTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[inventorytype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *InventoryTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[inventorytype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *InventoryTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, inventorytype.FieldDescription)
}

// SetImageURL sets the "image_url" field.
func (m *InventoryTypeMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *InventoryTypeMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the InventoryType entity.
// If the InventoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryTypeMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *InventoryTypeMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[inventorytype.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *InventoryTypeMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[inventorytype.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *InventoryTypeMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, inventorytype.FieldImageURL)
}

// SetIconURL sets the "icon_url" field.
func (m *InventoryTypeMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *InventoryTypeMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the InventoryType entity.
// If the InventoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryTypeMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *InventoryTypeMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[inventorytype.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *InventoryTypeMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[inventorytype.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *InventoryTypeMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, inventorytype.FieldIconURL)
}

// SetIndustryType sets the "industry_type" field.
func (m *InventoryTypeMutation) SetIndustryType(it inventorytype.IndustryType) {
	m.industry_type = &it
}

// IndustryType returns the value of the "industry_type" field in the mutation.
func (m *InventoryTypeMutation) IndustryType() (r inventorytype.IndustryType, exists bool) {
	v := m.industry_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustryType returns the old "industry_type" field's value of the InventoryType entity.
// If the InventoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryTypeMutation) OldIndustryType(ctx context.Context) (v inventorytype.IndustryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustryType: %w", err)
	}
	return oldValue.IndustryType, nil
}

// ClearIndustryType clears the value of the "industry_type" field.
func (m *InventoryTypeMutation) ClearIndustryType() {
	m.industry_type = nil
	m.clearedFields[inventorytype.FieldIndustryType] = struct{}{}
}

// IndustryTypeCleared returns if the "industry_type" field was cleared in this mutation.
func (m *InventoryTypeMutation) IndustryTypeCleared() bool {
	_, ok := m.clearedFields[inventorytype.FieldIndustryType]
	return ok
}

// ResetIndustryType resets all changes to the "industry_type" field.
func (m *InventoryTypeMutation) ResetIndustryType() {
	m.industry_type = nil
	delete(m.clearedFields, inventorytype.FieldIndustryType)
}

// SetMeasurementUnit sets the "measurement_unit" field.
func (m *InventoryTypeMutation) SetMeasurementUnit(s string) {
	m.measurement_unit = &s
}

// MeasurementUnit returns the value of the "measurement_unit" field in the mutation.
func (m *InventoryTypeMutation) MeasurementUnit() (r string, exists bool) {
	v := m.measurement_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasurementUnit returns the old "measurement_unit" field's value of the InventoryType entity.
// If the InventoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryTypeMutation) OldMeasurementUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasurementUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasurementUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasurementUnit: %w", err)
	}
	return oldValue.MeasurementUnit, nil
}

// ClearMeasurementUnit clears the value of the "measurement_unit" field.
func (m *InventoryTypeMutation) ClearMeasurementUnit() {
	m.measurement_unit = nil
	m.clearedFields[inventorytype.FieldMeasurementUnit] = struct{}{}
}

// MeasurementUnitCleared returns if the "measurement_unit" field was cleared in this mutation.
func (m *InventoryTypeMutation) MeasurementUnitCleared() bool {
	_, ok := m.clearedFields[inventorytype.FieldMeasurementUnit]
	return ok
}

// ResetMeasurementUnit resets all changes to the "measurement_unit" field.
func (m *InventoryTypeMutation) ResetMeasurementUnit() {
	m.measurement_unit = nil
	delete(m.clearedFields, inventorytype.FieldMeasurementUnit)
}

// AddAttributeIDs adds the "attributes" edge to the InventoryAttribute entity by ids.
func (m *InventoryTypeMutation) AddAttributeIDs(ids ...string) {
	if m.attributes == nil {
		m.attributes = make(map[string]struct{})
	}
	for i := range ids {
		m.attributes[ids[i]] = struct{}{}
	}
}

// ClearAttributes clears the "attributes" edge to the InventoryAttribute entity.
func (m *InventoryTypeMutation) ClearAttributes() {
	m.clearedattributes = true
}

// AttributesCleared reports if the "attributes" edge to the InventoryAttribute entity was cleared.
func (m *InventoryTypeMutation) AttributesCleared() bool {
	return m.clearedattributes
}

// RemoveAttributeIDs removes the "attributes" edge to the InventoryAttribute entity by IDs.
func (m *InventoryTypeMutation) RemoveAttributeIDs(ids ...string) {
	if m.removedattributes == nil {
		m.removedattributes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attributes, ids[i])
		m.removedattributes[ids[i]] = struct{}{}
	}
}

// RemovedAttributes returns the removed IDs of the "attributes" edge to the InventoryAttribute entity.
func (m *InventoryTypeMutation) RemovedAttributesIDs() (ids []string) {
	for id := range m.removedattributes {
		ids = append(ids, id)
	}
	return
}

// AttributesIDs returns the "attributes" edge IDs in the mutation.
func (m *InventoryTypeMutation) AttributesIDs() (ids []string) {
	for id := range m.attributes {
		ids = append(ids, id)
	}
	return
}

// ResetAttributes resets all changes to the "attributes" edge.
func (m *InventoryTypeMutation) ResetAttributes() {
	m.attributes = nil
	m.clearedattributes = false
	m.removedattributes = nil
}

// AddPlaceInventoryIDs adds the "place_inventories" edge to the PlaceInventory entity by ids.
func (m *InventoryTypeMutation) AddPlaceInventoryIDs(ids ...string) {
	if m.place_inventories == nil {
		m.place_inventories = make(map[string]struct{})
	}
	for i := range ids {
		m.place_inventories[ids[i]] = struct{}{}
	}
}

// ClearPlaceInventories clears the "place_inventories" edge to the PlaceInventory entity.
func (m *InventoryTypeMutation) ClearPlaceInventories() {
	m.clearedplace_inventories = true
}

// PlaceInventoriesCleared reports if the "place_inventories" edge to the PlaceInventory entity was cleared.
func (m *InventoryTypeMutation) PlaceInventoriesCleared() bool {
	return m.clearedplace_inventories
}

// RemovePlaceInventoryIDs removes the "place_inventories" edge to the PlaceInventory entity by IDs.
func (m *InventoryTypeMutation) RemovePlaceInventoryIDs(ids ...string) {
	if m.removedplace_inventories == nil {
		m.removedplace_inventories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place_inventories, ids[i])
		m.removedplace_inventories[ids[i]] = struct{}{}
	}
}

// RemovedPlaceInventories returns the removed IDs of the "place_inventories" edge to the PlaceInventory entity.
func (m *InventoryTypeMutation) RemovedPlaceInventoriesIDs() (ids []string) {
	for id := range m.removedplace_inventories {
		ids = append(ids, id)
	}
	return
}

// PlaceInventoriesIDs returns the "place_inventories" edge IDs in the mutation.
func (m *InventoryTypeMutation) PlaceInventoriesIDs() (ids []string) {
	for id := range m.place_inventories {
		ids = append(ids, id)
	}
	return
}

// ResetPlaceInventories resets all changes to the "place_inventories" edge.
func (m *InventoryTypeMutation) ResetPlaceInventories() {
	m.place_inventories = nil
	m.clearedplace_inventories = false
	m.removedplace_inventories = nil
}

// Where appends a list predicates to the InventoryTypeMutation builder.
func (m *InventoryTypeMutation) Where(ps ...predicate.InventoryType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryType).
func (m *InventoryTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, inventorytype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, inventorytype.FieldDescription)
	}
	if m.image_url != nil {
		fields = append(fields, inventorytype.FieldImageURL)
	}
	if m.icon_url != nil {
		fields = append(fields, inventorytype.FieldIconURL)
	}
	if m.industry_type != nil {
		fields = append(fields, inventorytype.FieldIndustryType)
	}
	if m.measurement_unit != nil {
		fields = append(fields, inventorytype.FieldMeasurementUnit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventorytype.FieldName:
		return m.Name()
	case inventorytype.FieldDescription:
		return m.Description()
	case inventorytype.FieldImageURL:
		return m.ImageURL()
	case inventorytype.FieldIconURL:
		return m.IconURL()
	case inventorytype.FieldIndustryType:
		return m.IndustryType()
	case inventorytype.FieldMeasurementUnit:
		return m.MeasurementUnit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventorytype.FieldName:
		return m.OldName(ctx)
	case inventorytype.FieldDescription:
		return m.OldDescription(ctx)
	case inventorytype.FieldImageURL:
		return m.OldImageURL(ctx)
	case inventorytype.FieldIconURL:
		return m.OldIconURL(ctx)
	case inventorytype.FieldIndustryType:
		return m.OldIndustryType(ctx)
	case inventorytype.FieldMeasurementUnit:
		return m.OldMeasurementUnit(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventorytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inventorytype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case inventorytype.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case inventorytype.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case inventorytype.FieldIndustryType:
		v, ok := value.(inventorytype.IndustryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustryType(v)
		return nil
	case inventorytype.FieldMeasurementUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasurementUnit(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InventoryType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventorytype.FieldDescription) {
		fields = append(fields, inventorytype.FieldDescription)
	}
	if m.FieldCleared(inventorytype.FieldImageURL) {
		fields = append(fields, inventorytype.FieldImageURL)
	}
	if m.FieldCleared(inventorytype.FieldIconURL) {
		fields = append(fields, inventorytype.FieldIconURL)
	}
	if m.FieldCleared(inventorytype.FieldIndustryType) {
		fields = append(fields, inventorytype.FieldIndustryType)
	}
	if m.FieldCleared(inventorytype.FieldMeasurementUnit) {
		fields = append(fields, inventorytype.FieldMeasurementUnit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryTypeMutation) ClearField(name string) error {
	switch name {
	case inventorytype.FieldDescription:
		m.ClearDescription()
		return nil
	case inventorytype.FieldImageURL:
		m.ClearImageURL()
		return nil
	case inventorytype.FieldIconURL:
		m.ClearIconURL()
		return nil
	case inventorytype.FieldIndustryType:
		m.ClearIndustryType()
		return nil
	case inventorytype.FieldMeasurementUnit:
		m.ClearMeasurementUnit()
		return nil
	}
	return fmt.Errorf("unknown InventoryType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryTypeMutation) ResetField(name string) error {
	switch name {
	case inventorytype.FieldName:
		m.ResetName()
		return nil
	case inventorytype.FieldDescription:
		m.ResetDescription()
		return nil
	case inventorytype.FieldImageURL:
		m.ResetImageURL()
		return nil
	case inventorytype.FieldIconURL:
		m.ResetIconURL()
		return nil
	case inventorytype.FieldIndustryType:
		m.ResetIndustryType()
		return nil
	case inventorytype.FieldMeasurementUnit:
		m.ResetMeasurementUnit()
		return nil
	}
	return fmt.Errorf("unknown InventoryType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attributes != nil {
		edges = append(edges, inventorytype.EdgeAttributes)
	}
	if m.place_inventories != nil {
		edges = append(edges, inventorytype.EdgePlaceInventories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventorytype.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.attributes))
		for id := range m.attributes {
			ids = append(ids, id)
		}
		return ids
	case inventorytype.EdgePlaceInventories:
		ids := make([]ent.Value, 0, len(m.place_inventories))
		for id := range m.place_inventories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattributes != nil {
		edges = append(edges, inventorytype.EdgeAttributes)
	}
	if m.removedplace_inventories != nil {
		edges = append(edges, inventorytype.EdgePlaceInventories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inventorytype.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.removedattributes))
		for id := range m.removedattributes {
			ids = append(ids, id)
		}
		return ids
	case inventorytype.EdgePlaceInventories:
		ids := make([]ent.Value, 0, len(m.removedplace_inventories))
		for id := range m.removedplace_inventories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattributes {
		edges = append(edges, inventorytype.EdgeAttributes)
	}
	if m.clearedplace_inventories {
		edges = append(edges, inventorytype.EdgePlaceInventories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case inventorytype.EdgeAttributes:
		return m.clearedattributes
	case inventorytype.EdgePlaceInventories:
		return m.clearedplace_inventories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InventoryType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryTypeMutation) ResetEdge(name string) error {
	switch name {
	case inventorytype.EdgeAttributes:
		m.ResetAttributes()
		return nil
	case inventorytype.EdgePlaceInventories:
		m.ResetPlaceInventories()
		return nil
	}
	return fmt.Errorf("unknown InventoryType edge %s", name)
}

// LikeMutation represents an operation that mutates the Like nodes in the graph.
type LikeMutation struct {
	config
	op            Op
	typ           string
	id            *string
	createdAt     *time.Time
	updatedAt     *time.Time
	like          *bool
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	review        *string
	clearedreview bool
	media         *string
	clearedmedia  bool
	post          *string
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*Like, error)
	predicates    []predicate.Like
}

var _ ent.Mutation = (*LikeMutation)(nil)

// likeOption allows management of the mutation configuration using functional options.
type likeOption func(*LikeMutation)

// newLikeMutation creates new mutation for the Like entity.
func newLikeMutation(c config, op Op, opts ...likeOption) *LikeMutation {
	m := &LikeMutation{
		config:        c,
		op:            op,
		typ:           TypeLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikeID sets the ID field of the mutation.
func withLikeID(id string) likeOption {
	return func(m *LikeMutation) {
		var (
			err   error
			once  sync.Once
			value *Like
		)
		m.oldValue = func(ctx context.Context) (*Like, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Like.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLike sets the old Like of the mutation.
func withLike(node *Like) likeOption {
	return func(m *LikeMutation) {
		m.oldValue = func(context.Context) (*Like, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Like entities.
func (m *LikeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Like.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *LikeMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *LikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *LikeMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *LikeMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *LikeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *LikeMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetLike sets the "like" field.
func (m *LikeMutation) SetLike(b bool) {
	m.like = &b
}

// Like returns the value of the "like" field in the mutation.
func (m *LikeMutation) Like() (r bool, exists bool) {
	v := m.like
	if v == nil {
		return
	}
	return *v, true
}

// OldLike returns the old "like" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldLike(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLike is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLike requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLike: %w", err)
	}
	return oldValue.Like, nil
}

// ResetLike resets all changes to the "like" field.
func (m *LikeMutation) ResetLike() {
	m.like = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *LikeMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *LikeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *LikeMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetReviewID sets the "review" edge to the Review entity by id.
func (m *LikeMutation) SetReviewID(id string) {
	m.review = &id
}

// ClearReview clears the "review" edge to the Review entity.
func (m *LikeMutation) ClearReview() {
	m.clearedreview = true
}

// ReviewCleared reports if the "review" edge to the Review entity was cleared.
func (m *LikeMutation) ReviewCleared() bool {
	return m.clearedreview
}

// ReviewID returns the "review" edge ID in the mutation.
func (m *LikeMutation) ReviewID() (id string, exists bool) {
	if m.review != nil {
		return *m.review, true
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) ReviewIDs() (ids []string) {
	if id := m.review; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *LikeMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
}

// SetMediaID sets the "media" edge to the Media entity by id.
func (m *LikeMutation) SetMediaID(id string) {
	m.media = &id
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *LikeMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *LikeMutation) MediaCleared() bool {
	return m.clearedmedia
}

// MediaID returns the "media" edge ID in the mutation.
func (m *LikeMutation) MediaID() (id string, exists bool) {
	if m.media != nil {
		return *m.media, true
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) MediaIDs() (ids []string) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *LikeMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *LikeMutation) SetPostID(id string) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *LikeMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *LikeMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *LikeMutation) PostID() (id string, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *LikeMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the LikeMutation builder.
func (m *LikeMutation) Where(ps ...predicate.Like) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Like, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Like).
func (m *LikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.createdAt != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, like.FieldUpdatedAt)
	}
	if m.like != nil {
		fields = append(fields, like.FieldLike)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case like.FieldCreatedAt:
		return m.CreatedAt()
	case like.FieldUpdatedAt:
		return m.UpdatedAt()
	case like.FieldLike:
		return m.Like()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case like.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case like.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case like.FieldLike:
		return m.OldLike(ctx)
	}
	return nil, fmt.Errorf("unknown Like field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case like.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case like.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case like.FieldLike:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLike(v)
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Like numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Like nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikeMutation) ResetField(name string) error {
	switch name {
	case like.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case like.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case like.FieldLike:
		m.ResetLike()
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, like.EdgeUser)
	}
	if m.review != nil {
		edges = append(edges, like.EdgeReview)
	}
	if m.media != nil {
		edges = append(edges, like.EdgeMedia)
	}
	if m.post != nil {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case like.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case like.EdgeReview:
		if id := m.review; id != nil {
			return []ent.Value{*id}
		}
	case like.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	case like.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, like.EdgeUser)
	}
	if m.clearedreview {
		edges = append(edges, like.EdgeReview)
	}
	if m.clearedmedia {
		edges = append(edges, like.EdgeMedia)
	}
	if m.clearedpost {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikeMutation) EdgeCleared(name string) bool {
	switch name {
	case like.EdgeUser:
		return m.cleareduser
	case like.EdgeReview:
		return m.clearedreview
	case like.EdgeMedia:
		return m.clearedmedia
	case like.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikeMutation) ClearEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ClearUser()
		return nil
	case like.EdgeReview:
		m.ClearReview()
		return nil
	case like.EdgeMedia:
		m.ClearMedia()
		return nil
	case like.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Like unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikeMutation) ResetEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ResetUser()
		return nil
	case like.EdgeReview:
		m.ResetReview()
		return nil
	case like.EdgeMedia:
		m.ResetMedia()
		return nil
	case like.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown Like edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	_URL                   *string
	_MediaType             *string
	_CreatedAt             *time.Time
	_UpdatedAt             *time.Time
	likeCount              *int
	addlikeCount           *int
	dislikeCount           *int
	adddislikeCount        *int
	clearedFields          map[string]struct{}
	post                   *string
	clearedpost            bool
	review                 *string
	clearedreview          bool
	categories             map[string]struct{}
	removedcategories      map[string]struct{}
	clearedcategories      bool
	place                  map[string]struct{}
	removedplace           map[string]struct{}
	clearedplace           bool
	place_inventory        map[string]struct{}
	removedplace_inventory map[string]struct{}
	clearedplace_inventory bool
	menu                   map[string]struct{}
	removedmenu            map[string]struct{}
	clearedmenu            bool
	room_category          map[string]struct{}
	removedroom_category   map[string]struct{}
	clearedroom_category   bool
	room                   map[string]struct{}
	removedroom            map[string]struct{}
	clearedroom            bool
	plan                   *string
	clearedplan            bool
	done                   bool
	oldValue               func(context.Context) (*Media, error)
	predicates             []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id string) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Media entities.
func (m *MediaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "URL" field.
func (m *MediaMutation) SetURL(s string) {
	m._URL = &s
}

// URL returns the value of the "URL" field in the mutation.
func (m *MediaMutation) URL() (r string, exists bool) {
	v := m._URL
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "URL" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "URL" field.
func (m *MediaMutation) ResetURL() {
	m._URL = nil
}

// SetMediaType sets the "MediaType" field.
func (m *MediaMutation) SetMediaType(s string) {
	m._MediaType = &s
}

// MediaType returns the value of the "MediaType" field in the mutation.
func (m *MediaMutation) MediaType() (r string, exists bool) {
	v := m._MediaType
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaType returns the old "MediaType" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldMediaType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaType: %w", err)
	}
	return oldValue.MediaType, nil
}

// ResetMediaType resets all changes to the "MediaType" field.
func (m *MediaMutation) ResetMediaType() {
	m._MediaType = nil
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *MediaMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *MediaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *MediaMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *MediaMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *MediaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *MediaMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetLikeCount sets the "likeCount" field.
func (m *MediaMutation) SetLikeCount(i int) {
	m.likeCount = &i
	m.addlikeCount = nil
}

// LikeCount returns the value of the "likeCount" field in the mutation.
func (m *MediaMutation) LikeCount() (r int, exists bool) {
	v := m.likeCount
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "likeCount" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "likeCount" field.
func (m *MediaMutation) AddLikeCount(i int) {
	if m.addlikeCount != nil {
		*m.addlikeCount += i
	} else {
		m.addlikeCount = &i
	}
}

// AddedLikeCount returns the value that was added to the "likeCount" field in this mutation.
func (m *MediaMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlikeCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "likeCount" field.
func (m *MediaMutation) ResetLikeCount() {
	m.likeCount = nil
	m.addlikeCount = nil
}

// SetDislikeCount sets the "dislikeCount" field.
func (m *MediaMutation) SetDislikeCount(i int) {
	m.dislikeCount = &i
	m.adddislikeCount = nil
}

// DislikeCount returns the value of the "dislikeCount" field in the mutation.
func (m *MediaMutation) DislikeCount() (r int, exists bool) {
	v := m.dislikeCount
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislikeCount" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislikeCount" field.
func (m *MediaMutation) AddDislikeCount(i int) {
	if m.adddislikeCount != nil {
		*m.adddislikeCount += i
	} else {
		m.adddislikeCount = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislikeCount" field in this mutation.
func (m *MediaMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislikeCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislikeCount" field.
func (m *MediaMutation) ResetDislikeCount() {
	m.dislikeCount = nil
	m.adddislikeCount = nil
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *MediaMutation) SetPostID(id string) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *MediaMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *MediaMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *MediaMutation) PostID() (id string, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *MediaMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *MediaMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// SetReviewID sets the "review" edge to the Review entity by id.
func (m *MediaMutation) SetReviewID(id string) {
	m.review = &id
}

// ClearReview clears the "review" edge to the Review entity.
func (m *MediaMutation) ClearReview() {
	m.clearedreview = true
}

// ReviewCleared reports if the "review" edge to the Review entity was cleared.
func (m *MediaMutation) ReviewCleared() bool {
	return m.clearedreview
}

// ReviewID returns the "review" edge ID in the mutation.
func (m *MediaMutation) ReviewID() (id string, exists bool) {
	if m.review != nil {
		return *m.review, true
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewID instead. It exists only for internal usage by the builders.
func (m *MediaMutation) ReviewIDs() (ids []string) {
	if id := m.review; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *MediaMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *MediaMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *MediaMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *MediaMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *MediaMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *MediaMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *MediaMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *MediaMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *MediaMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *MediaMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *MediaMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *MediaMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *MediaMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *MediaMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *MediaMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddPlaceInventoryIDs adds the "place_inventory" edge to the PlaceInventory entity by ids.
func (m *MediaMutation) AddPlaceInventoryIDs(ids ...string) {
	if m.place_inventory == nil {
		m.place_inventory = make(map[string]struct{})
	}
	for i := range ids {
		m.place_inventory[ids[i]] = struct{}{}
	}
}

// ClearPlaceInventory clears the "place_inventory" edge to the PlaceInventory entity.
func (m *MediaMutation) ClearPlaceInventory() {
	m.clearedplace_inventory = true
}

// PlaceInventoryCleared reports if the "place_inventory" edge to the PlaceInventory entity was cleared.
func (m *MediaMutation) PlaceInventoryCleared() bool {
	return m.clearedplace_inventory
}

// RemovePlaceInventoryIDs removes the "place_inventory" edge to the PlaceInventory entity by IDs.
func (m *MediaMutation) RemovePlaceInventoryIDs(ids ...string) {
	if m.removedplace_inventory == nil {
		m.removedplace_inventory = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place_inventory, ids[i])
		m.removedplace_inventory[ids[i]] = struct{}{}
	}
}

// RemovedPlaceInventory returns the removed IDs of the "place_inventory" edge to the PlaceInventory entity.
func (m *MediaMutation) RemovedPlaceInventoryIDs() (ids []string) {
	for id := range m.removedplace_inventory {
		ids = append(ids, id)
	}
	return
}

// PlaceInventoryIDs returns the "place_inventory" edge IDs in the mutation.
func (m *MediaMutation) PlaceInventoryIDs() (ids []string) {
	for id := range m.place_inventory {
		ids = append(ids, id)
	}
	return
}

// ResetPlaceInventory resets all changes to the "place_inventory" edge.
func (m *MediaMutation) ResetPlaceInventory() {
	m.place_inventory = nil
	m.clearedplace_inventory = false
	m.removedplace_inventory = nil
}

// AddMenuIDs adds the "menu" edge to the Menu entity by ids.
func (m *MediaMutation) AddMenuIDs(ids ...string) {
	if m.menu == nil {
		m.menu = make(map[string]struct{})
	}
	for i := range ids {
		m.menu[ids[i]] = struct{}{}
	}
}

// ClearMenu clears the "menu" edge to the Menu entity.
func (m *MediaMutation) ClearMenu() {
	m.clearedmenu = true
}

// MenuCleared reports if the "menu" edge to the Menu entity was cleared.
func (m *MediaMutation) MenuCleared() bool {
	return m.clearedmenu
}

// RemoveMenuIDs removes the "menu" edge to the Menu entity by IDs.
func (m *MediaMutation) RemoveMenuIDs(ids ...string) {
	if m.removedmenu == nil {
		m.removedmenu = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menu, ids[i])
		m.removedmenu[ids[i]] = struct{}{}
	}
}

// RemovedMenu returns the removed IDs of the "menu" edge to the Menu entity.
func (m *MediaMutation) RemovedMenuIDs() (ids []string) {
	for id := range m.removedmenu {
		ids = append(ids, id)
	}
	return
}

// MenuIDs returns the "menu" edge IDs in the mutation.
func (m *MediaMutation) MenuIDs() (ids []string) {
	for id := range m.menu {
		ids = append(ids, id)
	}
	return
}

// ResetMenu resets all changes to the "menu" edge.
func (m *MediaMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
	m.removedmenu = nil
}

// AddRoomCategoryIDs adds the "room_category" edge to the RoomCategory entity by ids.
func (m *MediaMutation) AddRoomCategoryIDs(ids ...string) {
	if m.room_category == nil {
		m.room_category = make(map[string]struct{})
	}
	for i := range ids {
		m.room_category[ids[i]] = struct{}{}
	}
}

// ClearRoomCategory clears the "room_category" edge to the RoomCategory entity.
func (m *MediaMutation) ClearRoomCategory() {
	m.clearedroom_category = true
}

// RoomCategoryCleared reports if the "room_category" edge to the RoomCategory entity was cleared.
func (m *MediaMutation) RoomCategoryCleared() bool {
	return m.clearedroom_category
}

// RemoveRoomCategoryIDs removes the "room_category" edge to the RoomCategory entity by IDs.
func (m *MediaMutation) RemoveRoomCategoryIDs(ids ...string) {
	if m.removedroom_category == nil {
		m.removedroom_category = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.room_category, ids[i])
		m.removedroom_category[ids[i]] = struct{}{}
	}
}

// RemovedRoomCategory returns the removed IDs of the "room_category" edge to the RoomCategory entity.
func (m *MediaMutation) RemovedRoomCategoryIDs() (ids []string) {
	for id := range m.removedroom_category {
		ids = append(ids, id)
	}
	return
}

// RoomCategoryIDs returns the "room_category" edge IDs in the mutation.
func (m *MediaMutation) RoomCategoryIDs() (ids []string) {
	for id := range m.room_category {
		ids = append(ids, id)
	}
	return
}

// ResetRoomCategory resets all changes to the "room_category" edge.
func (m *MediaMutation) ResetRoomCategory() {
	m.room_category = nil
	m.clearedroom_category = false
	m.removedroom_category = nil
}

// AddRoomIDs adds the "room" edge to the Room entity by ids.
func (m *MediaMutation) AddRoomIDs(ids ...string) {
	if m.room == nil {
		m.room = make(map[string]struct{})
	}
	for i := range ids {
		m.room[ids[i]] = struct{}{}
	}
}

// ClearRoom clears the "room" edge to the Room entity.
func (m *MediaMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared reports if the "room" edge to the Room entity was cleared.
func (m *MediaMutation) RoomCleared() bool {
	return m.clearedroom
}

// RemoveRoomIDs removes the "room" edge to the Room entity by IDs.
func (m *MediaMutation) RemoveRoomIDs(ids ...string) {
	if m.removedroom == nil {
		m.removedroom = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.room, ids[i])
		m.removedroom[ids[i]] = struct{}{}
	}
}

// RemovedRoom returns the removed IDs of the "room" edge to the Room entity.
func (m *MediaMutation) RemovedRoomIDs() (ids []string) {
	for id := range m.removedroom {
		ids = append(ids, id)
	}
	return
}

// RoomIDs returns the "room" edge IDs in the mutation.
func (m *MediaMutation) RoomIDs() (ids []string) {
	for id := range m.room {
		ids = append(ids, id)
	}
	return
}

// ResetRoom resets all changes to the "room" edge.
func (m *MediaMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
	m.removedroom = nil
}

// SetPlanID sets the "plan" edge to the Plan entity by id.
func (m *MediaMutation) SetPlanID(id string) {
	m.plan = &id
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *MediaMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *MediaMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanID returns the "plan" edge ID in the mutation.
func (m *MediaMutation) PlanID() (id string, exists bool) {
	if m.plan != nil {
		return *m.plan, true
	}
	return
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *MediaMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *MediaMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._URL != nil {
		fields = append(fields, media.FieldURL)
	}
	if m._MediaType != nil {
		fields = append(fields, media.FieldMediaType)
	}
	if m._CreatedAt != nil {
		fields = append(fields, media.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, media.FieldUpdatedAt)
	}
	if m.likeCount != nil {
		fields = append(fields, media.FieldLikeCount)
	}
	if m.dislikeCount != nil {
		fields = append(fields, media.FieldDislikeCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldURL:
		return m.URL()
	case media.FieldMediaType:
		return m.MediaType()
	case media.FieldCreatedAt:
		return m.CreatedAt()
	case media.FieldUpdatedAt:
		return m.UpdatedAt()
	case media.FieldLikeCount:
		return m.LikeCount()
	case media.FieldDislikeCount:
		return m.DislikeCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldURL:
		return m.OldURL(ctx)
	case media.FieldMediaType:
		return m.OldMediaType(ctx)
	case media.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case media.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case media.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case media.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case media.FieldMediaType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaType(v)
		return nil
	case media.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case media.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case media.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case media.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	var fields []string
	if m.addlikeCount != nil {
		fields = append(fields, media.FieldLikeCount)
	}
	if m.adddislikeCount != nil {
		fields = append(fields, media.FieldDislikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case media.FieldLikeCount:
		return m.AddedLikeCount()
	case media.FieldDislikeCount:
		return m.AddedDislikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case media.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case media.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldURL:
		m.ResetURL()
		return nil
	case media.FieldMediaType:
		m.ResetMediaType()
		return nil
	case media.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case media.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case media.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case media.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.post != nil {
		edges = append(edges, media.EdgePost)
	}
	if m.review != nil {
		edges = append(edges, media.EdgeReview)
	}
	if m.categories != nil {
		edges = append(edges, media.EdgeCategories)
	}
	if m.place != nil {
		edges = append(edges, media.EdgePlace)
	}
	if m.place_inventory != nil {
		edges = append(edges, media.EdgePlaceInventory)
	}
	if m.menu != nil {
		edges = append(edges, media.EdgeMenu)
	}
	if m.room_category != nil {
		edges = append(edges, media.EdgeRoomCategory)
	}
	if m.room != nil {
		edges = append(edges, media.EdgeRoom)
	}
	if m.plan != nil {
		edges = append(edges, media.EdgePlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case media.EdgeReview:
		if id := m.review; id != nil {
			return []ent.Value{*id}
		}
	case media.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case media.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case media.EdgePlaceInventory:
		ids := make([]ent.Value, 0, len(m.place_inventory))
		for id := range m.place_inventory {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.menu))
		for id := range m.menu {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeRoomCategory:
		ids := make([]ent.Value, 0, len(m.room_category))
		for id := range m.room_category {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeRoom:
		ids := make([]ent.Value, 0, len(m.room))
		for id := range m.room {
			ids = append(ids, id)
		}
		return ids
	case media.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedcategories != nil {
		edges = append(edges, media.EdgeCategories)
	}
	if m.removedplace != nil {
		edges = append(edges, media.EdgePlace)
	}
	if m.removedplace_inventory != nil {
		edges = append(edges, media.EdgePlaceInventory)
	}
	if m.removedmenu != nil {
		edges = append(edges, media.EdgeMenu)
	}
	if m.removedroom_category != nil {
		edges = append(edges, media.EdgeRoomCategory)
	}
	if m.removedroom != nil {
		edges = append(edges, media.EdgeRoom)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case media.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case media.EdgePlaceInventory:
		ids := make([]ent.Value, 0, len(m.removedplace_inventory))
		for id := range m.removedplace_inventory {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.removedmenu))
		for id := range m.removedmenu {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeRoomCategory:
		ids := make([]ent.Value, 0, len(m.removedroom_category))
		for id := range m.removedroom_category {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeRoom:
		ids := make([]ent.Value, 0, len(m.removedroom))
		for id := range m.removedroom {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedpost {
		edges = append(edges, media.EdgePost)
	}
	if m.clearedreview {
		edges = append(edges, media.EdgeReview)
	}
	if m.clearedcategories {
		edges = append(edges, media.EdgeCategories)
	}
	if m.clearedplace {
		edges = append(edges, media.EdgePlace)
	}
	if m.clearedplace_inventory {
		edges = append(edges, media.EdgePlaceInventory)
	}
	if m.clearedmenu {
		edges = append(edges, media.EdgeMenu)
	}
	if m.clearedroom_category {
		edges = append(edges, media.EdgeRoomCategory)
	}
	if m.clearedroom {
		edges = append(edges, media.EdgeRoom)
	}
	if m.clearedplan {
		edges = append(edges, media.EdgePlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgePost:
		return m.clearedpost
	case media.EdgeReview:
		return m.clearedreview
	case media.EdgeCategories:
		return m.clearedcategories
	case media.EdgePlace:
		return m.clearedplace
	case media.EdgePlaceInventory:
		return m.clearedplace_inventory
	case media.EdgeMenu:
		return m.clearedmenu
	case media.EdgeRoomCategory:
		return m.clearedroom_category
	case media.EdgeRoom:
		return m.clearedroom
	case media.EdgePlan:
		return m.clearedplan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	case media.EdgePost:
		m.ClearPost()
		return nil
	case media.EdgeReview:
		m.ClearReview()
		return nil
	case media.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgePost:
		m.ResetPost()
		return nil
	case media.EdgeReview:
		m.ResetReview()
		return nil
	case media.EdgeCategories:
		m.ResetCategories()
		return nil
	case media.EdgePlace:
		m.ResetPlace()
		return nil
	case media.EdgePlaceInventory:
		m.ResetPlaceInventory()
		return nil
	case media.EdgeMenu:
		m.ResetMenu()
		return nil
	case media.EdgeRoomCategory:
		m.ResetRoomCategory()
		return nil
	case media.EdgeRoom:
		m.ResetRoom()
		return nil
	case media.EdgePlan:
		m.ResetPlan()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	deleted_at        *string
	is_deleted        *bool
	description       *string
	options           *string
	foodType          *menu.FoodType
	menuItemType      *menu.MenuItemType
	drinkType         *menu.DrinkType
	dietaryType       *menu.DietaryType
	is_available      *bool
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	place             map[string]struct{}
	removedplace      map[string]struct{}
	clearedplace      bool
	categories        map[string]struct{}
	removedcategories map[string]struct{}
	clearedcategories bool
	menu_items        map[string]struct{}
	removedmenu_items map[string]struct{}
	clearedmenu_items bool
	media             map[string]struct{}
	removedmedia      map[string]struct{}
	clearedmedia      bool
	created_by        map[string]struct{}
	removedcreated_by map[string]struct{}
	clearedcreated_by bool
	updated_by        map[string]struct{}
	removedupdated_by map[string]struct{}
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*Menu, error)
	predicates        []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id string) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MenuMutation) SetDeletedAt(s string) {
	m.deleted_at = &s
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MenuMutation) DeletedAt() (r string, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDeletedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MenuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[menu.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MenuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MenuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, menu.FieldDeletedAt)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *MenuMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *MenuMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *MenuMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetDescription sets the "description" field.
func (m *MenuMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MenuMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MenuMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[menu.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MenuMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[menu.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MenuMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, menu.FieldDescription)
}

// SetOptions sets the "options" field.
func (m *MenuMutation) SetOptions(s string) {
	m.options = &s
}

// Options returns the value of the "options" field in the mutation.
func (m *MenuMutation) Options() (r string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldOptions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ClearOptions clears the value of the "options" field.
func (m *MenuMutation) ClearOptions() {
	m.options = nil
	m.clearedFields[menu.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *MenuMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[menu.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *MenuMutation) ResetOptions() {
	m.options = nil
	delete(m.clearedFields, menu.FieldOptions)
}

// SetFoodType sets the "foodType" field.
func (m *MenuMutation) SetFoodType(mt menu.FoodType) {
	m.foodType = &mt
}

// FoodType returns the value of the "foodType" field in the mutation.
func (m *MenuMutation) FoodType() (r menu.FoodType, exists bool) {
	v := m.foodType
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodType returns the old "foodType" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldFoodType(ctx context.Context) (v menu.FoodType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFoodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFoodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodType: %w", err)
	}
	return oldValue.FoodType, nil
}

// ClearFoodType clears the value of the "foodType" field.
func (m *MenuMutation) ClearFoodType() {
	m.foodType = nil
	m.clearedFields[menu.FieldFoodType] = struct{}{}
}

// FoodTypeCleared returns if the "foodType" field was cleared in this mutation.
func (m *MenuMutation) FoodTypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldFoodType]
	return ok
}

// ResetFoodType resets all changes to the "foodType" field.
func (m *MenuMutation) ResetFoodType() {
	m.foodType = nil
	delete(m.clearedFields, menu.FieldFoodType)
}

// SetMenuItemType sets the "menuItemType" field.
func (m *MenuMutation) SetMenuItemType(mit menu.MenuItemType) {
	m.menuItemType = &mit
}

// MenuItemType returns the value of the "menuItemType" field in the mutation.
func (m *MenuMutation) MenuItemType() (r menu.MenuItemType, exists bool) {
	v := m.menuItemType
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuItemType returns the old "menuItemType" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuItemType(ctx context.Context) (v menu.MenuItemType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuItemType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuItemType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuItemType: %w", err)
	}
	return oldValue.MenuItemType, nil
}

// ClearMenuItemType clears the value of the "menuItemType" field.
func (m *MenuMutation) ClearMenuItemType() {
	m.menuItemType = nil
	m.clearedFields[menu.FieldMenuItemType] = struct{}{}
}

// MenuItemTypeCleared returns if the "menuItemType" field was cleared in this mutation.
func (m *MenuMutation) MenuItemTypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldMenuItemType]
	return ok
}

// ResetMenuItemType resets all changes to the "menuItemType" field.
func (m *MenuMutation) ResetMenuItemType() {
	m.menuItemType = nil
	delete(m.clearedFields, menu.FieldMenuItemType)
}

// SetDrinkType sets the "drinkType" field.
func (m *MenuMutation) SetDrinkType(mt menu.DrinkType) {
	m.drinkType = &mt
}

// DrinkType returns the value of the "drinkType" field in the mutation.
func (m *MenuMutation) DrinkType() (r menu.DrinkType, exists bool) {
	v := m.drinkType
	if v == nil {
		return
	}
	return *v, true
}

// OldDrinkType returns the old "drinkType" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDrinkType(ctx context.Context) (v menu.DrinkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrinkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrinkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrinkType: %w", err)
	}
	return oldValue.DrinkType, nil
}

// ClearDrinkType clears the value of the "drinkType" field.
func (m *MenuMutation) ClearDrinkType() {
	m.drinkType = nil
	m.clearedFields[menu.FieldDrinkType] = struct{}{}
}

// DrinkTypeCleared returns if the "drinkType" field was cleared in this mutation.
func (m *MenuMutation) DrinkTypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldDrinkType]
	return ok
}

// ResetDrinkType resets all changes to the "drinkType" field.
func (m *MenuMutation) ResetDrinkType() {
	m.drinkType = nil
	delete(m.clearedFields, menu.FieldDrinkType)
}

// SetDietaryType sets the "dietaryType" field.
func (m *MenuMutation) SetDietaryType(mt menu.DietaryType) {
	m.dietaryType = &mt
}

// DietaryType returns the value of the "dietaryType" field in the mutation.
func (m *MenuMutation) DietaryType() (r menu.DietaryType, exists bool) {
	v := m.dietaryType
	if v == nil {
		return
	}
	return *v, true
}

// OldDietaryType returns the old "dietaryType" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDietaryType(ctx context.Context) (v menu.DietaryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDietaryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDietaryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDietaryType: %w", err)
	}
	return oldValue.DietaryType, nil
}

// ClearDietaryType clears the value of the "dietaryType" field.
func (m *MenuMutation) ClearDietaryType() {
	m.dietaryType = nil
	m.clearedFields[menu.FieldDietaryType] = struct{}{}
}

// DietaryTypeCleared returns if the "dietaryType" field was cleared in this mutation.
func (m *MenuMutation) DietaryTypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldDietaryType]
	return ok
}

// ResetDietaryType resets all changes to the "dietaryType" field.
func (m *MenuMutation) ResetDietaryType() {
	m.dietaryType = nil
	delete(m.clearedFields, menu.FieldDietaryType)
}

// SetIsAvailable sets the "is_available" field.
func (m *MenuMutation) SetIsAvailable(b bool) {
	m.is_available = &b
}

// IsAvailable returns the value of the "is_available" field in the mutation.
func (m *MenuMutation) IsAvailable() (r bool, exists bool) {
	v := m.is_available
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAvailable returns the old "is_available" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAvailable: %w", err)
	}
	return oldValue.IsAvailable, nil
}

// ResetIsAvailable resets all changes to the "is_available" field.
func (m *MenuMutation) ResetIsAvailable() {
	m.is_available = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menu.FieldUpdatedAt)
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *MenuMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *MenuMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *MenuMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *MenuMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *MenuMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *MenuMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *MenuMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *MenuMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *MenuMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *MenuMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *MenuMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *MenuMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *MenuMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *MenuMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddMenuItemIDs adds the "menu_items" edge to the MenuItem entity by ids.
func (m *MenuMutation) AddMenuItemIDs(ids ...string) {
	if m.menu_items == nil {
		m.menu_items = make(map[string]struct{})
	}
	for i := range ids {
		m.menu_items[ids[i]] = struct{}{}
	}
}

// ClearMenuItems clears the "menu_items" edge to the MenuItem entity.
func (m *MenuMutation) ClearMenuItems() {
	m.clearedmenu_items = true
}

// MenuItemsCleared reports if the "menu_items" edge to the MenuItem entity was cleared.
func (m *MenuMutation) MenuItemsCleared() bool {
	return m.clearedmenu_items
}

// RemoveMenuItemIDs removes the "menu_items" edge to the MenuItem entity by IDs.
func (m *MenuMutation) RemoveMenuItemIDs(ids ...string) {
	if m.removedmenu_items == nil {
		m.removedmenu_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menu_items, ids[i])
		m.removedmenu_items[ids[i]] = struct{}{}
	}
}

// RemovedMenuItems returns the removed IDs of the "menu_items" edge to the MenuItem entity.
func (m *MenuMutation) RemovedMenuItemsIDs() (ids []string) {
	for id := range m.removedmenu_items {
		ids = append(ids, id)
	}
	return
}

// MenuItemsIDs returns the "menu_items" edge IDs in the mutation.
func (m *MenuMutation) MenuItemsIDs() (ids []string) {
	for id := range m.menu_items {
		ids = append(ids, id)
	}
	return
}

// ResetMenuItems resets all changes to the "menu_items" edge.
func (m *MenuMutation) ResetMenuItems() {
	m.menu_items = nil
	m.clearedmenu_items = false
	m.removedmenu_items = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *MenuMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *MenuMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *MenuMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *MenuMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *MenuMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *MenuMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *MenuMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddCreatedByIDs adds the "created_by" edge to the User entity by ids.
func (m *MenuMutation) AddCreatedByIDs(ids ...string) {
	if m.created_by == nil {
		m.created_by = make(map[string]struct{})
	}
	for i := range ids {
		m.created_by[ids[i]] = struct{}{}
	}
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *MenuMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *MenuMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// RemoveCreatedByIDs removes the "created_by" edge to the User entity by IDs.
func (m *MenuMutation) RemoveCreatedByIDs(ids ...string) {
	if m.removedcreated_by == nil {
		m.removedcreated_by = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_by, ids[i])
		m.removedcreated_by[ids[i]] = struct{}{}
	}
}

// RemovedCreatedBy returns the removed IDs of the "created_by" edge to the User entity.
func (m *MenuMutation) RemovedCreatedByIDs() (ids []string) {
	for id := range m.removedcreated_by {
		ids = append(ids, id)
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
func (m *MenuMutation) CreatedByIDs() (ids []string) {
	for id := range m.created_by {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *MenuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
	m.removedcreated_by = nil
}

// AddUpdatedByIDs adds the "updated_by" edge to the User entity by ids.
func (m *MenuMutation) AddUpdatedByIDs(ids ...string) {
	if m.updated_by == nil {
		m.updated_by = make(map[string]struct{})
	}
	for i := range ids {
		m.updated_by[ids[i]] = struct{}{}
	}
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *MenuMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *MenuMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// RemoveUpdatedByIDs removes the "updated_by" edge to the User entity by IDs.
func (m *MenuMutation) RemoveUpdatedByIDs(ids ...string) {
	if m.removedupdated_by == nil {
		m.removedupdated_by = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.updated_by, ids[i])
		m.removedupdated_by[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedBy returns the removed IDs of the "updated_by" edge to the User entity.
func (m *MenuMutation) RemovedUpdatedByIDs() (ids []string) {
	for id := range m.removedupdated_by {
		ids = append(ids, id)
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
func (m *MenuMutation) UpdatedByIDs() (ids []string) {
	for id := range m.updated_by {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *MenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
	m.removedupdated_by = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.deleted_at != nil {
		fields = append(fields, menu.FieldDeletedAt)
	}
	if m.is_deleted != nil {
		fields = append(fields, menu.FieldIsDeleted)
	}
	if m.description != nil {
		fields = append(fields, menu.FieldDescription)
	}
	if m.options != nil {
		fields = append(fields, menu.FieldOptions)
	}
	if m.foodType != nil {
		fields = append(fields, menu.FieldFoodType)
	}
	if m.menuItemType != nil {
		fields = append(fields, menu.FieldMenuItemType)
	}
	if m.drinkType != nil {
		fields = append(fields, menu.FieldDrinkType)
	}
	if m.dietaryType != nil {
		fields = append(fields, menu.FieldDietaryType)
	}
	if m.is_available != nil {
		fields = append(fields, menu.FieldIsAvailable)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldName:
		return m.Name()
	case menu.FieldDeletedAt:
		return m.DeletedAt()
	case menu.FieldIsDeleted:
		return m.IsDeleted()
	case menu.FieldDescription:
		return m.Description()
	case menu.FieldOptions:
		return m.Options()
	case menu.FieldFoodType:
		return m.FoodType()
	case menu.FieldMenuItemType:
		return m.MenuItemType()
	case menu.FieldDrinkType:
		return m.DrinkType()
	case menu.FieldDietaryType:
		return m.DietaryType()
	case menu.FieldIsAvailable:
		return m.IsAvailable()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case menu.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case menu.FieldDescription:
		return m.OldDescription(ctx)
	case menu.FieldOptions:
		return m.OldOptions(ctx)
	case menu.FieldFoodType:
		return m.OldFoodType(ctx)
	case menu.FieldMenuItemType:
		return m.OldMenuItemType(ctx)
	case menu.FieldDrinkType:
		return m.OldDrinkType(ctx)
	case menu.FieldDietaryType:
		return m.OldDietaryType(ctx)
	case menu.FieldIsAvailable:
		return m.OldIsAvailable(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldDeletedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case menu.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case menu.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case menu.FieldOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case menu.FieldFoodType:
		v, ok := value.(menu.FoodType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodType(v)
		return nil
	case menu.FieldMenuItemType:
		v, ok := value.(menu.MenuItemType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuItemType(v)
		return nil
	case menu.FieldDrinkType:
		v, ok := value.(menu.DrinkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrinkType(v)
		return nil
	case menu.FieldDietaryType:
		v, ok := value.(menu.DietaryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDietaryType(v)
		return nil
	case menu.FieldIsAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAvailable(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldDeletedAt) {
		fields = append(fields, menu.FieldDeletedAt)
	}
	if m.FieldCleared(menu.FieldDescription) {
		fields = append(fields, menu.FieldDescription)
	}
	if m.FieldCleared(menu.FieldOptions) {
		fields = append(fields, menu.FieldOptions)
	}
	if m.FieldCleared(menu.FieldFoodType) {
		fields = append(fields, menu.FieldFoodType)
	}
	if m.FieldCleared(menu.FieldMenuItemType) {
		fields = append(fields, menu.FieldMenuItemType)
	}
	if m.FieldCleared(menu.FieldDrinkType) {
		fields = append(fields, menu.FieldDrinkType)
	}
	if m.FieldCleared(menu.FieldDietaryType) {
		fields = append(fields, menu.FieldDietaryType)
	}
	if m.FieldCleared(menu.FieldUpdatedAt) {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case menu.FieldDescription:
		m.ClearDescription()
		return nil
	case menu.FieldOptions:
		m.ClearOptions()
		return nil
	case menu.FieldFoodType:
		m.ClearFoodType()
		return nil
	case menu.FieldMenuItemType:
		m.ClearMenuItemType()
		return nil
	case menu.FieldDrinkType:
		m.ClearDrinkType()
		return nil
	case menu.FieldDietaryType:
		m.ClearDietaryType()
		return nil
	case menu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case menu.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case menu.FieldDescription:
		m.ResetDescription()
		return nil
	case menu.FieldOptions:
		m.ResetOptions()
		return nil
	case menu.FieldFoodType:
		m.ResetFoodType()
		return nil
	case menu.FieldMenuItemType:
		m.ResetMenuItemType()
		return nil
	case menu.FieldDrinkType:
		m.ResetDrinkType()
		return nil
	case menu.FieldDietaryType:
		m.ResetDietaryType()
		return nil
	case menu.FieldIsAvailable:
		m.ResetIsAvailable()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.place != nil {
		edges = append(edges, menu.EdgePlace)
	}
	if m.categories != nil {
		edges = append(edges, menu.EdgeCategories)
	}
	if m.menu_items != nil {
		edges = append(edges, menu.EdgeMenuItems)
	}
	if m.media != nil {
		edges = append(edges, menu.EdgeMedia)
	}
	if m.created_by != nil {
		edges = append(edges, menu.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, menu.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.menu_items))
		for id := range m.menu_items {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeCreatedBy:
		ids := make([]ent.Value, 0, len(m.created_by))
		for id := range m.created_by {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeUpdatedBy:
		ids := make([]ent.Value, 0, len(m.updated_by))
		for id := range m.updated_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedplace != nil {
		edges = append(edges, menu.EdgePlace)
	}
	if m.removedcategories != nil {
		edges = append(edges, menu.EdgeCategories)
	}
	if m.removedmenu_items != nil {
		edges = append(edges, menu.EdgeMenuItems)
	}
	if m.removedmedia != nil {
		edges = append(edges, menu.EdgeMedia)
	}
	if m.removedcreated_by != nil {
		edges = append(edges, menu.EdgeCreatedBy)
	}
	if m.removedupdated_by != nil {
		edges = append(edges, menu.EdgeUpdatedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.removedmenu_items))
		for id := range m.removedmenu_items {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeCreatedBy:
		ids := make([]ent.Value, 0, len(m.removedcreated_by))
		for id := range m.removedcreated_by {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeUpdatedBy:
		ids := make([]ent.Value, 0, len(m.removedupdated_by))
		for id := range m.removedupdated_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedplace {
		edges = append(edges, menu.EdgePlace)
	}
	if m.clearedcategories {
		edges = append(edges, menu.EdgeCategories)
	}
	if m.clearedmenu_items {
		edges = append(edges, menu.EdgeMenuItems)
	}
	if m.clearedmedia {
		edges = append(edges, menu.EdgeMedia)
	}
	if m.clearedcreated_by {
		edges = append(edges, menu.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, menu.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgePlace:
		return m.clearedplace
	case menu.EdgeCategories:
		return m.clearedcategories
	case menu.EdgeMenuItems:
		return m.clearedmenu_items
	case menu.EdgeMedia:
		return m.clearedmedia
	case menu.EdgeCreatedBy:
		return m.clearedcreated_by
	case menu.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgePlace:
		m.ResetPlace()
		return nil
	case menu.EdgeCategories:
		m.ResetCategories()
		return nil
	case menu.EdgeMenuItems:
		m.ResetMenuItems()
		return nil
	case menu.EdgeMedia:
		m.ResetMedia()
		return nil
	case menu.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case menu.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuItemMutation represents an operation that mutates the MenuItem nodes in the graph.
type MenuItemMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	name                   *string
	description            *string
	price                  *float64
	addprice               *float64
	currency               *string
	is_available           *bool
	preparation_time       *int
	addpreparation_time    *int
	options                *[]string
	appendoptions          []string
	deleted_at             *string
	_type                  *menuitem.Type
	status                 *menuitem.Status
	_DrinkType             *menuitem.DrinkType
	_DietaryType           *menuitem.DietaryType
	is_deleted             *bool
	calories               *int
	addcalories            *int
	serve_size             *int
	addserve_size          *int
	available_from         *time.Time
	available_until        *time.Time
	image_url              *string
	spiciness_level        *menuitem.SpicinessLevel
	allergens              *[]string
	appendallergens        []string
	chef_special_note      *string
	rating                 *int
	addrating              *int
	review_count           *int
	addreview_count        *int
	category               *string
	order_count            *int
	addorder_count         *int
	sku                    *string
	is_featured            *bool
	is_new                 *bool
	is_seasonal            *bool
	season                 *string
	discount_percentage    *int
	adddiscount_percentage *int
	promotion_description  *string
	promotion_start        *time.Time
	promotion_end          *time.Time
	tags                   *[]string
	appendtags             []string
	related_items          *[]string
	appendrelated_items    []string
	clearedFields          map[string]struct{}
	menu                   map[string]struct{}
	removedmenu            map[string]struct{}
	clearedmenu            bool
	inventory              *string
	clearedinventory       bool
	media                  map[string]struct{}
	removedmedia           map[string]struct{}
	clearedmedia           bool
	order_items            map[string]struct{}
	removedorder_items     map[string]struct{}
	clearedorder_items     bool
	done                   bool
	oldValue               func(context.Context) (*MenuItem, error)
	predicates             []predicate.MenuItem
}

var _ ent.Mutation = (*MenuItemMutation)(nil)

// menuitemOption allows management of the mutation configuration using functional options.
type menuitemOption func(*MenuItemMutation)

// newMenuItemMutation creates new mutation for the MenuItem entity.
func newMenuItemMutation(c config, op Op, opts ...menuitemOption) *MenuItemMutation {
	m := &MenuItemMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuItemID sets the ID field of the mutation.
func withMenuItemID(id string) menuitemOption {
	return func(m *MenuItemMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuItem
		)
		m.oldValue = func(ctx context.Context) (*MenuItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuItem sets the old MenuItem of the mutation.
func withMenuItem(node *MenuItem) menuitemOption {
	return func(m *MenuItemMutation) {
		m.oldValue = func(context.Context) (*MenuItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuItem entities.
func (m *MenuItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MenuItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MenuItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MenuItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MenuItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[menuitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MenuItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MenuItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, menuitem.FieldDescription)
}

// SetPrice sets the "price" field.
func (m *MenuItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MenuItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MenuItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MenuItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *MenuItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetCurrency sets the "currency" field.
func (m *MenuItemMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *MenuItemMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *MenuItemMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[menuitem.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *MenuItemMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *MenuItemMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, menuitem.FieldCurrency)
}

// SetIsAvailable sets the "is_available" field.
func (m *MenuItemMutation) SetIsAvailable(b bool) {
	m.is_available = &b
}

// IsAvailable returns the value of the "is_available" field in the mutation.
func (m *MenuItemMutation) IsAvailable() (r bool, exists bool) {
	v := m.is_available
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAvailable returns the old "is_available" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldIsAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAvailable: %w", err)
	}
	return oldValue.IsAvailable, nil
}

// ResetIsAvailable resets all changes to the "is_available" field.
func (m *MenuItemMutation) ResetIsAvailable() {
	m.is_available = nil
}

// SetPreparationTime sets the "preparation_time" field.
func (m *MenuItemMutation) SetPreparationTime(i int) {
	m.preparation_time = &i
	m.addpreparation_time = nil
}

// PreparationTime returns the value of the "preparation_time" field in the mutation.
func (m *MenuItemMutation) PreparationTime() (r int, exists bool) {
	v := m.preparation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPreparationTime returns the old "preparation_time" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPreparationTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreparationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreparationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreparationTime: %w", err)
	}
	return oldValue.PreparationTime, nil
}

// AddPreparationTime adds i to the "preparation_time" field.
func (m *MenuItemMutation) AddPreparationTime(i int) {
	if m.addpreparation_time != nil {
		*m.addpreparation_time += i
	} else {
		m.addpreparation_time = &i
	}
}

// AddedPreparationTime returns the value that was added to the "preparation_time" field in this mutation.
func (m *MenuItemMutation) AddedPreparationTime() (r int, exists bool) {
	v := m.addpreparation_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearPreparationTime clears the value of the "preparation_time" field.
func (m *MenuItemMutation) ClearPreparationTime() {
	m.preparation_time = nil
	m.addpreparation_time = nil
	m.clearedFields[menuitem.FieldPreparationTime] = struct{}{}
}

// PreparationTimeCleared returns if the "preparation_time" field was cleared in this mutation.
func (m *MenuItemMutation) PreparationTimeCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldPreparationTime]
	return ok
}

// ResetPreparationTime resets all changes to the "preparation_time" field.
func (m *MenuItemMutation) ResetPreparationTime() {
	m.preparation_time = nil
	m.addpreparation_time = nil
	delete(m.clearedFields, menuitem.FieldPreparationTime)
}

// SetOptions sets the "options" field.
func (m *MenuItemMutation) SetOptions(s []string) {
	m.options = &s
	m.appendoptions = nil
}

// Options returns the value of the "options" field in the mutation.
func (m *MenuItemMutation) Options() (r []string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// AppendOptions adds s to the "options" field.
func (m *MenuItemMutation) AppendOptions(s []string) {
	m.appendoptions = append(m.appendoptions, s...)
}

// AppendedOptions returns the list of values that were appended to the "options" field in this mutation.
func (m *MenuItemMutation) AppendedOptions() ([]string, bool) {
	if len(m.appendoptions) == 0 {
		return nil, false
	}
	return m.appendoptions, true
}

// ClearOptions clears the value of the "options" field.
func (m *MenuItemMutation) ClearOptions() {
	m.options = nil
	m.appendoptions = nil
	m.clearedFields[menuitem.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *MenuItemMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *MenuItemMutation) ResetOptions() {
	m.options = nil
	m.appendoptions = nil
	delete(m.clearedFields, menuitem.FieldOptions)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MenuItemMutation) SetDeletedAt(s string) {
	m.deleted_at = &s
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MenuItemMutation) DeletedAt() (r string, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldDeletedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MenuItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[menuitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MenuItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MenuItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, menuitem.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *MenuItemMutation) SetType(value menuitem.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuItemMutation) GetType() (r menuitem.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldType(ctx context.Context) (v menuitem.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MenuItemMutation) ClearType() {
	m._type = nil
	m.clearedFields[menuitem.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MenuItemMutation) TypeCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MenuItemMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, menuitem.FieldType)
}

// SetStatus sets the "status" field.
func (m *MenuItemMutation) SetStatus(value menuitem.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MenuItemMutation) Status() (r menuitem.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldStatus(ctx context.Context) (v menuitem.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MenuItemMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[menuitem.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MenuItemMutation) StatusCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MenuItemMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, menuitem.FieldStatus)
}

// SetDrinkType sets the "DrinkType" field.
func (m *MenuItemMutation) SetDrinkType(mt menuitem.DrinkType) {
	m._DrinkType = &mt
}

// DrinkType returns the value of the "DrinkType" field in the mutation.
func (m *MenuItemMutation) DrinkType() (r menuitem.DrinkType, exists bool) {
	v := m._DrinkType
	if v == nil {
		return
	}
	return *v, true
}

// OldDrinkType returns the old "DrinkType" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldDrinkType(ctx context.Context) (v menuitem.DrinkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrinkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrinkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrinkType: %w", err)
	}
	return oldValue.DrinkType, nil
}

// ClearDrinkType clears the value of the "DrinkType" field.
func (m *MenuItemMutation) ClearDrinkType() {
	m._DrinkType = nil
	m.clearedFields[menuitem.FieldDrinkType] = struct{}{}
}

// DrinkTypeCleared returns if the "DrinkType" field was cleared in this mutation.
func (m *MenuItemMutation) DrinkTypeCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldDrinkType]
	return ok
}

// ResetDrinkType resets all changes to the "DrinkType" field.
func (m *MenuItemMutation) ResetDrinkType() {
	m._DrinkType = nil
	delete(m.clearedFields, menuitem.FieldDrinkType)
}

// SetDietaryType sets the "DietaryType" field.
func (m *MenuItemMutation) SetDietaryType(mt menuitem.DietaryType) {
	m._DietaryType = &mt
}

// DietaryType returns the value of the "DietaryType" field in the mutation.
func (m *MenuItemMutation) DietaryType() (r menuitem.DietaryType, exists bool) {
	v := m._DietaryType
	if v == nil {
		return
	}
	return *v, true
}

// OldDietaryType returns the old "DietaryType" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldDietaryType(ctx context.Context) (v menuitem.DietaryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDietaryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDietaryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDietaryType: %w", err)
	}
	return oldValue.DietaryType, nil
}

// ClearDietaryType clears the value of the "DietaryType" field.
func (m *MenuItemMutation) ClearDietaryType() {
	m._DietaryType = nil
	m.clearedFields[menuitem.FieldDietaryType] = struct{}{}
}

// DietaryTypeCleared returns if the "DietaryType" field was cleared in this mutation.
func (m *MenuItemMutation) DietaryTypeCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldDietaryType]
	return ok
}

// ResetDietaryType resets all changes to the "DietaryType" field.
func (m *MenuItemMutation) ResetDietaryType() {
	m._DietaryType = nil
	delete(m.clearedFields, menuitem.FieldDietaryType)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *MenuItemMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *MenuItemMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *MenuItemMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCalories sets the "calories" field.
func (m *MenuItemMutation) SetCalories(i int) {
	m.calories = &i
	m.addcalories = nil
}

// Calories returns the value of the "calories" field in the mutation.
func (m *MenuItemMutation) Calories() (r int, exists bool) {
	v := m.calories
	if v == nil {
		return
	}
	return *v, true
}

// OldCalories returns the old "calories" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldCalories(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalories: %w", err)
	}
	return oldValue.Calories, nil
}

// AddCalories adds i to the "calories" field.
func (m *MenuItemMutation) AddCalories(i int) {
	if m.addcalories != nil {
		*m.addcalories += i
	} else {
		m.addcalories = &i
	}
}

// AddedCalories returns the value that was added to the "calories" field in this mutation.
func (m *MenuItemMutation) AddedCalories() (r int, exists bool) {
	v := m.addcalories
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalories clears the value of the "calories" field.
func (m *MenuItemMutation) ClearCalories() {
	m.calories = nil
	m.addcalories = nil
	m.clearedFields[menuitem.FieldCalories] = struct{}{}
}

// CaloriesCleared returns if the "calories" field was cleared in this mutation.
func (m *MenuItemMutation) CaloriesCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldCalories]
	return ok
}

// ResetCalories resets all changes to the "calories" field.
func (m *MenuItemMutation) ResetCalories() {
	m.calories = nil
	m.addcalories = nil
	delete(m.clearedFields, menuitem.FieldCalories)
}

// SetServeSize sets the "serve_size" field.
func (m *MenuItemMutation) SetServeSize(i int) {
	m.serve_size = &i
	m.addserve_size = nil
}

// ServeSize returns the value of the "serve_size" field in the mutation.
func (m *MenuItemMutation) ServeSize() (r int, exists bool) {
	v := m.serve_size
	if v == nil {
		return
	}
	return *v, true
}

// OldServeSize returns the old "serve_size" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldServeSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServeSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServeSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServeSize: %w", err)
	}
	return oldValue.ServeSize, nil
}

// AddServeSize adds i to the "serve_size" field.
func (m *MenuItemMutation) AddServeSize(i int) {
	if m.addserve_size != nil {
		*m.addserve_size += i
	} else {
		m.addserve_size = &i
	}
}

// AddedServeSize returns the value that was added to the "serve_size" field in this mutation.
func (m *MenuItemMutation) AddedServeSize() (r int, exists bool) {
	v := m.addserve_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearServeSize clears the value of the "serve_size" field.
func (m *MenuItemMutation) ClearServeSize() {
	m.serve_size = nil
	m.addserve_size = nil
	m.clearedFields[menuitem.FieldServeSize] = struct{}{}
}

// ServeSizeCleared returns if the "serve_size" field was cleared in this mutation.
func (m *MenuItemMutation) ServeSizeCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldServeSize]
	return ok
}

// ResetServeSize resets all changes to the "serve_size" field.
func (m *MenuItemMutation) ResetServeSize() {
	m.serve_size = nil
	m.addserve_size = nil
	delete(m.clearedFields, menuitem.FieldServeSize)
}

// SetAvailableFrom sets the "available_from" field.
func (m *MenuItemMutation) SetAvailableFrom(t time.Time) {
	m.available_from = &t
}

// AvailableFrom returns the value of the "available_from" field in the mutation.
func (m *MenuItemMutation) AvailableFrom() (r time.Time, exists bool) {
	v := m.available_from
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableFrom returns the old "available_from" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldAvailableFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableFrom: %w", err)
	}
	return oldValue.AvailableFrom, nil
}

// ClearAvailableFrom clears the value of the "available_from" field.
func (m *MenuItemMutation) ClearAvailableFrom() {
	m.available_from = nil
	m.clearedFields[menuitem.FieldAvailableFrom] = struct{}{}
}

// AvailableFromCleared returns if the "available_from" field was cleared in this mutation.
func (m *MenuItemMutation) AvailableFromCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldAvailableFrom]
	return ok
}

// ResetAvailableFrom resets all changes to the "available_from" field.
func (m *MenuItemMutation) ResetAvailableFrom() {
	m.available_from = nil
	delete(m.clearedFields, menuitem.FieldAvailableFrom)
}

// SetAvailableUntil sets the "available_until" field.
func (m *MenuItemMutation) SetAvailableUntil(t time.Time) {
	m.available_until = &t
}

// AvailableUntil returns the value of the "available_until" field in the mutation.
func (m *MenuItemMutation) AvailableUntil() (r time.Time, exists bool) {
	v := m.available_until
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableUntil returns the old "available_until" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldAvailableUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableUntil: %w", err)
	}
	return oldValue.AvailableUntil, nil
}

// ClearAvailableUntil clears the value of the "available_until" field.
func (m *MenuItemMutation) ClearAvailableUntil() {
	m.available_until = nil
	m.clearedFields[menuitem.FieldAvailableUntil] = struct{}{}
}

// AvailableUntilCleared returns if the "available_until" field was cleared in this mutation.
func (m *MenuItemMutation) AvailableUntilCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldAvailableUntil]
	return ok
}

// ResetAvailableUntil resets all changes to the "available_until" field.
func (m *MenuItemMutation) ResetAvailableUntil() {
	m.available_until = nil
	delete(m.clearedFields, menuitem.FieldAvailableUntil)
}

// SetImageURL sets the "image_url" field.
func (m *MenuItemMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *MenuItemMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *MenuItemMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[menuitem.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *MenuItemMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *MenuItemMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, menuitem.FieldImageURL)
}

// SetSpicinessLevel sets the "spiciness_level" field.
func (m *MenuItemMutation) SetSpicinessLevel(ml menuitem.SpicinessLevel) {
	m.spiciness_level = &ml
}

// SpicinessLevel returns the value of the "spiciness_level" field in the mutation.
func (m *MenuItemMutation) SpicinessLevel() (r menuitem.SpicinessLevel, exists bool) {
	v := m.spiciness_level
	if v == nil {
		return
	}
	return *v, true
}

// OldSpicinessLevel returns the old "spiciness_level" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldSpicinessLevel(ctx context.Context) (v menuitem.SpicinessLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpicinessLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpicinessLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpicinessLevel: %w", err)
	}
	return oldValue.SpicinessLevel, nil
}

// ClearSpicinessLevel clears the value of the "spiciness_level" field.
func (m *MenuItemMutation) ClearSpicinessLevel() {
	m.spiciness_level = nil
	m.clearedFields[menuitem.FieldSpicinessLevel] = struct{}{}
}

// SpicinessLevelCleared returns if the "spiciness_level" field was cleared in this mutation.
func (m *MenuItemMutation) SpicinessLevelCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldSpicinessLevel]
	return ok
}

// ResetSpicinessLevel resets all changes to the "spiciness_level" field.
func (m *MenuItemMutation) ResetSpicinessLevel() {
	m.spiciness_level = nil
	delete(m.clearedFields, menuitem.FieldSpicinessLevel)
}

// SetAllergens sets the "allergens" field.
func (m *MenuItemMutation) SetAllergens(s []string) {
	m.allergens = &s
	m.appendallergens = nil
}

// Allergens returns the value of the "allergens" field in the mutation.
func (m *MenuItemMutation) Allergens() (r []string, exists bool) {
	v := m.allergens
	if v == nil {
		return
	}
	return *v, true
}

// OldAllergens returns the old "allergens" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldAllergens(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllergens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllergens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllergens: %w", err)
	}
	return oldValue.Allergens, nil
}

// AppendAllergens adds s to the "allergens" field.
func (m *MenuItemMutation) AppendAllergens(s []string) {
	m.appendallergens = append(m.appendallergens, s...)
}

// AppendedAllergens returns the list of values that were appended to the "allergens" field in this mutation.
func (m *MenuItemMutation) AppendedAllergens() ([]string, bool) {
	if len(m.appendallergens) == 0 {
		return nil, false
	}
	return m.appendallergens, true
}

// ClearAllergens clears the value of the "allergens" field.
func (m *MenuItemMutation) ClearAllergens() {
	m.allergens = nil
	m.appendallergens = nil
	m.clearedFields[menuitem.FieldAllergens] = struct{}{}
}

// AllergensCleared returns if the "allergens" field was cleared in this mutation.
func (m *MenuItemMutation) AllergensCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldAllergens]
	return ok
}

// ResetAllergens resets all changes to the "allergens" field.
func (m *MenuItemMutation) ResetAllergens() {
	m.allergens = nil
	m.appendallergens = nil
	delete(m.clearedFields, menuitem.FieldAllergens)
}

// SetChefSpecialNote sets the "chef_special_note" field.
func (m *MenuItemMutation) SetChefSpecialNote(s string) {
	m.chef_special_note = &s
}

// ChefSpecialNote returns the value of the "chef_special_note" field in the mutation.
func (m *MenuItemMutation) ChefSpecialNote() (r string, exists bool) {
	v := m.chef_special_note
	if v == nil {
		return
	}
	return *v, true
}

// OldChefSpecialNote returns the old "chef_special_note" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldChefSpecialNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChefSpecialNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChefSpecialNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChefSpecialNote: %w", err)
	}
	return oldValue.ChefSpecialNote, nil
}

// ClearChefSpecialNote clears the value of the "chef_special_note" field.
func (m *MenuItemMutation) ClearChefSpecialNote() {
	m.chef_special_note = nil
	m.clearedFields[menuitem.FieldChefSpecialNote] = struct{}{}
}

// ChefSpecialNoteCleared returns if the "chef_special_note" field was cleared in this mutation.
func (m *MenuItemMutation) ChefSpecialNoteCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldChefSpecialNote]
	return ok
}

// ResetChefSpecialNote resets all changes to the "chef_special_note" field.
func (m *MenuItemMutation) ResetChefSpecialNote() {
	m.chef_special_note = nil
	delete(m.clearedFields, menuitem.FieldChefSpecialNote)
}

// SetRating sets the "rating" field.
func (m *MenuItemMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *MenuItemMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *MenuItemMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *MenuItemMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ClearRating clears the value of the "rating" field.
func (m *MenuItemMutation) ClearRating() {
	m.rating = nil
	m.addrating = nil
	m.clearedFields[menuitem.FieldRating] = struct{}{}
}

// RatingCleared returns if the "rating" field was cleared in this mutation.
func (m *MenuItemMutation) RatingCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldRating]
	return ok
}

// ResetRating resets all changes to the "rating" field.
func (m *MenuItemMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
	delete(m.clearedFields, menuitem.FieldRating)
}

// SetReviewCount sets the "review_count" field.
func (m *MenuItemMutation) SetReviewCount(i int) {
	m.review_count = &i
	m.addreview_count = nil
}

// ReviewCount returns the value of the "review_count" field in the mutation.
func (m *MenuItemMutation) ReviewCount() (r int, exists bool) {
	v := m.review_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewCount returns the old "review_count" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldReviewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewCount: %w", err)
	}
	return oldValue.ReviewCount, nil
}

// AddReviewCount adds i to the "review_count" field.
func (m *MenuItemMutation) AddReviewCount(i int) {
	if m.addreview_count != nil {
		*m.addreview_count += i
	} else {
		m.addreview_count = &i
	}
}

// AddedReviewCount returns the value that was added to the "review_count" field in this mutation.
func (m *MenuItemMutation) AddedReviewCount() (r int, exists bool) {
	v := m.addreview_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearReviewCount clears the value of the "review_count" field.
func (m *MenuItemMutation) ClearReviewCount() {
	m.review_count = nil
	m.addreview_count = nil
	m.clearedFields[menuitem.FieldReviewCount] = struct{}{}
}

// ReviewCountCleared returns if the "review_count" field was cleared in this mutation.
func (m *MenuItemMutation) ReviewCountCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldReviewCount]
	return ok
}

// ResetReviewCount resets all changes to the "review_count" field.
func (m *MenuItemMutation) ResetReviewCount() {
	m.review_count = nil
	m.addreview_count = nil
	delete(m.clearedFields, menuitem.FieldReviewCount)
}

// SetCategory sets the "category" field.
func (m *MenuItemMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *MenuItemMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *MenuItemMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[menuitem.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *MenuItemMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *MenuItemMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, menuitem.FieldCategory)
}

// SetOrderCount sets the "order_count" field.
func (m *MenuItemMutation) SetOrderCount(i int) {
	m.order_count = &i
	m.addorder_count = nil
}

// OrderCount returns the value of the "order_count" field in the mutation.
func (m *MenuItemMutation) OrderCount() (r int, exists bool) {
	v := m.order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCount returns the old "order_count" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldOrderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCount: %w", err)
	}
	return oldValue.OrderCount, nil
}

// AddOrderCount adds i to the "order_count" field.
func (m *MenuItemMutation) AddOrderCount(i int) {
	if m.addorder_count != nil {
		*m.addorder_count += i
	} else {
		m.addorder_count = &i
	}
}

// AddedOrderCount returns the value that was added to the "order_count" field in this mutation.
func (m *MenuItemMutation) AddedOrderCount() (r int, exists bool) {
	v := m.addorder_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderCount clears the value of the "order_count" field.
func (m *MenuItemMutation) ClearOrderCount() {
	m.order_count = nil
	m.addorder_count = nil
	m.clearedFields[menuitem.FieldOrderCount] = struct{}{}
}

// OrderCountCleared returns if the "order_count" field was cleared in this mutation.
func (m *MenuItemMutation) OrderCountCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldOrderCount]
	return ok
}

// ResetOrderCount resets all changes to the "order_count" field.
func (m *MenuItemMutation) ResetOrderCount() {
	m.order_count = nil
	m.addorder_count = nil
	delete(m.clearedFields, menuitem.FieldOrderCount)
}

// SetSku sets the "sku" field.
func (m *MenuItemMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *MenuItemMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ClearSku clears the value of the "sku" field.
func (m *MenuItemMutation) ClearSku() {
	m.sku = nil
	m.clearedFields[menuitem.FieldSku] = struct{}{}
}

// SkuCleared returns if the "sku" field was cleared in this mutation.
func (m *MenuItemMutation) SkuCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldSku]
	return ok
}

// ResetSku resets all changes to the "sku" field.
func (m *MenuItemMutation) ResetSku() {
	m.sku = nil
	delete(m.clearedFields, menuitem.FieldSku)
}

// SetIsFeatured sets the "is_featured" field.
func (m *MenuItemMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *MenuItemMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ClearIsFeatured clears the value of the "is_featured" field.
func (m *MenuItemMutation) ClearIsFeatured() {
	m.is_featured = nil
	m.clearedFields[menuitem.FieldIsFeatured] = struct{}{}
}

// IsFeaturedCleared returns if the "is_featured" field was cleared in this mutation.
func (m *MenuItemMutation) IsFeaturedCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldIsFeatured]
	return ok
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *MenuItemMutation) ResetIsFeatured() {
	m.is_featured = nil
	delete(m.clearedFields, menuitem.FieldIsFeatured)
}

// SetIsNew sets the "is_new" field.
func (m *MenuItemMutation) SetIsNew(b bool) {
	m.is_new = &b
}

// IsNew returns the value of the "is_new" field in the mutation.
func (m *MenuItemMutation) IsNew() (r bool, exists bool) {
	v := m.is_new
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNew returns the old "is_new" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldIsNew(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNew: %w", err)
	}
	return oldValue.IsNew, nil
}

// ClearIsNew clears the value of the "is_new" field.
func (m *MenuItemMutation) ClearIsNew() {
	m.is_new = nil
	m.clearedFields[menuitem.FieldIsNew] = struct{}{}
}

// IsNewCleared returns if the "is_new" field was cleared in this mutation.
func (m *MenuItemMutation) IsNewCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldIsNew]
	return ok
}

// ResetIsNew resets all changes to the "is_new" field.
func (m *MenuItemMutation) ResetIsNew() {
	m.is_new = nil
	delete(m.clearedFields, menuitem.FieldIsNew)
}

// SetIsSeasonal sets the "is_seasonal" field.
func (m *MenuItemMutation) SetIsSeasonal(b bool) {
	m.is_seasonal = &b
}

// IsSeasonal returns the value of the "is_seasonal" field in the mutation.
func (m *MenuItemMutation) IsSeasonal() (r bool, exists bool) {
	v := m.is_seasonal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSeasonal returns the old "is_seasonal" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldIsSeasonal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSeasonal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSeasonal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSeasonal: %w", err)
	}
	return oldValue.IsSeasonal, nil
}

// ClearIsSeasonal clears the value of the "is_seasonal" field.
func (m *MenuItemMutation) ClearIsSeasonal() {
	m.is_seasonal = nil
	m.clearedFields[menuitem.FieldIsSeasonal] = struct{}{}
}

// IsSeasonalCleared returns if the "is_seasonal" field was cleared in this mutation.
func (m *MenuItemMutation) IsSeasonalCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldIsSeasonal]
	return ok
}

// ResetIsSeasonal resets all changes to the "is_seasonal" field.
func (m *MenuItemMutation) ResetIsSeasonal() {
	m.is_seasonal = nil
	delete(m.clearedFields, menuitem.FieldIsSeasonal)
}

// SetSeason sets the "season" field.
func (m *MenuItemMutation) SetSeason(s string) {
	m.season = &s
}

// Season returns the value of the "season" field in the mutation.
func (m *MenuItemMutation) Season() (r string, exists bool) {
	v := m.season
	if v == nil {
		return
	}
	return *v, true
}

// OldSeason returns the old "season" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldSeason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeason: %w", err)
	}
	return oldValue.Season, nil
}

// ClearSeason clears the value of the "season" field.
func (m *MenuItemMutation) ClearSeason() {
	m.season = nil
	m.clearedFields[menuitem.FieldSeason] = struct{}{}
}

// SeasonCleared returns if the "season" field was cleared in this mutation.
func (m *MenuItemMutation) SeasonCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldSeason]
	return ok
}

// ResetSeason resets all changes to the "season" field.
func (m *MenuItemMutation) ResetSeason() {
	m.season = nil
	delete(m.clearedFields, menuitem.FieldSeason)
}

// SetDiscountPercentage sets the "discount_percentage" field.
func (m *MenuItemMutation) SetDiscountPercentage(i int) {
	m.discount_percentage = &i
	m.adddiscount_percentage = nil
}

// DiscountPercentage returns the value of the "discount_percentage" field in the mutation.
func (m *MenuItemMutation) DiscountPercentage() (r int, exists bool) {
	v := m.discount_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPercentage returns the old "discount_percentage" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldDiscountPercentage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPercentage: %w", err)
	}
	return oldValue.DiscountPercentage, nil
}

// AddDiscountPercentage adds i to the "discount_percentage" field.
func (m *MenuItemMutation) AddDiscountPercentage(i int) {
	if m.adddiscount_percentage != nil {
		*m.adddiscount_percentage += i
	} else {
		m.adddiscount_percentage = &i
	}
}

// AddedDiscountPercentage returns the value that was added to the "discount_percentage" field in this mutation.
func (m *MenuItemMutation) AddedDiscountPercentage() (r int, exists bool) {
	v := m.adddiscount_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiscountPercentage clears the value of the "discount_percentage" field.
func (m *MenuItemMutation) ClearDiscountPercentage() {
	m.discount_percentage = nil
	m.adddiscount_percentage = nil
	m.clearedFields[menuitem.FieldDiscountPercentage] = struct{}{}
}

// DiscountPercentageCleared returns if the "discount_percentage" field was cleared in this mutation.
func (m *MenuItemMutation) DiscountPercentageCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldDiscountPercentage]
	return ok
}

// ResetDiscountPercentage resets all changes to the "discount_percentage" field.
func (m *MenuItemMutation) ResetDiscountPercentage() {
	m.discount_percentage = nil
	m.adddiscount_percentage = nil
	delete(m.clearedFields, menuitem.FieldDiscountPercentage)
}

// SetPromotionDescription sets the "promotion_description" field.
func (m *MenuItemMutation) SetPromotionDescription(s string) {
	m.promotion_description = &s
}

// PromotionDescription returns the value of the "promotion_description" field in the mutation.
func (m *MenuItemMutation) PromotionDescription() (r string, exists bool) {
	v := m.promotion_description
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionDescription returns the old "promotion_description" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPromotionDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotionDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotionDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionDescription: %w", err)
	}
	return oldValue.PromotionDescription, nil
}

// ClearPromotionDescription clears the value of the "promotion_description" field.
func (m *MenuItemMutation) ClearPromotionDescription() {
	m.promotion_description = nil
	m.clearedFields[menuitem.FieldPromotionDescription] = struct{}{}
}

// PromotionDescriptionCleared returns if the "promotion_description" field was cleared in this mutation.
func (m *MenuItemMutation) PromotionDescriptionCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldPromotionDescription]
	return ok
}

// ResetPromotionDescription resets all changes to the "promotion_description" field.
func (m *MenuItemMutation) ResetPromotionDescription() {
	m.promotion_description = nil
	delete(m.clearedFields, menuitem.FieldPromotionDescription)
}

// SetPromotionStart sets the "promotion_start" field.
func (m *MenuItemMutation) SetPromotionStart(t time.Time) {
	m.promotion_start = &t
}

// PromotionStart returns the value of the "promotion_start" field in the mutation.
func (m *MenuItemMutation) PromotionStart() (r time.Time, exists bool) {
	v := m.promotion_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionStart returns the old "promotion_start" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPromotionStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotionStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotionStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionStart: %w", err)
	}
	return oldValue.PromotionStart, nil
}

// ClearPromotionStart clears the value of the "promotion_start" field.
func (m *MenuItemMutation) ClearPromotionStart() {
	m.promotion_start = nil
	m.clearedFields[menuitem.FieldPromotionStart] = struct{}{}
}

// PromotionStartCleared returns if the "promotion_start" field was cleared in this mutation.
func (m *MenuItemMutation) PromotionStartCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldPromotionStart]
	return ok
}

// ResetPromotionStart resets all changes to the "promotion_start" field.
func (m *MenuItemMutation) ResetPromotionStart() {
	m.promotion_start = nil
	delete(m.clearedFields, menuitem.FieldPromotionStart)
}

// SetPromotionEnd sets the "promotion_end" field.
func (m *MenuItemMutation) SetPromotionEnd(t time.Time) {
	m.promotion_end = &t
}

// PromotionEnd returns the value of the "promotion_end" field in the mutation.
func (m *MenuItemMutation) PromotionEnd() (r time.Time, exists bool) {
	v := m.promotion_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionEnd returns the old "promotion_end" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPromotionEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotionEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotionEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionEnd: %w", err)
	}
	return oldValue.PromotionEnd, nil
}

// ClearPromotionEnd clears the value of the "promotion_end" field.
func (m *MenuItemMutation) ClearPromotionEnd() {
	m.promotion_end = nil
	m.clearedFields[menuitem.FieldPromotionEnd] = struct{}{}
}

// PromotionEndCleared returns if the "promotion_end" field was cleared in this mutation.
func (m *MenuItemMutation) PromotionEndCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldPromotionEnd]
	return ok
}

// ResetPromotionEnd resets all changes to the "promotion_end" field.
func (m *MenuItemMutation) ResetPromotionEnd() {
	m.promotion_end = nil
	delete(m.clearedFields, menuitem.FieldPromotionEnd)
}

// SetTags sets the "tags" field.
func (m *MenuItemMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *MenuItemMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *MenuItemMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *MenuItemMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *MenuItemMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[menuitem.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *MenuItemMutation) TagsCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *MenuItemMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, menuitem.FieldTags)
}

// SetRelatedItems sets the "related_items" field.
func (m *MenuItemMutation) SetRelatedItems(s []string) {
	m.related_items = &s
	m.appendrelated_items = nil
}

// RelatedItems returns the value of the "related_items" field in the mutation.
func (m *MenuItemMutation) RelatedItems() (r []string, exists bool) {
	v := m.related_items
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedItems returns the old "related_items" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldRelatedItems(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedItems: %w", err)
	}
	return oldValue.RelatedItems, nil
}

// AppendRelatedItems adds s to the "related_items" field.
func (m *MenuItemMutation) AppendRelatedItems(s []string) {
	m.appendrelated_items = append(m.appendrelated_items, s...)
}

// AppendedRelatedItems returns the list of values that were appended to the "related_items" field in this mutation.
func (m *MenuItemMutation) AppendedRelatedItems() ([]string, bool) {
	if len(m.appendrelated_items) == 0 {
		return nil, false
	}
	return m.appendrelated_items, true
}

// ClearRelatedItems clears the value of the "related_items" field.
func (m *MenuItemMutation) ClearRelatedItems() {
	m.related_items = nil
	m.appendrelated_items = nil
	m.clearedFields[menuitem.FieldRelatedItems] = struct{}{}
}

// RelatedItemsCleared returns if the "related_items" field was cleared in this mutation.
func (m *MenuItemMutation) RelatedItemsCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldRelatedItems]
	return ok
}

// ResetRelatedItems resets all changes to the "related_items" field.
func (m *MenuItemMutation) ResetRelatedItems() {
	m.related_items = nil
	m.appendrelated_items = nil
	delete(m.clearedFields, menuitem.FieldRelatedItems)
}

// AddMenuIDs adds the "menu" edge to the Menu entity by ids.
func (m *MenuItemMutation) AddMenuIDs(ids ...string) {
	if m.menu == nil {
		m.menu = make(map[string]struct{})
	}
	for i := range ids {
		m.menu[ids[i]] = struct{}{}
	}
}

// ClearMenu clears the "menu" edge to the Menu entity.
func (m *MenuItemMutation) ClearMenu() {
	m.clearedmenu = true
}

// MenuCleared reports if the "menu" edge to the Menu entity was cleared.
func (m *MenuItemMutation) MenuCleared() bool {
	return m.clearedmenu
}

// RemoveMenuIDs removes the "menu" edge to the Menu entity by IDs.
func (m *MenuItemMutation) RemoveMenuIDs(ids ...string) {
	if m.removedmenu == nil {
		m.removedmenu = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menu, ids[i])
		m.removedmenu[ids[i]] = struct{}{}
	}
}

// RemovedMenu returns the removed IDs of the "menu" edge to the Menu entity.
func (m *MenuItemMutation) RemovedMenuIDs() (ids []string) {
	for id := range m.removedmenu {
		ids = append(ids, id)
	}
	return
}

// MenuIDs returns the "menu" edge IDs in the mutation.
func (m *MenuItemMutation) MenuIDs() (ids []string) {
	for id := range m.menu {
		ids = append(ids, id)
	}
	return
}

// ResetMenu resets all changes to the "menu" edge.
func (m *MenuItemMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
	m.removedmenu = nil
}

// SetInventoryID sets the "inventory" edge to the PlaceInventory entity by id.
func (m *MenuItemMutation) SetInventoryID(id string) {
	m.inventory = &id
}

// ClearInventory clears the "inventory" edge to the PlaceInventory entity.
func (m *MenuItemMutation) ClearInventory() {
	m.clearedinventory = true
}

// InventoryCleared reports if the "inventory" edge to the PlaceInventory entity was cleared.
func (m *MenuItemMutation) InventoryCleared() bool {
	return m.clearedinventory
}

// InventoryID returns the "inventory" edge ID in the mutation.
func (m *MenuItemMutation) InventoryID() (id string, exists bool) {
	if m.inventory != nil {
		return *m.inventory, true
	}
	return
}

// InventoryIDs returns the "inventory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryID instead. It exists only for internal usage by the builders.
func (m *MenuItemMutation) InventoryIDs() (ids []string) {
	if id := m.inventory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventory resets all changes to the "inventory" edge.
func (m *MenuItemMutation) ResetInventory() {
	m.inventory = nil
	m.clearedinventory = false
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *MenuItemMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *MenuItemMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *MenuItemMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *MenuItemMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *MenuItemMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *MenuItemMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *MenuItemMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *MenuItemMutation) AddOrderItemIDs(ids ...string) {
	if m.order_items == nil {
		m.order_items = make(map[string]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *MenuItemMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *MenuItemMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *MenuItemMutation) RemoveOrderItemIDs(ids ...string) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *MenuItemMutation) RemovedOrderItemsIDs() (ids []string) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *MenuItemMutation) OrderItemsIDs() (ids []string) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *MenuItemMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// Where appends a list predicates to the MenuItemMutation builder.
func (m *MenuItemMutation) Where(ps ...predicate.MenuItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuItem).
func (m *MenuItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuItemMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.name != nil {
		fields = append(fields, menuitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, menuitem.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, menuitem.FieldPrice)
	}
	if m.currency != nil {
		fields = append(fields, menuitem.FieldCurrency)
	}
	if m.is_available != nil {
		fields = append(fields, menuitem.FieldIsAvailable)
	}
	if m.preparation_time != nil {
		fields = append(fields, menuitem.FieldPreparationTime)
	}
	if m.options != nil {
		fields = append(fields, menuitem.FieldOptions)
	}
	if m.deleted_at != nil {
		fields = append(fields, menuitem.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, menuitem.FieldType)
	}
	if m.status != nil {
		fields = append(fields, menuitem.FieldStatus)
	}
	if m._DrinkType != nil {
		fields = append(fields, menuitem.FieldDrinkType)
	}
	if m._DietaryType != nil {
		fields = append(fields, menuitem.FieldDietaryType)
	}
	if m.is_deleted != nil {
		fields = append(fields, menuitem.FieldIsDeleted)
	}
	if m.calories != nil {
		fields = append(fields, menuitem.FieldCalories)
	}
	if m.serve_size != nil {
		fields = append(fields, menuitem.FieldServeSize)
	}
	if m.available_from != nil {
		fields = append(fields, menuitem.FieldAvailableFrom)
	}
	if m.available_until != nil {
		fields = append(fields, menuitem.FieldAvailableUntil)
	}
	if m.image_url != nil {
		fields = append(fields, menuitem.FieldImageURL)
	}
	if m.spiciness_level != nil {
		fields = append(fields, menuitem.FieldSpicinessLevel)
	}
	if m.allergens != nil {
		fields = append(fields, menuitem.FieldAllergens)
	}
	if m.chef_special_note != nil {
		fields = append(fields, menuitem.FieldChefSpecialNote)
	}
	if m.rating != nil {
		fields = append(fields, menuitem.FieldRating)
	}
	if m.review_count != nil {
		fields = append(fields, menuitem.FieldReviewCount)
	}
	if m.category != nil {
		fields = append(fields, menuitem.FieldCategory)
	}
	if m.order_count != nil {
		fields = append(fields, menuitem.FieldOrderCount)
	}
	if m.sku != nil {
		fields = append(fields, menuitem.FieldSku)
	}
	if m.is_featured != nil {
		fields = append(fields, menuitem.FieldIsFeatured)
	}
	if m.is_new != nil {
		fields = append(fields, menuitem.FieldIsNew)
	}
	if m.is_seasonal != nil {
		fields = append(fields, menuitem.FieldIsSeasonal)
	}
	if m.season != nil {
		fields = append(fields, menuitem.FieldSeason)
	}
	if m.discount_percentage != nil {
		fields = append(fields, menuitem.FieldDiscountPercentage)
	}
	if m.promotion_description != nil {
		fields = append(fields, menuitem.FieldPromotionDescription)
	}
	if m.promotion_start != nil {
		fields = append(fields, menuitem.FieldPromotionStart)
	}
	if m.promotion_end != nil {
		fields = append(fields, menuitem.FieldPromotionEnd)
	}
	if m.tags != nil {
		fields = append(fields, menuitem.FieldTags)
	}
	if m.related_items != nil {
		fields = append(fields, menuitem.FieldRelatedItems)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldName:
		return m.Name()
	case menuitem.FieldDescription:
		return m.Description()
	case menuitem.FieldPrice:
		return m.Price()
	case menuitem.FieldCurrency:
		return m.Currency()
	case menuitem.FieldIsAvailable:
		return m.IsAvailable()
	case menuitem.FieldPreparationTime:
		return m.PreparationTime()
	case menuitem.FieldOptions:
		return m.Options()
	case menuitem.FieldDeletedAt:
		return m.DeletedAt()
	case menuitem.FieldType:
		return m.GetType()
	case menuitem.FieldStatus:
		return m.Status()
	case menuitem.FieldDrinkType:
		return m.DrinkType()
	case menuitem.FieldDietaryType:
		return m.DietaryType()
	case menuitem.FieldIsDeleted:
		return m.IsDeleted()
	case menuitem.FieldCalories:
		return m.Calories()
	case menuitem.FieldServeSize:
		return m.ServeSize()
	case menuitem.FieldAvailableFrom:
		return m.AvailableFrom()
	case menuitem.FieldAvailableUntil:
		return m.AvailableUntil()
	case menuitem.FieldImageURL:
		return m.ImageURL()
	case menuitem.FieldSpicinessLevel:
		return m.SpicinessLevel()
	case menuitem.FieldAllergens:
		return m.Allergens()
	case menuitem.FieldChefSpecialNote:
		return m.ChefSpecialNote()
	case menuitem.FieldRating:
		return m.Rating()
	case menuitem.FieldReviewCount:
		return m.ReviewCount()
	case menuitem.FieldCategory:
		return m.Category()
	case menuitem.FieldOrderCount:
		return m.OrderCount()
	case menuitem.FieldSku:
		return m.Sku()
	case menuitem.FieldIsFeatured:
		return m.IsFeatured()
	case menuitem.FieldIsNew:
		return m.IsNew()
	case menuitem.FieldIsSeasonal:
		return m.IsSeasonal()
	case menuitem.FieldSeason:
		return m.Season()
	case menuitem.FieldDiscountPercentage:
		return m.DiscountPercentage()
	case menuitem.FieldPromotionDescription:
		return m.PromotionDescription()
	case menuitem.FieldPromotionStart:
		return m.PromotionStart()
	case menuitem.FieldPromotionEnd:
		return m.PromotionEnd()
	case menuitem.FieldTags:
		return m.Tags()
	case menuitem.FieldRelatedItems:
		return m.RelatedItems()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuitem.FieldName:
		return m.OldName(ctx)
	case menuitem.FieldDescription:
		return m.OldDescription(ctx)
	case menuitem.FieldPrice:
		return m.OldPrice(ctx)
	case menuitem.FieldCurrency:
		return m.OldCurrency(ctx)
	case menuitem.FieldIsAvailable:
		return m.OldIsAvailable(ctx)
	case menuitem.FieldPreparationTime:
		return m.OldPreparationTime(ctx)
	case menuitem.FieldOptions:
		return m.OldOptions(ctx)
	case menuitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case menuitem.FieldType:
		return m.OldType(ctx)
	case menuitem.FieldStatus:
		return m.OldStatus(ctx)
	case menuitem.FieldDrinkType:
		return m.OldDrinkType(ctx)
	case menuitem.FieldDietaryType:
		return m.OldDietaryType(ctx)
	case menuitem.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case menuitem.FieldCalories:
		return m.OldCalories(ctx)
	case menuitem.FieldServeSize:
		return m.OldServeSize(ctx)
	case menuitem.FieldAvailableFrom:
		return m.OldAvailableFrom(ctx)
	case menuitem.FieldAvailableUntil:
		return m.OldAvailableUntil(ctx)
	case menuitem.FieldImageURL:
		return m.OldImageURL(ctx)
	case menuitem.FieldSpicinessLevel:
		return m.OldSpicinessLevel(ctx)
	case menuitem.FieldAllergens:
		return m.OldAllergens(ctx)
	case menuitem.FieldChefSpecialNote:
		return m.OldChefSpecialNote(ctx)
	case menuitem.FieldRating:
		return m.OldRating(ctx)
	case menuitem.FieldReviewCount:
		return m.OldReviewCount(ctx)
	case menuitem.FieldCategory:
		return m.OldCategory(ctx)
	case menuitem.FieldOrderCount:
		return m.OldOrderCount(ctx)
	case menuitem.FieldSku:
		return m.OldSku(ctx)
	case menuitem.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case menuitem.FieldIsNew:
		return m.OldIsNew(ctx)
	case menuitem.FieldIsSeasonal:
		return m.OldIsSeasonal(ctx)
	case menuitem.FieldSeason:
		return m.OldSeason(ctx)
	case menuitem.FieldDiscountPercentage:
		return m.OldDiscountPercentage(ctx)
	case menuitem.FieldPromotionDescription:
		return m.OldPromotionDescription(ctx)
	case menuitem.FieldPromotionStart:
		return m.OldPromotionStart(ctx)
	case menuitem.FieldPromotionEnd:
		return m.OldPromotionEnd(ctx)
	case menuitem.FieldTags:
		return m.OldTags(ctx)
	case menuitem.FieldRelatedItems:
		return m.OldRelatedItems(ctx)
	}
	return nil, fmt.Errorf("unknown MenuItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menuitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case menuitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case menuitem.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case menuitem.FieldIsAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAvailable(v)
		return nil
	case menuitem.FieldPreparationTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreparationTime(v)
		return nil
	case menuitem.FieldOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case menuitem.FieldDeletedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case menuitem.FieldType:
		v, ok := value.(menuitem.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menuitem.FieldStatus:
		v, ok := value.(menuitem.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menuitem.FieldDrinkType:
		v, ok := value.(menuitem.DrinkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrinkType(v)
		return nil
	case menuitem.FieldDietaryType:
		v, ok := value.(menuitem.DietaryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDietaryType(v)
		return nil
	case menuitem.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case menuitem.FieldCalories:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalories(v)
		return nil
	case menuitem.FieldServeSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServeSize(v)
		return nil
	case menuitem.FieldAvailableFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableFrom(v)
		return nil
	case menuitem.FieldAvailableUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableUntil(v)
		return nil
	case menuitem.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case menuitem.FieldSpicinessLevel:
		v, ok := value.(menuitem.SpicinessLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpicinessLevel(v)
		return nil
	case menuitem.FieldAllergens:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllergens(v)
		return nil
	case menuitem.FieldChefSpecialNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChefSpecialNote(v)
		return nil
	case menuitem.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case menuitem.FieldReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewCount(v)
		return nil
	case menuitem.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case menuitem.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCount(v)
		return nil
	case menuitem.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case menuitem.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case menuitem.FieldIsNew:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNew(v)
		return nil
	case menuitem.FieldIsSeasonal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSeasonal(v)
		return nil
	case menuitem.FieldSeason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeason(v)
		return nil
	case menuitem.FieldDiscountPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPercentage(v)
		return nil
	case menuitem.FieldPromotionDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionDescription(v)
		return nil
	case menuitem.FieldPromotionStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionStart(v)
		return nil
	case menuitem.FieldPromotionEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionEnd(v)
		return nil
	case menuitem.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case menuitem.FieldRelatedItems:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedItems(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, menuitem.FieldPrice)
	}
	if m.addpreparation_time != nil {
		fields = append(fields, menuitem.FieldPreparationTime)
	}
	if m.addcalories != nil {
		fields = append(fields, menuitem.FieldCalories)
	}
	if m.addserve_size != nil {
		fields = append(fields, menuitem.FieldServeSize)
	}
	if m.addrating != nil {
		fields = append(fields, menuitem.FieldRating)
	}
	if m.addreview_count != nil {
		fields = append(fields, menuitem.FieldReviewCount)
	}
	if m.addorder_count != nil {
		fields = append(fields, menuitem.FieldOrderCount)
	}
	if m.adddiscount_percentage != nil {
		fields = append(fields, menuitem.FieldDiscountPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldPrice:
		return m.AddedPrice()
	case menuitem.FieldPreparationTime:
		return m.AddedPreparationTime()
	case menuitem.FieldCalories:
		return m.AddedCalories()
	case menuitem.FieldServeSize:
		return m.AddedServeSize()
	case menuitem.FieldRating:
		return m.AddedRating()
	case menuitem.FieldReviewCount:
		return m.AddedReviewCount()
	case menuitem.FieldOrderCount:
		return m.AddedOrderCount()
	case menuitem.FieldDiscountPercentage:
		return m.AddedDiscountPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case menuitem.FieldPreparationTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreparationTime(v)
		return nil
	case menuitem.FieldCalories:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalories(v)
		return nil
	case menuitem.FieldServeSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServeSize(v)
		return nil
	case menuitem.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case menuitem.FieldReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewCount(v)
		return nil
	case menuitem.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCount(v)
		return nil
	case menuitem.FieldDiscountPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menuitem.FieldDescription) {
		fields = append(fields, menuitem.FieldDescription)
	}
	if m.FieldCleared(menuitem.FieldCurrency) {
		fields = append(fields, menuitem.FieldCurrency)
	}
	if m.FieldCleared(menuitem.FieldPreparationTime) {
		fields = append(fields, menuitem.FieldPreparationTime)
	}
	if m.FieldCleared(menuitem.FieldOptions) {
		fields = append(fields, menuitem.FieldOptions)
	}
	if m.FieldCleared(menuitem.FieldDeletedAt) {
		fields = append(fields, menuitem.FieldDeletedAt)
	}
	if m.FieldCleared(menuitem.FieldType) {
		fields = append(fields, menuitem.FieldType)
	}
	if m.FieldCleared(menuitem.FieldStatus) {
		fields = append(fields, menuitem.FieldStatus)
	}
	if m.FieldCleared(menuitem.FieldDrinkType) {
		fields = append(fields, menuitem.FieldDrinkType)
	}
	if m.FieldCleared(menuitem.FieldDietaryType) {
		fields = append(fields, menuitem.FieldDietaryType)
	}
	if m.FieldCleared(menuitem.FieldCalories) {
		fields = append(fields, menuitem.FieldCalories)
	}
	if m.FieldCleared(menuitem.FieldServeSize) {
		fields = append(fields, menuitem.FieldServeSize)
	}
	if m.FieldCleared(menuitem.FieldAvailableFrom) {
		fields = append(fields, menuitem.FieldAvailableFrom)
	}
	if m.FieldCleared(menuitem.FieldAvailableUntil) {
		fields = append(fields, menuitem.FieldAvailableUntil)
	}
	if m.FieldCleared(menuitem.FieldImageURL) {
		fields = append(fields, menuitem.FieldImageURL)
	}
	if m.FieldCleared(menuitem.FieldSpicinessLevel) {
		fields = append(fields, menuitem.FieldSpicinessLevel)
	}
	if m.FieldCleared(menuitem.FieldAllergens) {
		fields = append(fields, menuitem.FieldAllergens)
	}
	if m.FieldCleared(menuitem.FieldChefSpecialNote) {
		fields = append(fields, menuitem.FieldChefSpecialNote)
	}
	if m.FieldCleared(menuitem.FieldRating) {
		fields = append(fields, menuitem.FieldRating)
	}
	if m.FieldCleared(menuitem.FieldReviewCount) {
		fields = append(fields, menuitem.FieldReviewCount)
	}
	if m.FieldCleared(menuitem.FieldCategory) {
		fields = append(fields, menuitem.FieldCategory)
	}
	if m.FieldCleared(menuitem.FieldOrderCount) {
		fields = append(fields, menuitem.FieldOrderCount)
	}
	if m.FieldCleared(menuitem.FieldSku) {
		fields = append(fields, menuitem.FieldSku)
	}
	if m.FieldCleared(menuitem.FieldIsFeatured) {
		fields = append(fields, menuitem.FieldIsFeatured)
	}
	if m.FieldCleared(menuitem.FieldIsNew) {
		fields = append(fields, menuitem.FieldIsNew)
	}
	if m.FieldCleared(menuitem.FieldIsSeasonal) {
		fields = append(fields, menuitem.FieldIsSeasonal)
	}
	if m.FieldCleared(menuitem.FieldSeason) {
		fields = append(fields, menuitem.FieldSeason)
	}
	if m.FieldCleared(menuitem.FieldDiscountPercentage) {
		fields = append(fields, menuitem.FieldDiscountPercentage)
	}
	if m.FieldCleared(menuitem.FieldPromotionDescription) {
		fields = append(fields, menuitem.FieldPromotionDescription)
	}
	if m.FieldCleared(menuitem.FieldPromotionStart) {
		fields = append(fields, menuitem.FieldPromotionStart)
	}
	if m.FieldCleared(menuitem.FieldPromotionEnd) {
		fields = append(fields, menuitem.FieldPromotionEnd)
	}
	if m.FieldCleared(menuitem.FieldTags) {
		fields = append(fields, menuitem.FieldTags)
	}
	if m.FieldCleared(menuitem.FieldRelatedItems) {
		fields = append(fields, menuitem.FieldRelatedItems)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuItemMutation) ClearField(name string) error {
	switch name {
	case menuitem.FieldDescription:
		m.ClearDescription()
		return nil
	case menuitem.FieldCurrency:
		m.ClearCurrency()
		return nil
	case menuitem.FieldPreparationTime:
		m.ClearPreparationTime()
		return nil
	case menuitem.FieldOptions:
		m.ClearOptions()
		return nil
	case menuitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case menuitem.FieldType:
		m.ClearType()
		return nil
	case menuitem.FieldStatus:
		m.ClearStatus()
		return nil
	case menuitem.FieldDrinkType:
		m.ClearDrinkType()
		return nil
	case menuitem.FieldDietaryType:
		m.ClearDietaryType()
		return nil
	case menuitem.FieldCalories:
		m.ClearCalories()
		return nil
	case menuitem.FieldServeSize:
		m.ClearServeSize()
		return nil
	case menuitem.FieldAvailableFrom:
		m.ClearAvailableFrom()
		return nil
	case menuitem.FieldAvailableUntil:
		m.ClearAvailableUntil()
		return nil
	case menuitem.FieldImageURL:
		m.ClearImageURL()
		return nil
	case menuitem.FieldSpicinessLevel:
		m.ClearSpicinessLevel()
		return nil
	case menuitem.FieldAllergens:
		m.ClearAllergens()
		return nil
	case menuitem.FieldChefSpecialNote:
		m.ClearChefSpecialNote()
		return nil
	case menuitem.FieldRating:
		m.ClearRating()
		return nil
	case menuitem.FieldReviewCount:
		m.ClearReviewCount()
		return nil
	case menuitem.FieldCategory:
		m.ClearCategory()
		return nil
	case menuitem.FieldOrderCount:
		m.ClearOrderCount()
		return nil
	case menuitem.FieldSku:
		m.ClearSku()
		return nil
	case menuitem.FieldIsFeatured:
		m.ClearIsFeatured()
		return nil
	case menuitem.FieldIsNew:
		m.ClearIsNew()
		return nil
	case menuitem.FieldIsSeasonal:
		m.ClearIsSeasonal()
		return nil
	case menuitem.FieldSeason:
		m.ClearSeason()
		return nil
	case menuitem.FieldDiscountPercentage:
		m.ClearDiscountPercentage()
		return nil
	case menuitem.FieldPromotionDescription:
		m.ClearPromotionDescription()
		return nil
	case menuitem.FieldPromotionStart:
		m.ClearPromotionStart()
		return nil
	case menuitem.FieldPromotionEnd:
		m.ClearPromotionEnd()
		return nil
	case menuitem.FieldTags:
		m.ClearTags()
		return nil
	case menuitem.FieldRelatedItems:
		m.ClearRelatedItems()
		return nil
	}
	return fmt.Errorf("unknown MenuItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuItemMutation) ResetField(name string) error {
	switch name {
	case menuitem.FieldName:
		m.ResetName()
		return nil
	case menuitem.FieldDescription:
		m.ResetDescription()
		return nil
	case menuitem.FieldPrice:
		m.ResetPrice()
		return nil
	case menuitem.FieldCurrency:
		m.ResetCurrency()
		return nil
	case menuitem.FieldIsAvailable:
		m.ResetIsAvailable()
		return nil
	case menuitem.FieldPreparationTime:
		m.ResetPreparationTime()
		return nil
	case menuitem.FieldOptions:
		m.ResetOptions()
		return nil
	case menuitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case menuitem.FieldType:
		m.ResetType()
		return nil
	case menuitem.FieldStatus:
		m.ResetStatus()
		return nil
	case menuitem.FieldDrinkType:
		m.ResetDrinkType()
		return nil
	case menuitem.FieldDietaryType:
		m.ResetDietaryType()
		return nil
	case menuitem.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case menuitem.FieldCalories:
		m.ResetCalories()
		return nil
	case menuitem.FieldServeSize:
		m.ResetServeSize()
		return nil
	case menuitem.FieldAvailableFrom:
		m.ResetAvailableFrom()
		return nil
	case menuitem.FieldAvailableUntil:
		m.ResetAvailableUntil()
		return nil
	case menuitem.FieldImageURL:
		m.ResetImageURL()
		return nil
	case menuitem.FieldSpicinessLevel:
		m.ResetSpicinessLevel()
		return nil
	case menuitem.FieldAllergens:
		m.ResetAllergens()
		return nil
	case menuitem.FieldChefSpecialNote:
		m.ResetChefSpecialNote()
		return nil
	case menuitem.FieldRating:
		m.ResetRating()
		return nil
	case menuitem.FieldReviewCount:
		m.ResetReviewCount()
		return nil
	case menuitem.FieldCategory:
		m.ResetCategory()
		return nil
	case menuitem.FieldOrderCount:
		m.ResetOrderCount()
		return nil
	case menuitem.FieldSku:
		m.ResetSku()
		return nil
	case menuitem.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case menuitem.FieldIsNew:
		m.ResetIsNew()
		return nil
	case menuitem.FieldIsSeasonal:
		m.ResetIsSeasonal()
		return nil
	case menuitem.FieldSeason:
		m.ResetSeason()
		return nil
	case menuitem.FieldDiscountPercentage:
		m.ResetDiscountPercentage()
		return nil
	case menuitem.FieldPromotionDescription:
		m.ResetPromotionDescription()
		return nil
	case menuitem.FieldPromotionStart:
		m.ResetPromotionStart()
		return nil
	case menuitem.FieldPromotionEnd:
		m.ResetPromotionEnd()
		return nil
	case menuitem.FieldTags:
		m.ResetTags()
		return nil
	case menuitem.FieldRelatedItems:
		m.ResetRelatedItems()
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.menu != nil {
		edges = append(edges, menuitem.EdgeMenu)
	}
	if m.inventory != nil {
		edges = append(edges, menuitem.EdgeInventory)
	}
	if m.media != nil {
		edges = append(edges, menuitem.EdgeMedia)
	}
	if m.order_items != nil {
		edges = append(edges, menuitem.EdgeOrderItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuitem.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.menu))
		for id := range m.menu {
			ids = append(ids, id)
		}
		return ids
	case menuitem.EdgeInventory:
		if id := m.inventory; id != nil {
			return []ent.Value{*id}
		}
	case menuitem.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case menuitem.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmenu != nil {
		edges = append(edges, menuitem.EdgeMenu)
	}
	if m.removedmedia != nil {
		edges = append(edges, menuitem.EdgeMedia)
	}
	if m.removedorder_items != nil {
		edges = append(edges, menuitem.EdgeOrderItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menuitem.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.removedmenu))
		for id := range m.removedmenu {
			ids = append(ids, id)
		}
		return ids
	case menuitem.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case menuitem.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmenu {
		edges = append(edges, menuitem.EdgeMenu)
	}
	if m.clearedinventory {
		edges = append(edges, menuitem.EdgeInventory)
	}
	if m.clearedmedia {
		edges = append(edges, menuitem.EdgeMedia)
	}
	if m.clearedorder_items {
		edges = append(edges, menuitem.EdgeOrderItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuItemMutation) EdgeCleared(name string) bool {
	switch name {
	case menuitem.EdgeMenu:
		return m.clearedmenu
	case menuitem.EdgeInventory:
		return m.clearedinventory
	case menuitem.EdgeMedia:
		return m.clearedmedia
	case menuitem.EdgeOrderItems:
		return m.clearedorder_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuItemMutation) ClearEdge(name string) error {
	switch name {
	case menuitem.EdgeInventory:
		m.ClearInventory()
		return nil
	}
	return fmt.Errorf("unknown MenuItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuItemMutation) ResetEdge(name string) error {
	switch name {
	case menuitem.EdgeMenu:
		m.ResetMenu()
		return nil
	case menuitem.EdgeInventory:
		m.ResetInventory()
		return nil
	case menuitem.EdgeMedia:
		m.ResetMedia()
		return nil
	case menuitem.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	}
	return fmt.Errorf("unknown MenuItem edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	title                   *string
	message                 *string
	link                    *string
	is_read                 *bool
	_type                   *int
	add_type                *int
	unread_count            *int
	addunread_count         *int
	created_at              *time.Time
	updated_at              *time.Time
	notifiable_type         *string
	notifiable_id           *string
	triggered_by            *string
	triggered_to            *string
	clearedFields           map[string]struct{}
	user                    map[string]struct{}
	removeduser             map[string]struct{}
	cleareduser             bool
	business_account        map[string]struct{}
	removedbusiness_account map[string]struct{}
	clearedbusiness_account bool
	place                   map[string]struct{}
	removedplace            map[string]struct{}
	clearedplace            bool
	post                    map[string]struct{}
	removedpost             map[string]struct{}
	clearedpost             bool
	comment                 map[string]struct{}
	removedcomment          map[string]struct{}
	clearedcomment          bool
	done                    bool
	oldValue                func(context.Context) (*Notification, error)
	predicates              []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id string) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *NotificationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *NotificationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *NotificationMutation) ResetMessage() {
	m.message = nil
}

// SetLink sets the "link" field.
func (m *NotificationMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *NotificationMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *NotificationMutation) ResetLink() {
	m.link = nil
}

// SetIsRead sets the "is_read" field.
func (m *NotificationMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *NotificationMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *NotificationMutation) ResetIsRead() {
	m.is_read = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *NotificationMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *NotificationMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetUnreadCount sets the "unread_count" field.
func (m *NotificationMutation) SetUnreadCount(i int) {
	m.unread_count = &i
	m.addunread_count = nil
}

// UnreadCount returns the value of the "unread_count" field in the mutation.
func (m *NotificationMutation) UnreadCount() (r int, exists bool) {
	v := m.unread_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUnreadCount returns the old "unread_count" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUnreadCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnreadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnreadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnreadCount: %w", err)
	}
	return oldValue.UnreadCount, nil
}

// AddUnreadCount adds i to the "unread_count" field.
func (m *NotificationMutation) AddUnreadCount(i int) {
	if m.addunread_count != nil {
		*m.addunread_count += i
	} else {
		m.addunread_count = &i
	}
}

// AddedUnreadCount returns the value that was added to the "unread_count" field in this mutation.
func (m *NotificationMutation) AddedUnreadCount() (r int, exists bool) {
	v := m.addunread_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnreadCount resets all changes to the "unread_count" field.
func (m *NotificationMutation) ResetUnreadCount() {
	m.unread_count = nil
	m.addunread_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNotifiableType sets the "notifiable_type" field.
func (m *NotificationMutation) SetNotifiableType(s string) {
	m.notifiable_type = &s
}

// NotifiableType returns the value of the "notifiable_type" field in the mutation.
func (m *NotificationMutation) NotifiableType() (r string, exists bool) {
	v := m.notifiable_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifiableType returns the old "notifiable_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldNotifiableType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifiableType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifiableType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifiableType: %w", err)
	}
	return oldValue.NotifiableType, nil
}

// ResetNotifiableType resets all changes to the "notifiable_type" field.
func (m *NotificationMutation) ResetNotifiableType() {
	m.notifiable_type = nil
}

// SetNotifiableID sets the "notifiable_id" field.
func (m *NotificationMutation) SetNotifiableID(s string) {
	m.notifiable_id = &s
}

// NotifiableID returns the value of the "notifiable_id" field in the mutation.
func (m *NotificationMutation) NotifiableID() (r string, exists bool) {
	v := m.notifiable_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifiableID returns the old "notifiable_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldNotifiableID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifiableID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifiableID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifiableID: %w", err)
	}
	return oldValue.NotifiableID, nil
}

// ResetNotifiableID resets all changes to the "notifiable_id" field.
func (m *NotificationMutation) ResetNotifiableID() {
	m.notifiable_id = nil
}

// SetTriggeredBy sets the "triggered_by" field.
func (m *NotificationMutation) SetTriggeredBy(s string) {
	m.triggered_by = &s
}

// TriggeredBy returns the value of the "triggered_by" field in the mutation.
func (m *NotificationMutation) TriggeredBy() (r string, exists bool) {
	v := m.triggered_by
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredBy returns the old "triggered_by" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTriggeredBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredBy: %w", err)
	}
	return oldValue.TriggeredBy, nil
}

// ResetTriggeredBy resets all changes to the "triggered_by" field.
func (m *NotificationMutation) ResetTriggeredBy() {
	m.triggered_by = nil
}

// SetTriggeredTo sets the "triggered_to" field.
func (m *NotificationMutation) SetTriggeredTo(s string) {
	m.triggered_to = &s
}

// TriggeredTo returns the value of the "triggered_to" field in the mutation.
func (m *NotificationMutation) TriggeredTo() (r string, exists bool) {
	v := m.triggered_to
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredTo returns the old "triggered_to" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTriggeredTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredTo: %w", err)
	}
	return oldValue.TriggeredTo, nil
}

// ResetTriggeredTo resets all changes to the "triggered_to" field.
func (m *NotificationMutation) ResetTriggeredTo() {
	m.triggered_to = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *NotificationMutation) AddUserIDs(ids ...string) {
	if m.user == nil {
		m.user = make(map[string]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotificationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotificationMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *NotificationMutation) RemoveUserIDs(ids ...string) {
	if m.removeduser == nil {
		m.removeduser = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *NotificationMutation) RemovedUserIDs() (ids []string) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *NotificationMutation) UserIDs() (ids []string) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddBusinessAccountIDs adds the "business_account" edge to the Business entity by ids.
func (m *NotificationMutation) AddBusinessAccountIDs(ids ...string) {
	if m.business_account == nil {
		m.business_account = make(map[string]struct{})
	}
	for i := range ids {
		m.business_account[ids[i]] = struct{}{}
	}
}

// ClearBusinessAccount clears the "business_account" edge to the Business entity.
func (m *NotificationMutation) ClearBusinessAccount() {
	m.clearedbusiness_account = true
}

// BusinessAccountCleared reports if the "business_account" edge to the Business entity was cleared.
func (m *NotificationMutation) BusinessAccountCleared() bool {
	return m.clearedbusiness_account
}

// RemoveBusinessAccountIDs removes the "business_account" edge to the Business entity by IDs.
func (m *NotificationMutation) RemoveBusinessAccountIDs(ids ...string) {
	if m.removedbusiness_account == nil {
		m.removedbusiness_account = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.business_account, ids[i])
		m.removedbusiness_account[ids[i]] = struct{}{}
	}
}

// RemovedBusinessAccount returns the removed IDs of the "business_account" edge to the Business entity.
func (m *NotificationMutation) RemovedBusinessAccountIDs() (ids []string) {
	for id := range m.removedbusiness_account {
		ids = append(ids, id)
	}
	return
}

// BusinessAccountIDs returns the "business_account" edge IDs in the mutation.
func (m *NotificationMutation) BusinessAccountIDs() (ids []string) {
	for id := range m.business_account {
		ids = append(ids, id)
	}
	return
}

// ResetBusinessAccount resets all changes to the "business_account" edge.
func (m *NotificationMutation) ResetBusinessAccount() {
	m.business_account = nil
	m.clearedbusiness_account = false
	m.removedbusiness_account = nil
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *NotificationMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *NotificationMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *NotificationMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *NotificationMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *NotificationMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *NotificationMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *NotificationMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddPostIDs adds the "post" edge to the Post entity by ids.
func (m *NotificationMutation) AddPostIDs(ids ...string) {
	if m.post == nil {
		m.post = make(map[string]struct{})
	}
	for i := range ids {
		m.post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "post" edge to the Post entity.
func (m *NotificationMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *NotificationMutation) PostCleared() bool {
	return m.clearedpost
}

// RemovePostIDs removes the "post" edge to the Post entity by IDs.
func (m *NotificationMutation) RemovePostIDs(ids ...string) {
	if m.removedpost == nil {
		m.removedpost = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post, ids[i])
		m.removedpost[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "post" edge to the Post entity.
func (m *NotificationMutation) RemovedPostIDs() (ids []string) {
	for id := range m.removedpost {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
func (m *NotificationMutation) PostIDs() (ids []string) {
	for id := range m.post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *NotificationMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
	m.removedpost = nil
}

// AddCommentIDs adds the "comment" edge to the Comment entity by ids.
func (m *NotificationMutation) AddCommentIDs(ids ...string) {
	if m.comment == nil {
		m.comment = make(map[string]struct{})
	}
	for i := range ids {
		m.comment[ids[i]] = struct{}{}
	}
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *NotificationMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *NotificationMutation) CommentCleared() bool {
	return m.clearedcomment
}

// RemoveCommentIDs removes the "comment" edge to the Comment entity by IDs.
func (m *NotificationMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomment == nil {
		m.removedcomment = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comment, ids[i])
		m.removedcomment[ids[i]] = struct{}{}
	}
}

// RemovedComment returns the removed IDs of the "comment" edge to the Comment entity.
func (m *NotificationMutation) RemovedCommentIDs() (ids []string) {
	for id := range m.removedcomment {
		ids = append(ids, id)
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
func (m *NotificationMutation) CommentIDs() (ids []string) {
	for id := range m.comment {
		ids = append(ids, id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *NotificationMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
	m.removedcomment = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, notification.FieldMessage)
	}
	if m.link != nil {
		fields = append(fields, notification.FieldLink)
	}
	if m.is_read != nil {
		fields = append(fields, notification.FieldIsRead)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.unread_count != nil {
		fields = append(fields, notification.FieldUnreadCount)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	if m.notifiable_type != nil {
		fields = append(fields, notification.FieldNotifiableType)
	}
	if m.notifiable_id != nil {
		fields = append(fields, notification.FieldNotifiableID)
	}
	if m.triggered_by != nil {
		fields = append(fields, notification.FieldTriggeredBy)
	}
	if m.triggered_to != nil {
		fields = append(fields, notification.FieldTriggeredTo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldMessage:
		return m.Message()
	case notification.FieldLink:
		return m.Link()
	case notification.FieldIsRead:
		return m.IsRead()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldUnreadCount:
		return m.UnreadCount()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	case notification.FieldNotifiableType:
		return m.NotifiableType()
	case notification.FieldNotifiableID:
		return m.NotifiableID()
	case notification.FieldTriggeredBy:
		return m.TriggeredBy()
	case notification.FieldTriggeredTo:
		return m.TriggeredTo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldMessage:
		return m.OldMessage(ctx)
	case notification.FieldLink:
		return m.OldLink(ctx)
	case notification.FieldIsRead:
		return m.OldIsRead(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldUnreadCount:
		return m.OldUnreadCount(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notification.FieldNotifiableType:
		return m.OldNotifiableType(ctx)
	case notification.FieldNotifiableID:
		return m.OldNotifiableID(ctx)
	case notification.FieldTriggeredBy:
		return m.OldTriggeredBy(ctx)
	case notification.FieldTriggeredTo:
		return m.OldTriggeredTo(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case notification.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case notification.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	case notification.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldUnreadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnreadCount(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notification.FieldNotifiableType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifiableType(v)
		return nil
	case notification.FieldNotifiableID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifiableID(v)
		return nil
	case notification.FieldTriggeredBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredBy(v)
		return nil
	case notification.FieldTriggeredTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredTo(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.addunread_count != nil {
		fields = append(fields, notification.FieldUnreadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldType:
		return m.AddedType()
	case notification.FieldUnreadCount:
		return m.AddedUnreadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case notification.FieldUnreadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnreadCount(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldMessage:
		m.ResetMessage()
		return nil
	case notification.FieldLink:
		m.ResetLink()
		return nil
	case notification.FieldIsRead:
		m.ResetIsRead()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldUnreadCount:
		m.ResetUnreadCount()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notification.FieldNotifiableType:
		m.ResetNotifiableType()
		return nil
	case notification.FieldNotifiableID:
		m.ResetNotifiableID()
		return nil
	case notification.FieldTriggeredBy:
		m.ResetTriggeredBy()
		return nil
	case notification.FieldTriggeredTo:
		m.ResetTriggeredTo()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, notification.EdgeUser)
	}
	if m.business_account != nil {
		edges = append(edges, notification.EdgeBusinessAccount)
	}
	if m.place != nil {
		edges = append(edges, notification.EdgePlace)
	}
	if m.post != nil {
		edges = append(edges, notification.EdgePost)
	}
	if m.comment != nil {
		edges = append(edges, notification.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeBusinessAccount:
		ids := make([]ent.Value, 0, len(m.business_account))
		for id := range m.business_account {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgePost:
		ids := make([]ent.Value, 0, len(m.post))
		for id := range m.post {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeComment:
		ids := make([]ent.Value, 0, len(m.comment))
		for id := range m.comment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeduser != nil {
		edges = append(edges, notification.EdgeUser)
	}
	if m.removedbusiness_account != nil {
		edges = append(edges, notification.EdgeBusinessAccount)
	}
	if m.removedplace != nil {
		edges = append(edges, notification.EdgePlace)
	}
	if m.removedpost != nil {
		edges = append(edges, notification.EdgePost)
	}
	if m.removedcomment != nil {
		edges = append(edges, notification.EdgeComment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeBusinessAccount:
		ids := make([]ent.Value, 0, len(m.removedbusiness_account))
		for id := range m.removedbusiness_account {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgePost:
		ids := make([]ent.Value, 0, len(m.removedpost))
		for id := range m.removedpost {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeComment:
		ids := make([]ent.Value, 0, len(m.removedcomment))
		for id := range m.removedcomment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, notification.EdgeUser)
	}
	if m.clearedbusiness_account {
		edges = append(edges, notification.EdgeBusinessAccount)
	}
	if m.clearedplace {
		edges = append(edges, notification.EdgePlace)
	}
	if m.clearedpost {
		edges = append(edges, notification.EdgePost)
	}
	if m.clearedcomment {
		edges = append(edges, notification.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeUser:
		return m.cleareduser
	case notification.EdgeBusinessAccount:
		return m.clearedbusiness_account
	case notification.EdgePlace:
		return m.clearedplace
	case notification.EdgePost:
		return m.clearedpost
	case notification.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeUser:
		m.ResetUser()
		return nil
	case notification.EdgeBusinessAccount:
		m.ResetBusinessAccount()
		return nil
	case notification.EdgePlace:
		m.ResetPlace()
		return nil
	case notification.EdgePost:
		m.ResetPost()
		return nil
	case notification.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	status             *order.Status
	total_amount       *float64
	addtotal_amount    *float64
	additional_info    *map[string]interface{}
	deleted_at         *string
	is_deleted         *bool
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	order_items        map[string]struct{}
	removedorder_items map[string]struct{}
	clearedorder_items bool
	table              map[string]struct{}
	removedtable       map[string]struct{}
	clearedtable       bool
	done               bool
	oldValue           func(context.Context) (*Order, error)
	predicates         []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id string) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *OrderMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *OrderMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *OrderMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *OrderMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *OrderMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetAdditionalInfo sets the "additional_info" field.
func (m *OrderMutation) SetAdditionalInfo(value map[string]interface{}) {
	m.additional_info = &value
}

// AdditionalInfo returns the value of the "additional_info" field in the mutation.
func (m *OrderMutation) AdditionalInfo() (r map[string]interface{}, exists bool) {
	v := m.additional_info
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalInfo returns the old "additional_info" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAdditionalInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalInfo: %w", err)
	}
	return oldValue.AdditionalInfo, nil
}

// ClearAdditionalInfo clears the value of the "additional_info" field.
func (m *OrderMutation) ClearAdditionalInfo() {
	m.additional_info = nil
	m.clearedFields[order.FieldAdditionalInfo] = struct{}{}
}

// AdditionalInfoCleared returns if the "additional_info" field was cleared in this mutation.
func (m *OrderMutation) AdditionalInfoCleared() bool {
	_, ok := m.clearedFields[order.FieldAdditionalInfo]
	return ok
}

// ResetAdditionalInfo resets all changes to the "additional_info" field.
func (m *OrderMutation) ResetAdditionalInfo() {
	m.additional_info = nil
	delete(m.clearedFields, order.FieldAdditionalInfo)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderMutation) SetDeletedAt(s string) {
	m.deleted_at = &s
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderMutation) DeletedAt() (r string, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeletedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[order.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, order.FieldDeletedAt)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *OrderMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *OrderMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *OrderMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OrderMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OrderMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddOrderItemIDs(ids ...string) {
	if m.order_items == nil {
		m.order_items = make(map[string]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveOrderItemIDs(ids ...string) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedOrderItemsIDs() (ids []string) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *OrderMutation) OrderItemsIDs() (ids []string) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *OrderMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddTableIDs adds the "table" edge to the PlaceTable entity by ids.
func (m *OrderMutation) AddTableIDs(ids ...string) {
	if m.table == nil {
		m.table = make(map[string]struct{})
	}
	for i := range ids {
		m.table[ids[i]] = struct{}{}
	}
}

// ClearTable clears the "table" edge to the PlaceTable entity.
func (m *OrderMutation) ClearTable() {
	m.clearedtable = true
}

// TableCleared reports if the "table" edge to the PlaceTable entity was cleared.
func (m *OrderMutation) TableCleared() bool {
	return m.clearedtable
}

// RemoveTableIDs removes the "table" edge to the PlaceTable entity by IDs.
func (m *OrderMutation) RemoveTableIDs(ids ...string) {
	if m.removedtable == nil {
		m.removedtable = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.table, ids[i])
		m.removedtable[ids[i]] = struct{}{}
	}
}

// RemovedTable returns the removed IDs of the "table" edge to the PlaceTable entity.
func (m *OrderMutation) RemovedTableIDs() (ids []string) {
	for id := range m.removedtable {
		ids = append(ids, id)
	}
	return
}

// TableIDs returns the "table" edge IDs in the mutation.
func (m *OrderMutation) TableIDs() (ids []string) {
	for id := range m.table {
		ids = append(ids, id)
	}
	return
}

// ResetTable resets all changes to the "table" edge.
func (m *OrderMutation) ResetTable() {
	m.table = nil
	m.clearedtable = false
	m.removedtable = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.total_amount != nil {
		fields = append(fields, order.FieldTotalAmount)
	}
	if m.additional_info != nil {
		fields = append(fields, order.FieldAdditionalInfo)
	}
	if m.deleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.is_deleted != nil {
		fields = append(fields, order.FieldIsDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldStatus:
		return m.Status()
	case order.FieldTotalAmount:
		return m.TotalAmount()
	case order.FieldAdditionalInfo:
		return m.AdditionalInfo()
	case order.FieldDeletedAt:
		return m.DeletedAt()
	case order.FieldIsDeleted:
		return m.IsDeleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case order.FieldAdditionalInfo:
		return m.OldAdditionalInfo(ctx)
	case order.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case order.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case order.FieldAdditionalInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalInfo(v)
		return nil
	case order.FieldDeletedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case order.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_amount != nil {
		fields = append(fields, order.FieldTotalAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldTotalAmount:
		return m.AddedTotalAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldAdditionalInfo) {
		fields = append(fields, order.FieldAdditionalInfo)
	}
	if m.FieldCleared(order.FieldDeletedAt) {
		fields = append(fields, order.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldAdditionalInfo:
		m.ClearAdditionalInfo()
		return nil
	case order.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case order.FieldAdditionalInfo:
		m.ResetAdditionalInfo()
		return nil
	case order.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case order.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, order.EdgeUser)
	}
	if m.order_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.table != nil {
		edges = append(edges, order.EdgeTable)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeTable:
		ids := make([]ent.Value, 0, len(m.table))
		for id := range m.table {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorder_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.removedtable != nil {
		edges = append(edges, order.EdgeTable)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeTable:
		ids := make([]ent.Value, 0, len(m.removedtable))
		for id := range m.removedtable {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, order.EdgeUser)
	}
	if m.clearedorder_items {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.clearedtable {
		edges = append(edges, order.EdgeTable)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeUser:
		return m.cleareduser
	case order.EdgeOrderItems:
		return m.clearedorder_items
	case order.EdgeTable:
		return m.clearedtable
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ResetUser()
		return nil
	case order.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case order.EdgeTable:
		m.ResetTable()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                Op
	typ               string
	id                *string
	quantity          *int
	addquantity       *int
	price_per_item    *float64
	addprice_per_item *float64
	total_price       *float64
	addtotal_price    *float64
	options           *[]string
	appendoptions     []string
	clearedFields     map[string]struct{}
	_order            map[string]struct{}
	removed_order     map[string]struct{}
	cleared_order     bool
	menu_item         map[string]struct{}
	removedmenu_item  map[string]struct{}
	clearedmenu_item  bool
	done              bool
	oldValue          func(context.Context) (*OrderItem, error)
	predicates        []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id string) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPricePerItem sets the "price_per_item" field.
func (m *OrderItemMutation) SetPricePerItem(f float64) {
	m.price_per_item = &f
	m.addprice_per_item = nil
}

// PricePerItem returns the value of the "price_per_item" field in the mutation.
func (m *OrderItemMutation) PricePerItem() (r float64, exists bool) {
	v := m.price_per_item
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerItem returns the old "price_per_item" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPricePerItem(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerItem: %w", err)
	}
	return oldValue.PricePerItem, nil
}

// AddPricePerItem adds f to the "price_per_item" field.
func (m *OrderItemMutation) AddPricePerItem(f float64) {
	if m.addprice_per_item != nil {
		*m.addprice_per_item += f
	} else {
		m.addprice_per_item = &f
	}
}

// AddedPricePerItem returns the value that was added to the "price_per_item" field in this mutation.
func (m *OrderItemMutation) AddedPricePerItem() (r float64, exists bool) {
	v := m.addprice_per_item
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerItem resets all changes to the "price_per_item" field.
func (m *OrderItemMutation) ResetPricePerItem() {
	m.price_per_item = nil
	m.addprice_per_item = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *OrderItemMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *OrderItemMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *OrderItemMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *OrderItemMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *OrderItemMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetOptions sets the "options" field.
func (m *OrderItemMutation) SetOptions(s []string) {
	m.options = &s
	m.appendoptions = nil
}

// Options returns the value of the "options" field in the mutation.
func (m *OrderItemMutation) Options() (r []string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// AppendOptions adds s to the "options" field.
func (m *OrderItemMutation) AppendOptions(s []string) {
	m.appendoptions = append(m.appendoptions, s...)
}

// AppendedOptions returns the list of values that were appended to the "options" field in this mutation.
func (m *OrderItemMutation) AppendedOptions() ([]string, bool) {
	if len(m.appendoptions) == 0 {
		return nil, false
	}
	return m.appendoptions, true
}

// ClearOptions clears the value of the "options" field.
func (m *OrderItemMutation) ClearOptions() {
	m.options = nil
	m.appendoptions = nil
	m.clearedFields[orderitem.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *OrderItemMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *OrderItemMutation) ResetOptions() {
	m.options = nil
	m.appendoptions = nil
	delete(m.clearedFields, orderitem.FieldOptions)
}

// AddOrderIDs adds the "order" edge to the Order entity by ids.
func (m *OrderItemMutation) AddOrderIDs(ids ...string) {
	if m._order == nil {
		m._order = make(map[string]struct{})
	}
	for i := range ids {
		m._order[ids[i]] = struct{}{}
	}
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.cleared_order
}

// RemoveOrderIDs removes the "order" edge to the Order entity by IDs.
func (m *OrderItemMutation) RemoveOrderIDs(ids ...string) {
	if m.removed_order == nil {
		m.removed_order = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._order, ids[i])
		m.removed_order[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed IDs of the "order" edge to the Order entity.
func (m *OrderItemMutation) RemovedOrderIDs() (ids []string) {
	for id := range m.removed_order {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
func (m *OrderItemMutation) OrderIDs() (ids []string) {
	for id := range m._order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
	m.removed_order = nil
}

// AddMenuItemIDs adds the "menu_item" edge to the MenuItem entity by ids.
func (m *OrderItemMutation) AddMenuItemIDs(ids ...string) {
	if m.menu_item == nil {
		m.menu_item = make(map[string]struct{})
	}
	for i := range ids {
		m.menu_item[ids[i]] = struct{}{}
	}
}

// ClearMenuItem clears the "menu_item" edge to the MenuItem entity.
func (m *OrderItemMutation) ClearMenuItem() {
	m.clearedmenu_item = true
}

// MenuItemCleared reports if the "menu_item" edge to the MenuItem entity was cleared.
func (m *OrderItemMutation) MenuItemCleared() bool {
	return m.clearedmenu_item
}

// RemoveMenuItemIDs removes the "menu_item" edge to the MenuItem entity by IDs.
func (m *OrderItemMutation) RemoveMenuItemIDs(ids ...string) {
	if m.removedmenu_item == nil {
		m.removedmenu_item = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menu_item, ids[i])
		m.removedmenu_item[ids[i]] = struct{}{}
	}
}

// RemovedMenuItem returns the removed IDs of the "menu_item" edge to the MenuItem entity.
func (m *OrderItemMutation) RemovedMenuItemIDs() (ids []string) {
	for id := range m.removedmenu_item {
		ids = append(ids, id)
	}
	return
}

// MenuItemIDs returns the "menu_item" edge IDs in the mutation.
func (m *OrderItemMutation) MenuItemIDs() (ids []string) {
	for id := range m.menu_item {
		ids = append(ids, id)
	}
	return
}

// ResetMenuItem resets all changes to the "menu_item" edge.
func (m *OrderItemMutation) ResetMenuItem() {
	m.menu_item = nil
	m.clearedmenu_item = false
	m.removedmenu_item = nil
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.price_per_item != nil {
		fields = append(fields, orderitem.FieldPricePerItem)
	}
	if m.total_price != nil {
		fields = append(fields, orderitem.FieldTotalPrice)
	}
	if m.options != nil {
		fields = append(fields, orderitem.FieldOptions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldPricePerItem:
		return m.PricePerItem()
	case orderitem.FieldTotalPrice:
		return m.TotalPrice()
	case orderitem.FieldOptions:
		return m.Options()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldPricePerItem:
		return m.OldPricePerItem(ctx)
	case orderitem.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case orderitem.FieldOptions:
		return m.OldOptions(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldPricePerItem:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerItem(v)
		return nil
	case orderitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case orderitem.FieldOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.addprice_per_item != nil {
		fields = append(fields, orderitem.FieldPricePerItem)
	}
	if m.addtotal_price != nil {
		fields = append(fields, orderitem.FieldTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldQuantity:
		return m.AddedQuantity()
	case orderitem.FieldPricePerItem:
		return m.AddedPricePerItem()
	case orderitem.FieldTotalPrice:
		return m.AddedTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderitem.FieldPricePerItem:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerItem(v)
		return nil
	case orderitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldOptions) {
		fields = append(fields, orderitem.FieldOptions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldOptions:
		m.ClearOptions()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldPricePerItem:
		m.ResetPricePerItem()
		return nil
	case orderitem.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case orderitem.FieldOptions:
		m.ResetOptions()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.menu_item != nil {
		edges = append(edges, orderitem.EdgeMenuItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		ids := make([]ent.Value, 0, len(m._order))
		for id := range m._order {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeMenuItem:
		ids := make([]ent.Value, 0, len(m.menu_item))
		for id := range m.menu_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.removedmenu_item != nil {
		edges = append(edges, orderitem.EdgeMenuItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removed_order))
		for id := range m.removed_order {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeMenuItem:
		ids := make([]ent.Value, 0, len(m.removedmenu_item))
		for id := range m.removedmenu_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.clearedmenu_item {
		edges = append(edges, orderitem.EdgeMenuItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	case orderitem.EdgeMenuItem:
		return m.clearedmenu_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderitem.EdgeMenuItem:
		m.ResetMenuItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Payment, error)
	predicates    []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id string) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	description   *string
	clearedFields map[string]struct{}
	staffs        map[string]struct{}
	removedstaffs map[string]struct{}
	clearedstaffs bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id string) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// AddStaffIDs adds the "staffs" edge to the Staff entity by ids.
func (m *PermissionMutation) AddStaffIDs(ids ...string) {
	if m.staffs == nil {
		m.staffs = make(map[string]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the Staff entity.
func (m *PermissionMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the Staff entity was cleared.
func (m *PermissionMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the Staff entity by IDs.
func (m *PermissionMutation) RemoveStaffIDs(ids ...string) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the Staff entity.
func (m *PermissionMutation) RemovedStaffsIDs() (ids []string) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *PermissionMutation) StaffsIDs() (ids []string) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *PermissionMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldName:
		return m.Name()
	case permission.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.staffs != nil {
		edges = append(edges, permission.EdgeStaffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstaffs != nil {
		edges = append(edges, permission.EdgeStaffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstaffs {
		edges = append(edges, permission.EdgeStaffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeStaffs:
		return m.clearedstaffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeStaffs:
		m.ResetStaffs()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// PlaceMutation represents an operation that mutates the Place nodes in the graph.
type PlaceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	name                       *string
	_type                      *string
	description                *string
	location                   *string
	email                      *string
	phone                      *string
	website                    *string
	cover_image                *string
	picture                    *string
	country                    *string
	city                       *string
	state                      *string
	place_settings             *map[string]interface{}
	opening_hours              *map[string]interface{}
	social_media               *map[string]interface{}
	payment_options            *map[string]interface{}
	tags                       *[]string
	appendtags                 []string
	features                   *[]string
	appendfeatures             []string
	additional_info            *map[string]interface{}
	images                     *[]string
	appendimages               []string
	availability               *map[string]interface{}
	special_offers             *string
	sustainability_score       *float64
	addsustainability_score    *float64
	map_coordinates            *map[string]interface{}
	longitude                  *string
	latitude                   *string
	search_text                *string
	relevance_score            *float64
	addrelevance_score         *float64
	follower_count             *int
	addfollower_count          *int
	like_count                 *int
	addlike_count              *int
	review_count               *int
	addreview_count            *int
	following_count            *int
	addfollowing_count         *int
	is_Premium                 *bool
	is_published               *bool
	likedByCurrentUser         *bool
	followedByCurrentUser      *bool
	clearedFields              map[string]struct{}
	business                   *string
	clearedbusiness            bool
	users                      map[string]struct{}
	removedusers               map[string]struct{}
	clearedusers               bool
	reviews                    map[string]struct{}
	removedreviews             map[string]struct{}
	clearedreviews             bool
	events                     map[string]struct{}
	removedevents              map[string]struct{}
	clearedevents              bool
	amenities                  map[string]struct{}
	removedamenities           map[string]struct{}
	clearedamenities           bool
	menus                      map[string]struct{}
	removedmenus               map[string]struct{}
	clearedmenus               bool
	medias                     map[string]struct{}
	removedmedias              map[string]struct{}
	clearedmedias              bool
	rooms                      map[string]struct{}
	removedrooms               map[string]struct{}
	clearedrooms               bool
	reservations               map[string]struct{}
	removedreservations        map[string]struct{}
	clearedreservations        bool
	bookings                   map[string]struct{}
	removedbookings            map[string]struct{}
	clearedbookings            bool
	categories                 map[string]struct{}
	removedcategories          map[string]struct{}
	clearedcategories          bool
	categoryAssignments        map[string]struct{}
	removedcategoryAssignments map[string]struct{}
	clearedcategoryAssignments bool
	faqs                       map[string]struct{}
	removedfaqs                map[string]struct{}
	clearedfaqs                bool
	likedByUsers               map[string]struct{}
	removedlikedByUsers        map[string]struct{}
	clearedlikedByUsers        bool
	followerUsers              map[string]struct{}
	removedfollowerUsers       map[string]struct{}
	clearedfollowerUsers       bool
	ratings                    map[string]struct{}
	removedratings             map[string]struct{}
	clearedratings             bool
	inventories                map[string]struct{}
	removedinventories         map[string]struct{}
	clearedinventories         bool
	notifications              map[string]struct{}
	removednotifications       map[string]struct{}
	clearednotifications       bool
	tables                     map[string]struct{}
	removedtables              map[string]struct{}
	clearedtables              bool
	staffs                     map[string]struct{}
	removedstaffs              map[string]struct{}
	clearedstaffs              bool
	room_categories            map[string]struct{}
	removedroom_categories     map[string]struct{}
	clearedroom_categories     bool
	plans                      map[string]struct{}
	removedplans               map[string]struct{}
	clearedplans               bool
	trainers                   map[string]struct{}
	removedtrainers            map[string]struct{}
	clearedtrainers            bool
	members                    map[string]struct{}
	removedmembers             map[string]struct{}
	clearedmembers             bool
	regularUsers               map[string]struct{}
	removedregularUsers        map[string]struct{}
	clearedregularUsers        bool
	done                       bool
	oldValue                   func(context.Context) (*Place, error)
	predicates                 []predicate.Place
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows management of the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for the Place entity.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the ID field of the mutation.
func withPlaceID(id string) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Place entities.
func (m *PlaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Place.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaceMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *PlaceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlaceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *PlaceMutation) ClearType() {
	m._type = nil
	m.clearedFields[place.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *PlaceMutation) TypeCleared() bool {
	_, ok := m.clearedFields[place.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *PlaceMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, place.FieldType)
}

// SetDescription sets the "description" field.
func (m *PlaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[place.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[place.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, place.FieldDescription)
}

// SetLocation sets the "location" field.
func (m *PlaceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *PlaceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *PlaceMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[place.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *PlaceMutation) LocationCleared() bool {
	_, ok := m.clearedFields[place.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *PlaceMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, place.FieldLocation)
}

// SetEmail sets the "email" field.
func (m *PlaceMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PlaceMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *PlaceMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[place.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *PlaceMutation) EmailCleared() bool {
	_, ok := m.clearedFields[place.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *PlaceMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, place.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *PlaceMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PlaceMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *PlaceMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[place.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *PlaceMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[place.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *PlaceMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, place.FieldPhone)
}

// SetWebsite sets the "website" field.
func (m *PlaceMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PlaceMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PlaceMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[place.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PlaceMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[place.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PlaceMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, place.FieldWebsite)
}

// SetCoverImage sets the "cover_image" field.
func (m *PlaceMutation) SetCoverImage(s string) {
	m.cover_image = &s
}

// CoverImage returns the value of the "cover_image" field in the mutation.
func (m *PlaceMutation) CoverImage() (r string, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "cover_image" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ClearCoverImage clears the value of the "cover_image" field.
func (m *PlaceMutation) ClearCoverImage() {
	m.cover_image = nil
	m.clearedFields[place.FieldCoverImage] = struct{}{}
}

// CoverImageCleared returns if the "cover_image" field was cleared in this mutation.
func (m *PlaceMutation) CoverImageCleared() bool {
	_, ok := m.clearedFields[place.FieldCoverImage]
	return ok
}

// ResetCoverImage resets all changes to the "cover_image" field.
func (m *PlaceMutation) ResetCoverImage() {
	m.cover_image = nil
	delete(m.clearedFields, place.FieldCoverImage)
}

// SetPicture sets the "picture" field.
func (m *PlaceMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *PlaceMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *PlaceMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[place.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *PlaceMutation) PictureCleared() bool {
	_, ok := m.clearedFields[place.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *PlaceMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, place.FieldPicture)
}

// SetCountry sets the "country" field.
func (m *PlaceMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *PlaceMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *PlaceMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[place.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *PlaceMutation) CountryCleared() bool {
	_, ok := m.clearedFields[place.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *PlaceMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, place.FieldCountry)
}

// SetCity sets the "city" field.
func (m *PlaceMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *PlaceMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *PlaceMutation) ClearCity() {
	m.city = nil
	m.clearedFields[place.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *PlaceMutation) CityCleared() bool {
	_, ok := m.clearedFields[place.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *PlaceMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, place.FieldCity)
}

// SetState sets the "state" field.
func (m *PlaceMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PlaceMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *PlaceMutation) ClearState() {
	m.state = nil
	m.clearedFields[place.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *PlaceMutation) StateCleared() bool {
	_, ok := m.clearedFields[place.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *PlaceMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, place.FieldState)
}

// SetPlaceSettings sets the "place_settings" field.
func (m *PlaceMutation) SetPlaceSettings(value map[string]interface{}) {
	m.place_settings = &value
}

// PlaceSettings returns the value of the "place_settings" field in the mutation.
func (m *PlaceMutation) PlaceSettings() (r map[string]interface{}, exists bool) {
	v := m.place_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceSettings returns the old "place_settings" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPlaceSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceSettings: %w", err)
	}
	return oldValue.PlaceSettings, nil
}

// ClearPlaceSettings clears the value of the "place_settings" field.
func (m *PlaceMutation) ClearPlaceSettings() {
	m.place_settings = nil
	m.clearedFields[place.FieldPlaceSettings] = struct{}{}
}

// PlaceSettingsCleared returns if the "place_settings" field was cleared in this mutation.
func (m *PlaceMutation) PlaceSettingsCleared() bool {
	_, ok := m.clearedFields[place.FieldPlaceSettings]
	return ok
}

// ResetPlaceSettings resets all changes to the "place_settings" field.
func (m *PlaceMutation) ResetPlaceSettings() {
	m.place_settings = nil
	delete(m.clearedFields, place.FieldPlaceSettings)
}

// SetOpeningHours sets the "opening_hours" field.
func (m *PlaceMutation) SetOpeningHours(value map[string]interface{}) {
	m.opening_hours = &value
}

// OpeningHours returns the value of the "opening_hours" field in the mutation.
func (m *PlaceMutation) OpeningHours() (r map[string]interface{}, exists bool) {
	v := m.opening_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldOpeningHours returns the old "opening_hours" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldOpeningHours(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpeningHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpeningHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpeningHours: %w", err)
	}
	return oldValue.OpeningHours, nil
}

// ClearOpeningHours clears the value of the "opening_hours" field.
func (m *PlaceMutation) ClearOpeningHours() {
	m.opening_hours = nil
	m.clearedFields[place.FieldOpeningHours] = struct{}{}
}

// OpeningHoursCleared returns if the "opening_hours" field was cleared in this mutation.
func (m *PlaceMutation) OpeningHoursCleared() bool {
	_, ok := m.clearedFields[place.FieldOpeningHours]
	return ok
}

// ResetOpeningHours resets all changes to the "opening_hours" field.
func (m *PlaceMutation) ResetOpeningHours() {
	m.opening_hours = nil
	delete(m.clearedFields, place.FieldOpeningHours)
}

// SetSocialMedia sets the "social_media" field.
func (m *PlaceMutation) SetSocialMedia(value map[string]interface{}) {
	m.social_media = &value
}

// SocialMedia returns the value of the "social_media" field in the mutation.
func (m *PlaceMutation) SocialMedia() (r map[string]interface{}, exists bool) {
	v := m.social_media
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialMedia returns the old "social_media" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSocialMedia(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialMedia: %w", err)
	}
	return oldValue.SocialMedia, nil
}

// ClearSocialMedia clears the value of the "social_media" field.
func (m *PlaceMutation) ClearSocialMedia() {
	m.social_media = nil
	m.clearedFields[place.FieldSocialMedia] = struct{}{}
}

// SocialMediaCleared returns if the "social_media" field was cleared in this mutation.
func (m *PlaceMutation) SocialMediaCleared() bool {
	_, ok := m.clearedFields[place.FieldSocialMedia]
	return ok
}

// ResetSocialMedia resets all changes to the "social_media" field.
func (m *PlaceMutation) ResetSocialMedia() {
	m.social_media = nil
	delete(m.clearedFields, place.FieldSocialMedia)
}

// SetPaymentOptions sets the "payment_options" field.
func (m *PlaceMutation) SetPaymentOptions(value map[string]interface{}) {
	m.payment_options = &value
}

// PaymentOptions returns the value of the "payment_options" field in the mutation.
func (m *PlaceMutation) PaymentOptions() (r map[string]interface{}, exists bool) {
	v := m.payment_options
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentOptions returns the old "payment_options" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPaymentOptions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentOptions: %w", err)
	}
	return oldValue.PaymentOptions, nil
}

// ClearPaymentOptions clears the value of the "payment_options" field.
func (m *PlaceMutation) ClearPaymentOptions() {
	m.payment_options = nil
	m.clearedFields[place.FieldPaymentOptions] = struct{}{}
}

// PaymentOptionsCleared returns if the "payment_options" field was cleared in this mutation.
func (m *PlaceMutation) PaymentOptionsCleared() bool {
	_, ok := m.clearedFields[place.FieldPaymentOptions]
	return ok
}

// ResetPaymentOptions resets all changes to the "payment_options" field.
func (m *PlaceMutation) ResetPaymentOptions() {
	m.payment_options = nil
	delete(m.clearedFields, place.FieldPaymentOptions)
}

// SetTags sets the "tags" field.
func (m *PlaceMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *PlaceMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *PlaceMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *PlaceMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *PlaceMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[place.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *PlaceMutation) TagsCleared() bool {
	_, ok := m.clearedFields[place.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *PlaceMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, place.FieldTags)
}

// SetFeatures sets the "features" field.
func (m *PlaceMutation) SetFeatures(s []string) {
	m.features = &s
	m.appendfeatures = nil
}

// Features returns the value of the "features" field in the mutation.
func (m *PlaceMutation) Features() (r []string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// AppendFeatures adds s to the "features" field.
func (m *PlaceMutation) AppendFeatures(s []string) {
	m.appendfeatures = append(m.appendfeatures, s...)
}

// AppendedFeatures returns the list of values that were appended to the "features" field in this mutation.
func (m *PlaceMutation) AppendedFeatures() ([]string, bool) {
	if len(m.appendfeatures) == 0 {
		return nil, false
	}
	return m.appendfeatures, true
}

// ClearFeatures clears the value of the "features" field.
func (m *PlaceMutation) ClearFeatures() {
	m.features = nil
	m.appendfeatures = nil
	m.clearedFields[place.FieldFeatures] = struct{}{}
}

// FeaturesCleared returns if the "features" field was cleared in this mutation.
func (m *PlaceMutation) FeaturesCleared() bool {
	_, ok := m.clearedFields[place.FieldFeatures]
	return ok
}

// ResetFeatures resets all changes to the "features" field.
func (m *PlaceMutation) ResetFeatures() {
	m.features = nil
	m.appendfeatures = nil
	delete(m.clearedFields, place.FieldFeatures)
}

// SetAdditionalInfo sets the "additional_info" field.
func (m *PlaceMutation) SetAdditionalInfo(value map[string]interface{}) {
	m.additional_info = &value
}

// AdditionalInfo returns the value of the "additional_info" field in the mutation.
func (m *PlaceMutation) AdditionalInfo() (r map[string]interface{}, exists bool) {
	v := m.additional_info
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalInfo returns the old "additional_info" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldAdditionalInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalInfo: %w", err)
	}
	return oldValue.AdditionalInfo, nil
}

// ClearAdditionalInfo clears the value of the "additional_info" field.
func (m *PlaceMutation) ClearAdditionalInfo() {
	m.additional_info = nil
	m.clearedFields[place.FieldAdditionalInfo] = struct{}{}
}

// AdditionalInfoCleared returns if the "additional_info" field was cleared in this mutation.
func (m *PlaceMutation) AdditionalInfoCleared() bool {
	_, ok := m.clearedFields[place.FieldAdditionalInfo]
	return ok
}

// ResetAdditionalInfo resets all changes to the "additional_info" field.
func (m *PlaceMutation) ResetAdditionalInfo() {
	m.additional_info = nil
	delete(m.clearedFields, place.FieldAdditionalInfo)
}

// SetImages sets the "images" field.
func (m *PlaceMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *PlaceMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *PlaceMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *PlaceMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *PlaceMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[place.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *PlaceMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[place.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *PlaceMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, place.FieldImages)
}

// SetAvailability sets the "availability" field.
func (m *PlaceMutation) SetAvailability(value map[string]interface{}) {
	m.availability = &value
}

// Availability returns the value of the "availability" field in the mutation.
func (m *PlaceMutation) Availability() (r map[string]interface{}, exists bool) {
	v := m.availability
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailability returns the old "availability" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldAvailability(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailability: %w", err)
	}
	return oldValue.Availability, nil
}

// ClearAvailability clears the value of the "availability" field.
func (m *PlaceMutation) ClearAvailability() {
	m.availability = nil
	m.clearedFields[place.FieldAvailability] = struct{}{}
}

// AvailabilityCleared returns if the "availability" field was cleared in this mutation.
func (m *PlaceMutation) AvailabilityCleared() bool {
	_, ok := m.clearedFields[place.FieldAvailability]
	return ok
}

// ResetAvailability resets all changes to the "availability" field.
func (m *PlaceMutation) ResetAvailability() {
	m.availability = nil
	delete(m.clearedFields, place.FieldAvailability)
}

// SetSpecialOffers sets the "special_offers" field.
func (m *PlaceMutation) SetSpecialOffers(s string) {
	m.special_offers = &s
}

// SpecialOffers returns the value of the "special_offers" field in the mutation.
func (m *PlaceMutation) SpecialOffers() (r string, exists bool) {
	v := m.special_offers
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialOffers returns the old "special_offers" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSpecialOffers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialOffers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialOffers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialOffers: %w", err)
	}
	return oldValue.SpecialOffers, nil
}

// ClearSpecialOffers clears the value of the "special_offers" field.
func (m *PlaceMutation) ClearSpecialOffers() {
	m.special_offers = nil
	m.clearedFields[place.FieldSpecialOffers] = struct{}{}
}

// SpecialOffersCleared returns if the "special_offers" field was cleared in this mutation.
func (m *PlaceMutation) SpecialOffersCleared() bool {
	_, ok := m.clearedFields[place.FieldSpecialOffers]
	return ok
}

// ResetSpecialOffers resets all changes to the "special_offers" field.
func (m *PlaceMutation) ResetSpecialOffers() {
	m.special_offers = nil
	delete(m.clearedFields, place.FieldSpecialOffers)
}

// SetSustainabilityScore sets the "sustainability_score" field.
func (m *PlaceMutation) SetSustainabilityScore(f float64) {
	m.sustainability_score = &f
	m.addsustainability_score = nil
}

// SustainabilityScore returns the value of the "sustainability_score" field in the mutation.
func (m *PlaceMutation) SustainabilityScore() (r float64, exists bool) {
	v := m.sustainability_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSustainabilityScore returns the old "sustainability_score" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSustainabilityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSustainabilityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSustainabilityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSustainabilityScore: %w", err)
	}
	return oldValue.SustainabilityScore, nil
}

// AddSustainabilityScore adds f to the "sustainability_score" field.
func (m *PlaceMutation) AddSustainabilityScore(f float64) {
	if m.addsustainability_score != nil {
		*m.addsustainability_score += f
	} else {
		m.addsustainability_score = &f
	}
}

// AddedSustainabilityScore returns the value that was added to the "sustainability_score" field in this mutation.
func (m *PlaceMutation) AddedSustainabilityScore() (r float64, exists bool) {
	v := m.addsustainability_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearSustainabilityScore clears the value of the "sustainability_score" field.
func (m *PlaceMutation) ClearSustainabilityScore() {
	m.sustainability_score = nil
	m.addsustainability_score = nil
	m.clearedFields[place.FieldSustainabilityScore] = struct{}{}
}

// SustainabilityScoreCleared returns if the "sustainability_score" field was cleared in this mutation.
func (m *PlaceMutation) SustainabilityScoreCleared() bool {
	_, ok := m.clearedFields[place.FieldSustainabilityScore]
	return ok
}

// ResetSustainabilityScore resets all changes to the "sustainability_score" field.
func (m *PlaceMutation) ResetSustainabilityScore() {
	m.sustainability_score = nil
	m.addsustainability_score = nil
	delete(m.clearedFields, place.FieldSustainabilityScore)
}

// SetMapCoordinates sets the "map_coordinates" field.
func (m *PlaceMutation) SetMapCoordinates(value map[string]interface{}) {
	m.map_coordinates = &value
}

// MapCoordinates returns the value of the "map_coordinates" field in the mutation.
func (m *PlaceMutation) MapCoordinates() (r map[string]interface{}, exists bool) {
	v := m.map_coordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldMapCoordinates returns the old "map_coordinates" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldMapCoordinates(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapCoordinates: %w", err)
	}
	return oldValue.MapCoordinates, nil
}

// ClearMapCoordinates clears the value of the "map_coordinates" field.
func (m *PlaceMutation) ClearMapCoordinates() {
	m.map_coordinates = nil
	m.clearedFields[place.FieldMapCoordinates] = struct{}{}
}

// MapCoordinatesCleared returns if the "map_coordinates" field was cleared in this mutation.
func (m *PlaceMutation) MapCoordinatesCleared() bool {
	_, ok := m.clearedFields[place.FieldMapCoordinates]
	return ok
}

// ResetMapCoordinates resets all changes to the "map_coordinates" field.
func (m *PlaceMutation) ResetMapCoordinates() {
	m.map_coordinates = nil
	delete(m.clearedFields, place.FieldMapCoordinates)
}

// SetLongitude sets the "longitude" field.
func (m *PlaceMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *PlaceMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *PlaceMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[place.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *PlaceMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[place.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *PlaceMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, place.FieldLongitude)
}

// SetLatitude sets the "latitude" field.
func (m *PlaceMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *PlaceMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *PlaceMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[place.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *PlaceMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[place.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *PlaceMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, place.FieldLatitude)
}

// SetSearchText sets the "search_text" field.
func (m *PlaceMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *PlaceMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *PlaceMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[place.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *PlaceMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[place.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *PlaceMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, place.FieldSearchText)
}

// SetRelevanceScore sets the "relevance_score" field.
func (m *PlaceMutation) SetRelevanceScore(f float64) {
	m.relevance_score = &f
	m.addrelevance_score = nil
}

// RelevanceScore returns the value of the "relevance_score" field in the mutation.
func (m *PlaceMutation) RelevanceScore() (r float64, exists bool) {
	v := m.relevance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "relevance_score" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldRelevanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds f to the "relevance_score" field.
func (m *PlaceMutation) AddRelevanceScore(f float64) {
	if m.addrelevance_score != nil {
		*m.addrelevance_score += f
	} else {
		m.addrelevance_score = &f
	}
}

// AddedRelevanceScore returns the value that was added to the "relevance_score" field in this mutation.
func (m *PlaceMutation) AddedRelevanceScore() (r float64, exists bool) {
	v := m.addrelevance_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelevanceScore clears the value of the "relevance_score" field.
func (m *PlaceMutation) ClearRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	m.clearedFields[place.FieldRelevanceScore] = struct{}{}
}

// RelevanceScoreCleared returns if the "relevance_score" field was cleared in this mutation.
func (m *PlaceMutation) RelevanceScoreCleared() bool {
	_, ok := m.clearedFields[place.FieldRelevanceScore]
	return ok
}

// ResetRelevanceScore resets all changes to the "relevance_score" field.
func (m *PlaceMutation) ResetRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	delete(m.clearedFields, place.FieldRelevanceScore)
}

// SetFollowerCount sets the "follower_count" field.
func (m *PlaceMutation) SetFollowerCount(i int) {
	m.follower_count = &i
	m.addfollower_count = nil
}

// FollowerCount returns the value of the "follower_count" field in the mutation.
func (m *PlaceMutation) FollowerCount() (r int, exists bool) {
	v := m.follower_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerCount returns the old "follower_count" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldFollowerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerCount: %w", err)
	}
	return oldValue.FollowerCount, nil
}

// AddFollowerCount adds i to the "follower_count" field.
func (m *PlaceMutation) AddFollowerCount(i int) {
	if m.addfollower_count != nil {
		*m.addfollower_count += i
	} else {
		m.addfollower_count = &i
	}
}

// AddedFollowerCount returns the value that was added to the "follower_count" field in this mutation.
func (m *PlaceMutation) AddedFollowerCount() (r int, exists bool) {
	v := m.addfollower_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowerCount resets all changes to the "follower_count" field.
func (m *PlaceMutation) ResetFollowerCount() {
	m.follower_count = nil
	m.addfollower_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *PlaceMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *PlaceMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *PlaceMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *PlaceMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *PlaceMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetReviewCount sets the "review_count" field.
func (m *PlaceMutation) SetReviewCount(i int) {
	m.review_count = &i
	m.addreview_count = nil
}

// ReviewCount returns the value of the "review_count" field in the mutation.
func (m *PlaceMutation) ReviewCount() (r int, exists bool) {
	v := m.review_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewCount returns the old "review_count" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldReviewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewCount: %w", err)
	}
	return oldValue.ReviewCount, nil
}

// AddReviewCount adds i to the "review_count" field.
func (m *PlaceMutation) AddReviewCount(i int) {
	if m.addreview_count != nil {
		*m.addreview_count += i
	} else {
		m.addreview_count = &i
	}
}

// AddedReviewCount returns the value that was added to the "review_count" field in this mutation.
func (m *PlaceMutation) AddedReviewCount() (r int, exists bool) {
	v := m.addreview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReviewCount resets all changes to the "review_count" field.
func (m *PlaceMutation) ResetReviewCount() {
	m.review_count = nil
	m.addreview_count = nil
}

// SetFollowingCount sets the "following_count" field.
func (m *PlaceMutation) SetFollowingCount(i int) {
	m.following_count = &i
	m.addfollowing_count = nil
}

// FollowingCount returns the value of the "following_count" field in the mutation.
func (m *PlaceMutation) FollowingCount() (r int, exists bool) {
	v := m.following_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingCount returns the old "following_count" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldFollowingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingCount: %w", err)
	}
	return oldValue.FollowingCount, nil
}

// AddFollowingCount adds i to the "following_count" field.
func (m *PlaceMutation) AddFollowingCount(i int) {
	if m.addfollowing_count != nil {
		*m.addfollowing_count += i
	} else {
		m.addfollowing_count = &i
	}
}

// AddedFollowingCount returns the value that was added to the "following_count" field in this mutation.
func (m *PlaceMutation) AddedFollowingCount() (r int, exists bool) {
	v := m.addfollowing_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowingCount resets all changes to the "following_count" field.
func (m *PlaceMutation) ResetFollowingCount() {
	m.following_count = nil
	m.addfollowing_count = nil
}

// SetIsPremium sets the "is_Premium" field.
func (m *PlaceMutation) SetIsPremium(b bool) {
	m.is_Premium = &b
}

// IsPremium returns the value of the "is_Premium" field in the mutation.
func (m *PlaceMutation) IsPremium() (r bool, exists bool) {
	v := m.is_Premium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old "is_Premium" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium resets all changes to the "is_Premium" field.
func (m *PlaceMutation) ResetIsPremium() {
	m.is_Premium = nil
}

// SetIsPublished sets the "is_published" field.
func (m *PlaceMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *PlaceMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *PlaceMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetLikedByCurrentUser sets the "likedByCurrentUser" field.
func (m *PlaceMutation) SetLikedByCurrentUser(b bool) {
	m.likedByCurrentUser = &b
}

// LikedByCurrentUser returns the value of the "likedByCurrentUser" field in the mutation.
func (m *PlaceMutation) LikedByCurrentUser() (r bool, exists bool) {
	v := m.likedByCurrentUser
	if v == nil {
		return
	}
	return *v, true
}

// OldLikedByCurrentUser returns the old "likedByCurrentUser" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLikedByCurrentUser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikedByCurrentUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikedByCurrentUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikedByCurrentUser: %w", err)
	}
	return oldValue.LikedByCurrentUser, nil
}

// ResetLikedByCurrentUser resets all changes to the "likedByCurrentUser" field.
func (m *PlaceMutation) ResetLikedByCurrentUser() {
	m.likedByCurrentUser = nil
}

// SetFollowedByCurrentUser sets the "followedByCurrentUser" field.
func (m *PlaceMutation) SetFollowedByCurrentUser(b bool) {
	m.followedByCurrentUser = &b
}

// FollowedByCurrentUser returns the value of the "followedByCurrentUser" field in the mutation.
func (m *PlaceMutation) FollowedByCurrentUser() (r bool, exists bool) {
	v := m.followedByCurrentUser
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowedByCurrentUser returns the old "followedByCurrentUser" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldFollowedByCurrentUser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowedByCurrentUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowedByCurrentUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowedByCurrentUser: %w", err)
	}
	return oldValue.FollowedByCurrentUser, nil
}

// ResetFollowedByCurrentUser resets all changes to the "followedByCurrentUser" field.
func (m *PlaceMutation) ResetFollowedByCurrentUser() {
	m.followedByCurrentUser = nil
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *PlaceMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *PlaceMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *PlaceMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *PlaceMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *PlaceMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *PlaceMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *PlaceMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *PlaceMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *PlaceMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *PlaceMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *PlaceMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *PlaceMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *PlaceMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *PlaceMutation) AddReviewIDs(ids ...string) {
	if m.reviews == nil {
		m.reviews = make(map[string]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *PlaceMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *PlaceMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *PlaceMutation) RemoveReviewIDs(ids ...string) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *PlaceMutation) RemovedReviewsIDs() (ids []string) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *PlaceMutation) ReviewsIDs() (ids []string) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *PlaceMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *PlaceMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *PlaceMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *PlaceMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *PlaceMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *PlaceMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *PlaceMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *PlaceMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddAmenityIDs adds the "amenities" edge to the Amenity entity by ids.
func (m *PlaceMutation) AddAmenityIDs(ids ...string) {
	if m.amenities == nil {
		m.amenities = make(map[string]struct{})
	}
	for i := range ids {
		m.amenities[ids[i]] = struct{}{}
	}
}

// ClearAmenities clears the "amenities" edge to the Amenity entity.
func (m *PlaceMutation) ClearAmenities() {
	m.clearedamenities = true
}

// AmenitiesCleared reports if the "amenities" edge to the Amenity entity was cleared.
func (m *PlaceMutation) AmenitiesCleared() bool {
	return m.clearedamenities
}

// RemoveAmenityIDs removes the "amenities" edge to the Amenity entity by IDs.
func (m *PlaceMutation) RemoveAmenityIDs(ids ...string) {
	if m.removedamenities == nil {
		m.removedamenities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.amenities, ids[i])
		m.removedamenities[ids[i]] = struct{}{}
	}
}

// RemovedAmenities returns the removed IDs of the "amenities" edge to the Amenity entity.
func (m *PlaceMutation) RemovedAmenitiesIDs() (ids []string) {
	for id := range m.removedamenities {
		ids = append(ids, id)
	}
	return
}

// AmenitiesIDs returns the "amenities" edge IDs in the mutation.
func (m *PlaceMutation) AmenitiesIDs() (ids []string) {
	for id := range m.amenities {
		ids = append(ids, id)
	}
	return
}

// ResetAmenities resets all changes to the "amenities" edge.
func (m *PlaceMutation) ResetAmenities() {
	m.amenities = nil
	m.clearedamenities = false
	m.removedamenities = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *PlaceMutation) AddMenuIDs(ids ...string) {
	if m.menus == nil {
		m.menus = make(map[string]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *PlaceMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *PlaceMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *PlaceMutation) RemoveMenuIDs(ids ...string) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *PlaceMutation) RemovedMenusIDs() (ids []string) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *PlaceMutation) MenusIDs() (ids []string) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *PlaceMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddMediaIDs adds the "medias" edge to the Media entity by ids.
func (m *PlaceMutation) AddMediaIDs(ids ...string) {
	if m.medias == nil {
		m.medias = make(map[string]struct{})
	}
	for i := range ids {
		m.medias[ids[i]] = struct{}{}
	}
}

// ClearMedias clears the "medias" edge to the Media entity.
func (m *PlaceMutation) ClearMedias() {
	m.clearedmedias = true
}

// MediasCleared reports if the "medias" edge to the Media entity was cleared.
func (m *PlaceMutation) MediasCleared() bool {
	return m.clearedmedias
}

// RemoveMediaIDs removes the "medias" edge to the Media entity by IDs.
func (m *PlaceMutation) RemoveMediaIDs(ids ...string) {
	if m.removedmedias == nil {
		m.removedmedias = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.medias, ids[i])
		m.removedmedias[ids[i]] = struct{}{}
	}
}

// RemovedMedias returns the removed IDs of the "medias" edge to the Media entity.
func (m *PlaceMutation) RemovedMediasIDs() (ids []string) {
	for id := range m.removedmedias {
		ids = append(ids, id)
	}
	return
}

// MediasIDs returns the "medias" edge IDs in the mutation.
func (m *PlaceMutation) MediasIDs() (ids []string) {
	for id := range m.medias {
		ids = append(ids, id)
	}
	return
}

// ResetMedias resets all changes to the "medias" edge.
func (m *PlaceMutation) ResetMedias() {
	m.medias = nil
	m.clearedmedias = false
	m.removedmedias = nil
}

// AddRoomIDs adds the "rooms" edge to the Room entity by ids.
func (m *PlaceMutation) AddRoomIDs(ids ...string) {
	if m.rooms == nil {
		m.rooms = make(map[string]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// ClearRooms clears the "rooms" edge to the Room entity.
func (m *PlaceMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared reports if the "rooms" edge to the Room entity was cleared.
func (m *PlaceMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RemoveRoomIDs removes the "rooms" edge to the Room entity by IDs.
func (m *PlaceMutation) RemoveRoomIDs(ids ...string) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rooms, ids[i])
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed IDs of the "rooms" edge to the Room entity.
func (m *PlaceMutation) RemovedRoomsIDs() (ids []string) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the "rooms" edge IDs in the mutation.
func (m *PlaceMutation) RoomsIDs() (ids []string) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms resets all changes to the "rooms" edge.
func (m *PlaceMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
	m.removedrooms = nil
}

// AddReservationIDs adds the "reservations" edge to the Reservation entity by ids.
func (m *PlaceMutation) AddReservationIDs(ids ...string) {
	if m.reservations == nil {
		m.reservations = make(map[string]struct{})
	}
	for i := range ids {
		m.reservations[ids[i]] = struct{}{}
	}
}

// ClearReservations clears the "reservations" edge to the Reservation entity.
func (m *PlaceMutation) ClearReservations() {
	m.clearedreservations = true
}

// ReservationsCleared reports if the "reservations" edge to the Reservation entity was cleared.
func (m *PlaceMutation) ReservationsCleared() bool {
	return m.clearedreservations
}

// RemoveReservationIDs removes the "reservations" edge to the Reservation entity by IDs.
func (m *PlaceMutation) RemoveReservationIDs(ids ...string) {
	if m.removedreservations == nil {
		m.removedreservations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reservations, ids[i])
		m.removedreservations[ids[i]] = struct{}{}
	}
}

// RemovedReservations returns the removed IDs of the "reservations" edge to the Reservation entity.
func (m *PlaceMutation) RemovedReservationsIDs() (ids []string) {
	for id := range m.removedreservations {
		ids = append(ids, id)
	}
	return
}

// ReservationsIDs returns the "reservations" edge IDs in the mutation.
func (m *PlaceMutation) ReservationsIDs() (ids []string) {
	for id := range m.reservations {
		ids = append(ids, id)
	}
	return
}

// ResetReservations resets all changes to the "reservations" edge.
func (m *PlaceMutation) ResetReservations() {
	m.reservations = nil
	m.clearedreservations = false
	m.removedreservations = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *PlaceMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *PlaceMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *PlaceMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *PlaceMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *PlaceMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *PlaceMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *PlaceMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *PlaceMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *PlaceMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *PlaceMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *PlaceMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *PlaceMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *PlaceMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *PlaceMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *PlaceMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *PlaceMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *PlaceMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *PlaceMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *PlaceMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *PlaceMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *PlaceMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// AddFaqIDs adds the "faqs" edge to the FAQ entity by ids.
func (m *PlaceMutation) AddFaqIDs(ids ...string) {
	if m.faqs == nil {
		m.faqs = make(map[string]struct{})
	}
	for i := range ids {
		m.faqs[ids[i]] = struct{}{}
	}
}

// ClearFaqs clears the "faqs" edge to the FAQ entity.
func (m *PlaceMutation) ClearFaqs() {
	m.clearedfaqs = true
}

// FaqsCleared reports if the "faqs" edge to the FAQ entity was cleared.
func (m *PlaceMutation) FaqsCleared() bool {
	return m.clearedfaqs
}

// RemoveFaqIDs removes the "faqs" edge to the FAQ entity by IDs.
func (m *PlaceMutation) RemoveFaqIDs(ids ...string) {
	if m.removedfaqs == nil {
		m.removedfaqs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.faqs, ids[i])
		m.removedfaqs[ids[i]] = struct{}{}
	}
}

// RemovedFaqs returns the removed IDs of the "faqs" edge to the FAQ entity.
func (m *PlaceMutation) RemovedFaqsIDs() (ids []string) {
	for id := range m.removedfaqs {
		ids = append(ids, id)
	}
	return
}

// FaqsIDs returns the "faqs" edge IDs in the mutation.
func (m *PlaceMutation) FaqsIDs() (ids []string) {
	for id := range m.faqs {
		ids = append(ids, id)
	}
	return
}

// ResetFaqs resets all changes to the "faqs" edge.
func (m *PlaceMutation) ResetFaqs() {
	m.faqs = nil
	m.clearedfaqs = false
	m.removedfaqs = nil
}

// AddLikedByUserIDs adds the "likedByUsers" edge to the UserLikePlace entity by ids.
func (m *PlaceMutation) AddLikedByUserIDs(ids ...string) {
	if m.likedByUsers == nil {
		m.likedByUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.likedByUsers[ids[i]] = struct{}{}
	}
}

// ClearLikedByUsers clears the "likedByUsers" edge to the UserLikePlace entity.
func (m *PlaceMutation) ClearLikedByUsers() {
	m.clearedlikedByUsers = true
}

// LikedByUsersCleared reports if the "likedByUsers" edge to the UserLikePlace entity was cleared.
func (m *PlaceMutation) LikedByUsersCleared() bool {
	return m.clearedlikedByUsers
}

// RemoveLikedByUserIDs removes the "likedByUsers" edge to the UserLikePlace entity by IDs.
func (m *PlaceMutation) RemoveLikedByUserIDs(ids ...string) {
	if m.removedlikedByUsers == nil {
		m.removedlikedByUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likedByUsers, ids[i])
		m.removedlikedByUsers[ids[i]] = struct{}{}
	}
}

// RemovedLikedByUsers returns the removed IDs of the "likedByUsers" edge to the UserLikePlace entity.
func (m *PlaceMutation) RemovedLikedByUsersIDs() (ids []string) {
	for id := range m.removedlikedByUsers {
		ids = append(ids, id)
	}
	return
}

// LikedByUsersIDs returns the "likedByUsers" edge IDs in the mutation.
func (m *PlaceMutation) LikedByUsersIDs() (ids []string) {
	for id := range m.likedByUsers {
		ids = append(ids, id)
	}
	return
}

// ResetLikedByUsers resets all changes to the "likedByUsers" edge.
func (m *PlaceMutation) ResetLikedByUsers() {
	m.likedByUsers = nil
	m.clearedlikedByUsers = false
	m.removedlikedByUsers = nil
}

// AddFollowerUserIDs adds the "followerUsers" edge to the UserFollowPlace entity by ids.
func (m *PlaceMutation) AddFollowerUserIDs(ids ...string) {
	if m.followerUsers == nil {
		m.followerUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followerUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowerUsers clears the "followerUsers" edge to the UserFollowPlace entity.
func (m *PlaceMutation) ClearFollowerUsers() {
	m.clearedfollowerUsers = true
}

// FollowerUsersCleared reports if the "followerUsers" edge to the UserFollowPlace entity was cleared.
func (m *PlaceMutation) FollowerUsersCleared() bool {
	return m.clearedfollowerUsers
}

// RemoveFollowerUserIDs removes the "followerUsers" edge to the UserFollowPlace entity by IDs.
func (m *PlaceMutation) RemoveFollowerUserIDs(ids ...string) {
	if m.removedfollowerUsers == nil {
		m.removedfollowerUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerUsers, ids[i])
		m.removedfollowerUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowerUsers returns the removed IDs of the "followerUsers" edge to the UserFollowPlace entity.
func (m *PlaceMutation) RemovedFollowerUsersIDs() (ids []string) {
	for id := range m.removedfollowerUsers {
		ids = append(ids, id)
	}
	return
}

// FollowerUsersIDs returns the "followerUsers" edge IDs in the mutation.
func (m *PlaceMutation) FollowerUsersIDs() (ids []string) {
	for id := range m.followerUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerUsers resets all changes to the "followerUsers" edge.
func (m *PlaceMutation) ResetFollowerUsers() {
	m.followerUsers = nil
	m.clearedfollowerUsers = false
	m.removedfollowerUsers = nil
}

// AddRatingIDs adds the "ratings" edge to the Rating entity by ids.
func (m *PlaceMutation) AddRatingIDs(ids ...string) {
	if m.ratings == nil {
		m.ratings = make(map[string]struct{})
	}
	for i := range ids {
		m.ratings[ids[i]] = struct{}{}
	}
}

// ClearRatings clears the "ratings" edge to the Rating entity.
func (m *PlaceMutation) ClearRatings() {
	m.clearedratings = true
}

// RatingsCleared reports if the "ratings" edge to the Rating entity was cleared.
func (m *PlaceMutation) RatingsCleared() bool {
	return m.clearedratings
}

// RemoveRatingIDs removes the "ratings" edge to the Rating entity by IDs.
func (m *PlaceMutation) RemoveRatingIDs(ids ...string) {
	if m.removedratings == nil {
		m.removedratings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratings, ids[i])
		m.removedratings[ids[i]] = struct{}{}
	}
}

// RemovedRatings returns the removed IDs of the "ratings" edge to the Rating entity.
func (m *PlaceMutation) RemovedRatingsIDs() (ids []string) {
	for id := range m.removedratings {
		ids = append(ids, id)
	}
	return
}

// RatingsIDs returns the "ratings" edge IDs in the mutation.
func (m *PlaceMutation) RatingsIDs() (ids []string) {
	for id := range m.ratings {
		ids = append(ids, id)
	}
	return
}

// ResetRatings resets all changes to the "ratings" edge.
func (m *PlaceMutation) ResetRatings() {
	m.ratings = nil
	m.clearedratings = false
	m.removedratings = nil
}

// AddInventoryIDs adds the "inventories" edge to the PlaceInventory entity by ids.
func (m *PlaceMutation) AddInventoryIDs(ids ...string) {
	if m.inventories == nil {
		m.inventories = make(map[string]struct{})
	}
	for i := range ids {
		m.inventories[ids[i]] = struct{}{}
	}
}

// ClearInventories clears the "inventories" edge to the PlaceInventory entity.
func (m *PlaceMutation) ClearInventories() {
	m.clearedinventories = true
}

// InventoriesCleared reports if the "inventories" edge to the PlaceInventory entity was cleared.
func (m *PlaceMutation) InventoriesCleared() bool {
	return m.clearedinventories
}

// RemoveInventoryIDs removes the "inventories" edge to the PlaceInventory entity by IDs.
func (m *PlaceMutation) RemoveInventoryIDs(ids ...string) {
	if m.removedinventories == nil {
		m.removedinventories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.inventories, ids[i])
		m.removedinventories[ids[i]] = struct{}{}
	}
}

// RemovedInventories returns the removed IDs of the "inventories" edge to the PlaceInventory entity.
func (m *PlaceMutation) RemovedInventoriesIDs() (ids []string) {
	for id := range m.removedinventories {
		ids = append(ids, id)
	}
	return
}

// InventoriesIDs returns the "inventories" edge IDs in the mutation.
func (m *PlaceMutation) InventoriesIDs() (ids []string) {
	for id := range m.inventories {
		ids = append(ids, id)
	}
	return
}

// ResetInventories resets all changes to the "inventories" edge.
func (m *PlaceMutation) ResetInventories() {
	m.inventories = nil
	m.clearedinventories = false
	m.removedinventories = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *PlaceMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *PlaceMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *PlaceMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *PlaceMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *PlaceMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *PlaceMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *PlaceMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddTableIDs adds the "tables" edge to the PlaceTable entity by ids.
func (m *PlaceMutation) AddTableIDs(ids ...string) {
	if m.tables == nil {
		m.tables = make(map[string]struct{})
	}
	for i := range ids {
		m.tables[ids[i]] = struct{}{}
	}
}

// ClearTables clears the "tables" edge to the PlaceTable entity.
func (m *PlaceMutation) ClearTables() {
	m.clearedtables = true
}

// TablesCleared reports if the "tables" edge to the PlaceTable entity was cleared.
func (m *PlaceMutation) TablesCleared() bool {
	return m.clearedtables
}

// RemoveTableIDs removes the "tables" edge to the PlaceTable entity by IDs.
func (m *PlaceMutation) RemoveTableIDs(ids ...string) {
	if m.removedtables == nil {
		m.removedtables = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tables, ids[i])
		m.removedtables[ids[i]] = struct{}{}
	}
}

// RemovedTables returns the removed IDs of the "tables" edge to the PlaceTable entity.
func (m *PlaceMutation) RemovedTablesIDs() (ids []string) {
	for id := range m.removedtables {
		ids = append(ids, id)
	}
	return
}

// TablesIDs returns the "tables" edge IDs in the mutation.
func (m *PlaceMutation) TablesIDs() (ids []string) {
	for id := range m.tables {
		ids = append(ids, id)
	}
	return
}

// ResetTables resets all changes to the "tables" edge.
func (m *PlaceMutation) ResetTables() {
	m.tables = nil
	m.clearedtables = false
	m.removedtables = nil
}

// AddStaffIDs adds the "staffs" edge to the Staff entity by ids.
func (m *PlaceMutation) AddStaffIDs(ids ...string) {
	if m.staffs == nil {
		m.staffs = make(map[string]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the Staff entity.
func (m *PlaceMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the Staff entity was cleared.
func (m *PlaceMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the Staff entity by IDs.
func (m *PlaceMutation) RemoveStaffIDs(ids ...string) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the Staff entity.
func (m *PlaceMutation) RemovedStaffsIDs() (ids []string) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *PlaceMutation) StaffsIDs() (ids []string) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *PlaceMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// AddRoomCategoryIDs adds the "room_categories" edge to the RoomCategory entity by ids.
func (m *PlaceMutation) AddRoomCategoryIDs(ids ...string) {
	if m.room_categories == nil {
		m.room_categories = make(map[string]struct{})
	}
	for i := range ids {
		m.room_categories[ids[i]] = struct{}{}
	}
}

// ClearRoomCategories clears the "room_categories" edge to the RoomCategory entity.
func (m *PlaceMutation) ClearRoomCategories() {
	m.clearedroom_categories = true
}

// RoomCategoriesCleared reports if the "room_categories" edge to the RoomCategory entity was cleared.
func (m *PlaceMutation) RoomCategoriesCleared() bool {
	return m.clearedroom_categories
}

// RemoveRoomCategoryIDs removes the "room_categories" edge to the RoomCategory entity by IDs.
func (m *PlaceMutation) RemoveRoomCategoryIDs(ids ...string) {
	if m.removedroom_categories == nil {
		m.removedroom_categories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.room_categories, ids[i])
		m.removedroom_categories[ids[i]] = struct{}{}
	}
}

// RemovedRoomCategories returns the removed IDs of the "room_categories" edge to the RoomCategory entity.
func (m *PlaceMutation) RemovedRoomCategoriesIDs() (ids []string) {
	for id := range m.removedroom_categories {
		ids = append(ids, id)
	}
	return
}

// RoomCategoriesIDs returns the "room_categories" edge IDs in the mutation.
func (m *PlaceMutation) RoomCategoriesIDs() (ids []string) {
	for id := range m.room_categories {
		ids = append(ids, id)
	}
	return
}

// ResetRoomCategories resets all changes to the "room_categories" edge.
func (m *PlaceMutation) ResetRoomCategories() {
	m.room_categories = nil
	m.clearedroom_categories = false
	m.removedroom_categories = nil
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *PlaceMutation) AddPlanIDs(ids ...string) {
	if m.plans == nil {
		m.plans = make(map[string]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *PlaceMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *PlaceMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *PlaceMutation) RemovePlanIDs(ids ...string) {
	if m.removedplans == nil {
		m.removedplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *PlaceMutation) RemovedPlansIDs() (ids []string) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *PlaceMutation) PlansIDs() (ids []string) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *PlaceMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// AddTrainerIDs adds the "trainers" edge to the Trainer entity by ids.
func (m *PlaceMutation) AddTrainerIDs(ids ...string) {
	if m.trainers == nil {
		m.trainers = make(map[string]struct{})
	}
	for i := range ids {
		m.trainers[ids[i]] = struct{}{}
	}
}

// ClearTrainers clears the "trainers" edge to the Trainer entity.
func (m *PlaceMutation) ClearTrainers() {
	m.clearedtrainers = true
}

// TrainersCleared reports if the "trainers" edge to the Trainer entity was cleared.
func (m *PlaceMutation) TrainersCleared() bool {
	return m.clearedtrainers
}

// RemoveTrainerIDs removes the "trainers" edge to the Trainer entity by IDs.
func (m *PlaceMutation) RemoveTrainerIDs(ids ...string) {
	if m.removedtrainers == nil {
		m.removedtrainers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.trainers, ids[i])
		m.removedtrainers[ids[i]] = struct{}{}
	}
}

// RemovedTrainers returns the removed IDs of the "trainers" edge to the Trainer entity.
func (m *PlaceMutation) RemovedTrainersIDs() (ids []string) {
	for id := range m.removedtrainers {
		ids = append(ids, id)
	}
	return
}

// TrainersIDs returns the "trainers" edge IDs in the mutation.
func (m *PlaceMutation) TrainersIDs() (ids []string) {
	for id := range m.trainers {
		ids = append(ids, id)
	}
	return
}

// ResetTrainers resets all changes to the "trainers" edge.
func (m *PlaceMutation) ResetTrainers() {
	m.trainers = nil
	m.clearedtrainers = false
	m.removedtrainers = nil
}

// AddMemberIDs adds the "members" edge to the User entity by ids.
func (m *PlaceMutation) AddMemberIDs(ids ...string) {
	if m.members == nil {
		m.members = make(map[string]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the User entity.
func (m *PlaceMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the User entity was cleared.
func (m *PlaceMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the User entity by IDs.
func (m *PlaceMutation) RemoveMemberIDs(ids ...string) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the User entity.
func (m *PlaceMutation) RemovedMembersIDs() (ids []string) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *PlaceMutation) MembersIDs() (ids []string) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *PlaceMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddRegularUserIDs adds the "regularUsers" edge to the User entity by ids.
func (m *PlaceMutation) AddRegularUserIDs(ids ...string) {
	if m.regularUsers == nil {
		m.regularUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.regularUsers[ids[i]] = struct{}{}
	}
}

// ClearRegularUsers clears the "regularUsers" edge to the User entity.
func (m *PlaceMutation) ClearRegularUsers() {
	m.clearedregularUsers = true
}

// RegularUsersCleared reports if the "regularUsers" edge to the User entity was cleared.
func (m *PlaceMutation) RegularUsersCleared() bool {
	return m.clearedregularUsers
}

// RemoveRegularUserIDs removes the "regularUsers" edge to the User entity by IDs.
func (m *PlaceMutation) RemoveRegularUserIDs(ids ...string) {
	if m.removedregularUsers == nil {
		m.removedregularUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.regularUsers, ids[i])
		m.removedregularUsers[ids[i]] = struct{}{}
	}
}

// RemovedRegularUsers returns the removed IDs of the "regularUsers" edge to the User entity.
func (m *PlaceMutation) RemovedRegularUsersIDs() (ids []string) {
	for id := range m.removedregularUsers {
		ids = append(ids, id)
	}
	return
}

// RegularUsersIDs returns the "regularUsers" edge IDs in the mutation.
func (m *PlaceMutation) RegularUsersIDs() (ids []string) {
	for id := range m.regularUsers {
		ids = append(ids, id)
	}
	return
}

// ResetRegularUsers resets all changes to the "regularUsers" edge.
func (m *PlaceMutation) ResetRegularUsers() {
	m.regularUsers = nil
	m.clearedregularUsers = false
	m.removedregularUsers = nil
}

// Where appends a list predicates to the PlaceMutation builder.
func (m *PlaceMutation) Where(ps ...predicate.Place) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Place, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.name != nil {
		fields = append(fields, place.FieldName)
	}
	if m._type != nil {
		fields = append(fields, place.FieldType)
	}
	if m.description != nil {
		fields = append(fields, place.FieldDescription)
	}
	if m.location != nil {
		fields = append(fields, place.FieldLocation)
	}
	if m.email != nil {
		fields = append(fields, place.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, place.FieldPhone)
	}
	if m.website != nil {
		fields = append(fields, place.FieldWebsite)
	}
	if m.cover_image != nil {
		fields = append(fields, place.FieldCoverImage)
	}
	if m.picture != nil {
		fields = append(fields, place.FieldPicture)
	}
	if m.country != nil {
		fields = append(fields, place.FieldCountry)
	}
	if m.city != nil {
		fields = append(fields, place.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, place.FieldState)
	}
	if m.place_settings != nil {
		fields = append(fields, place.FieldPlaceSettings)
	}
	if m.opening_hours != nil {
		fields = append(fields, place.FieldOpeningHours)
	}
	if m.social_media != nil {
		fields = append(fields, place.FieldSocialMedia)
	}
	if m.payment_options != nil {
		fields = append(fields, place.FieldPaymentOptions)
	}
	if m.tags != nil {
		fields = append(fields, place.FieldTags)
	}
	if m.features != nil {
		fields = append(fields, place.FieldFeatures)
	}
	if m.additional_info != nil {
		fields = append(fields, place.FieldAdditionalInfo)
	}
	if m.images != nil {
		fields = append(fields, place.FieldImages)
	}
	if m.availability != nil {
		fields = append(fields, place.FieldAvailability)
	}
	if m.special_offers != nil {
		fields = append(fields, place.FieldSpecialOffers)
	}
	if m.sustainability_score != nil {
		fields = append(fields, place.FieldSustainabilityScore)
	}
	if m.map_coordinates != nil {
		fields = append(fields, place.FieldMapCoordinates)
	}
	if m.longitude != nil {
		fields = append(fields, place.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, place.FieldLatitude)
	}
	if m.search_text != nil {
		fields = append(fields, place.FieldSearchText)
	}
	if m.relevance_score != nil {
		fields = append(fields, place.FieldRelevanceScore)
	}
	if m.follower_count != nil {
		fields = append(fields, place.FieldFollowerCount)
	}
	if m.like_count != nil {
		fields = append(fields, place.FieldLikeCount)
	}
	if m.review_count != nil {
		fields = append(fields, place.FieldReviewCount)
	}
	if m.following_count != nil {
		fields = append(fields, place.FieldFollowingCount)
	}
	if m.is_Premium != nil {
		fields = append(fields, place.FieldIsPremium)
	}
	if m.is_published != nil {
		fields = append(fields, place.FieldIsPublished)
	}
	if m.likedByCurrentUser != nil {
		fields = append(fields, place.FieldLikedByCurrentUser)
	}
	if m.followedByCurrentUser != nil {
		fields = append(fields, place.FieldFollowedByCurrentUser)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldName:
		return m.Name()
	case place.FieldType:
		return m.GetType()
	case place.FieldDescription:
		return m.Description()
	case place.FieldLocation:
		return m.Location()
	case place.FieldEmail:
		return m.Email()
	case place.FieldPhone:
		return m.Phone()
	case place.FieldWebsite:
		return m.Website()
	case place.FieldCoverImage:
		return m.CoverImage()
	case place.FieldPicture:
		return m.Picture()
	case place.FieldCountry:
		return m.Country()
	case place.FieldCity:
		return m.City()
	case place.FieldState:
		return m.State()
	case place.FieldPlaceSettings:
		return m.PlaceSettings()
	case place.FieldOpeningHours:
		return m.OpeningHours()
	case place.FieldSocialMedia:
		return m.SocialMedia()
	case place.FieldPaymentOptions:
		return m.PaymentOptions()
	case place.FieldTags:
		return m.Tags()
	case place.FieldFeatures:
		return m.Features()
	case place.FieldAdditionalInfo:
		return m.AdditionalInfo()
	case place.FieldImages:
		return m.Images()
	case place.FieldAvailability:
		return m.Availability()
	case place.FieldSpecialOffers:
		return m.SpecialOffers()
	case place.FieldSustainabilityScore:
		return m.SustainabilityScore()
	case place.FieldMapCoordinates:
		return m.MapCoordinates()
	case place.FieldLongitude:
		return m.Longitude()
	case place.FieldLatitude:
		return m.Latitude()
	case place.FieldSearchText:
		return m.SearchText()
	case place.FieldRelevanceScore:
		return m.RelevanceScore()
	case place.FieldFollowerCount:
		return m.FollowerCount()
	case place.FieldLikeCount:
		return m.LikeCount()
	case place.FieldReviewCount:
		return m.ReviewCount()
	case place.FieldFollowingCount:
		return m.FollowingCount()
	case place.FieldIsPremium:
		return m.IsPremium()
	case place.FieldIsPublished:
		return m.IsPublished()
	case place.FieldLikedByCurrentUser:
		return m.LikedByCurrentUser()
	case place.FieldFollowedByCurrentUser:
		return m.FollowedByCurrentUser()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldName:
		return m.OldName(ctx)
	case place.FieldType:
		return m.OldType(ctx)
	case place.FieldDescription:
		return m.OldDescription(ctx)
	case place.FieldLocation:
		return m.OldLocation(ctx)
	case place.FieldEmail:
		return m.OldEmail(ctx)
	case place.FieldPhone:
		return m.OldPhone(ctx)
	case place.FieldWebsite:
		return m.OldWebsite(ctx)
	case place.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case place.FieldPicture:
		return m.OldPicture(ctx)
	case place.FieldCountry:
		return m.OldCountry(ctx)
	case place.FieldCity:
		return m.OldCity(ctx)
	case place.FieldState:
		return m.OldState(ctx)
	case place.FieldPlaceSettings:
		return m.OldPlaceSettings(ctx)
	case place.FieldOpeningHours:
		return m.OldOpeningHours(ctx)
	case place.FieldSocialMedia:
		return m.OldSocialMedia(ctx)
	case place.FieldPaymentOptions:
		return m.OldPaymentOptions(ctx)
	case place.FieldTags:
		return m.OldTags(ctx)
	case place.FieldFeatures:
		return m.OldFeatures(ctx)
	case place.FieldAdditionalInfo:
		return m.OldAdditionalInfo(ctx)
	case place.FieldImages:
		return m.OldImages(ctx)
	case place.FieldAvailability:
		return m.OldAvailability(ctx)
	case place.FieldSpecialOffers:
		return m.OldSpecialOffers(ctx)
	case place.FieldSustainabilityScore:
		return m.OldSustainabilityScore(ctx)
	case place.FieldMapCoordinates:
		return m.OldMapCoordinates(ctx)
	case place.FieldLongitude:
		return m.OldLongitude(ctx)
	case place.FieldLatitude:
		return m.OldLatitude(ctx)
	case place.FieldSearchText:
		return m.OldSearchText(ctx)
	case place.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	case place.FieldFollowerCount:
		return m.OldFollowerCount(ctx)
	case place.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case place.FieldReviewCount:
		return m.OldReviewCount(ctx)
	case place.FieldFollowingCount:
		return m.OldFollowingCount(ctx)
	case place.FieldIsPremium:
		return m.OldIsPremium(ctx)
	case place.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case place.FieldLikedByCurrentUser:
		return m.OldLikedByCurrentUser(ctx)
	case place.FieldFollowedByCurrentUser:
		return m.OldFollowedByCurrentUser(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case place.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case place.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case place.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case place.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case place.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case place.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case place.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case place.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case place.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case place.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case place.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case place.FieldPlaceSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceSettings(v)
		return nil
	case place.FieldOpeningHours:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpeningHours(v)
		return nil
	case place.FieldSocialMedia:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialMedia(v)
		return nil
	case place.FieldPaymentOptions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentOptions(v)
		return nil
	case place.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case place.FieldFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case place.FieldAdditionalInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalInfo(v)
		return nil
	case place.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case place.FieldAvailability:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailability(v)
		return nil
	case place.FieldSpecialOffers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialOffers(v)
		return nil
	case place.FieldSustainabilityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSustainabilityScore(v)
		return nil
	case place.FieldMapCoordinates:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapCoordinates(v)
		return nil
	case place.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case place.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case place.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	case place.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	case place.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerCount(v)
		return nil
	case place.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case place.FieldReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewCount(v)
		return nil
	case place.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingCount(v)
		return nil
	case place.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	case place.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case place.FieldLikedByCurrentUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedByCurrentUser(v)
		return nil
	case place.FieldFollowedByCurrentUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowedByCurrentUser(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceMutation) AddedFields() []string {
	var fields []string
	if m.addsustainability_score != nil {
		fields = append(fields, place.FieldSustainabilityScore)
	}
	if m.addrelevance_score != nil {
		fields = append(fields, place.FieldRelevanceScore)
	}
	if m.addfollower_count != nil {
		fields = append(fields, place.FieldFollowerCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, place.FieldLikeCount)
	}
	if m.addreview_count != nil {
		fields = append(fields, place.FieldReviewCount)
	}
	if m.addfollowing_count != nil {
		fields = append(fields, place.FieldFollowingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case place.FieldSustainabilityScore:
		return m.AddedSustainabilityScore()
	case place.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	case place.FieldFollowerCount:
		return m.AddedFollowerCount()
	case place.FieldLikeCount:
		return m.AddedLikeCount()
	case place.FieldReviewCount:
		return m.AddedReviewCount()
	case place.FieldFollowingCount:
		return m.AddedFollowingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case place.FieldSustainabilityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSustainabilityScore(v)
		return nil
	case place.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	case place.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowerCount(v)
		return nil
	case place.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case place.FieldReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewCount(v)
		return nil
	case place.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(place.FieldType) {
		fields = append(fields, place.FieldType)
	}
	if m.FieldCleared(place.FieldDescription) {
		fields = append(fields, place.FieldDescription)
	}
	if m.FieldCleared(place.FieldLocation) {
		fields = append(fields, place.FieldLocation)
	}
	if m.FieldCleared(place.FieldEmail) {
		fields = append(fields, place.FieldEmail)
	}
	if m.FieldCleared(place.FieldPhone) {
		fields = append(fields, place.FieldPhone)
	}
	if m.FieldCleared(place.FieldWebsite) {
		fields = append(fields, place.FieldWebsite)
	}
	if m.FieldCleared(place.FieldCoverImage) {
		fields = append(fields, place.FieldCoverImage)
	}
	if m.FieldCleared(place.FieldPicture) {
		fields = append(fields, place.FieldPicture)
	}
	if m.FieldCleared(place.FieldCountry) {
		fields = append(fields, place.FieldCountry)
	}
	if m.FieldCleared(place.FieldCity) {
		fields = append(fields, place.FieldCity)
	}
	if m.FieldCleared(place.FieldState) {
		fields = append(fields, place.FieldState)
	}
	if m.FieldCleared(place.FieldPlaceSettings) {
		fields = append(fields, place.FieldPlaceSettings)
	}
	if m.FieldCleared(place.FieldOpeningHours) {
		fields = append(fields, place.FieldOpeningHours)
	}
	if m.FieldCleared(place.FieldSocialMedia) {
		fields = append(fields, place.FieldSocialMedia)
	}
	if m.FieldCleared(place.FieldPaymentOptions) {
		fields = append(fields, place.FieldPaymentOptions)
	}
	if m.FieldCleared(place.FieldTags) {
		fields = append(fields, place.FieldTags)
	}
	if m.FieldCleared(place.FieldFeatures) {
		fields = append(fields, place.FieldFeatures)
	}
	if m.FieldCleared(place.FieldAdditionalInfo) {
		fields = append(fields, place.FieldAdditionalInfo)
	}
	if m.FieldCleared(place.FieldImages) {
		fields = append(fields, place.FieldImages)
	}
	if m.FieldCleared(place.FieldAvailability) {
		fields = append(fields, place.FieldAvailability)
	}
	if m.FieldCleared(place.FieldSpecialOffers) {
		fields = append(fields, place.FieldSpecialOffers)
	}
	if m.FieldCleared(place.FieldSustainabilityScore) {
		fields = append(fields, place.FieldSustainabilityScore)
	}
	if m.FieldCleared(place.FieldMapCoordinates) {
		fields = append(fields, place.FieldMapCoordinates)
	}
	if m.FieldCleared(place.FieldLongitude) {
		fields = append(fields, place.FieldLongitude)
	}
	if m.FieldCleared(place.FieldLatitude) {
		fields = append(fields, place.FieldLatitude)
	}
	if m.FieldCleared(place.FieldSearchText) {
		fields = append(fields, place.FieldSearchText)
	}
	if m.FieldCleared(place.FieldRelevanceScore) {
		fields = append(fields, place.FieldRelevanceScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	switch name {
	case place.FieldType:
		m.ClearType()
		return nil
	case place.FieldDescription:
		m.ClearDescription()
		return nil
	case place.FieldLocation:
		m.ClearLocation()
		return nil
	case place.FieldEmail:
		m.ClearEmail()
		return nil
	case place.FieldPhone:
		m.ClearPhone()
		return nil
	case place.FieldWebsite:
		m.ClearWebsite()
		return nil
	case place.FieldCoverImage:
		m.ClearCoverImage()
		return nil
	case place.FieldPicture:
		m.ClearPicture()
		return nil
	case place.FieldCountry:
		m.ClearCountry()
		return nil
	case place.FieldCity:
		m.ClearCity()
		return nil
	case place.FieldState:
		m.ClearState()
		return nil
	case place.FieldPlaceSettings:
		m.ClearPlaceSettings()
		return nil
	case place.FieldOpeningHours:
		m.ClearOpeningHours()
		return nil
	case place.FieldSocialMedia:
		m.ClearSocialMedia()
		return nil
	case place.FieldPaymentOptions:
		m.ClearPaymentOptions()
		return nil
	case place.FieldTags:
		m.ClearTags()
		return nil
	case place.FieldFeatures:
		m.ClearFeatures()
		return nil
	case place.FieldAdditionalInfo:
		m.ClearAdditionalInfo()
		return nil
	case place.FieldImages:
		m.ClearImages()
		return nil
	case place.FieldAvailability:
		m.ClearAvailability()
		return nil
	case place.FieldSpecialOffers:
		m.ClearSpecialOffers()
		return nil
	case place.FieldSustainabilityScore:
		m.ClearSustainabilityScore()
		return nil
	case place.FieldMapCoordinates:
		m.ClearMapCoordinates()
		return nil
	case place.FieldLongitude:
		m.ClearLongitude()
		return nil
	case place.FieldLatitude:
		m.ClearLatitude()
		return nil
	case place.FieldSearchText:
		m.ClearSearchText()
		return nil
	case place.FieldRelevanceScore:
		m.ClearRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldName:
		m.ResetName()
		return nil
	case place.FieldType:
		m.ResetType()
		return nil
	case place.FieldDescription:
		m.ResetDescription()
		return nil
	case place.FieldLocation:
		m.ResetLocation()
		return nil
	case place.FieldEmail:
		m.ResetEmail()
		return nil
	case place.FieldPhone:
		m.ResetPhone()
		return nil
	case place.FieldWebsite:
		m.ResetWebsite()
		return nil
	case place.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case place.FieldPicture:
		m.ResetPicture()
		return nil
	case place.FieldCountry:
		m.ResetCountry()
		return nil
	case place.FieldCity:
		m.ResetCity()
		return nil
	case place.FieldState:
		m.ResetState()
		return nil
	case place.FieldPlaceSettings:
		m.ResetPlaceSettings()
		return nil
	case place.FieldOpeningHours:
		m.ResetOpeningHours()
		return nil
	case place.FieldSocialMedia:
		m.ResetSocialMedia()
		return nil
	case place.FieldPaymentOptions:
		m.ResetPaymentOptions()
		return nil
	case place.FieldTags:
		m.ResetTags()
		return nil
	case place.FieldFeatures:
		m.ResetFeatures()
		return nil
	case place.FieldAdditionalInfo:
		m.ResetAdditionalInfo()
		return nil
	case place.FieldImages:
		m.ResetImages()
		return nil
	case place.FieldAvailability:
		m.ResetAvailability()
		return nil
	case place.FieldSpecialOffers:
		m.ResetSpecialOffers()
		return nil
	case place.FieldSustainabilityScore:
		m.ResetSustainabilityScore()
		return nil
	case place.FieldMapCoordinates:
		m.ResetMapCoordinates()
		return nil
	case place.FieldLongitude:
		m.ResetLongitude()
		return nil
	case place.FieldLatitude:
		m.ResetLatitude()
		return nil
	case place.FieldSearchText:
		m.ResetSearchText()
		return nil
	case place.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	case place.FieldFollowerCount:
		m.ResetFollowerCount()
		return nil
	case place.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case place.FieldReviewCount:
		m.ResetReviewCount()
		return nil
	case place.FieldFollowingCount:
		m.ResetFollowingCount()
		return nil
	case place.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	case place.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case place.FieldLikedByCurrentUser:
		m.ResetLikedByCurrentUser()
		return nil
	case place.FieldFollowedByCurrentUser:
		m.ResetFollowedByCurrentUser()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 25)
	if m.business != nil {
		edges = append(edges, place.EdgeBusiness)
	}
	if m.users != nil {
		edges = append(edges, place.EdgeUsers)
	}
	if m.reviews != nil {
		edges = append(edges, place.EdgeReviews)
	}
	if m.events != nil {
		edges = append(edges, place.EdgeEvents)
	}
	if m.amenities != nil {
		edges = append(edges, place.EdgeAmenities)
	}
	if m.menus != nil {
		edges = append(edges, place.EdgeMenus)
	}
	if m.medias != nil {
		edges = append(edges, place.EdgeMedias)
	}
	if m.rooms != nil {
		edges = append(edges, place.EdgeRooms)
	}
	if m.reservations != nil {
		edges = append(edges, place.EdgeReservations)
	}
	if m.bookings != nil {
		edges = append(edges, place.EdgeBookings)
	}
	if m.categories != nil {
		edges = append(edges, place.EdgeCategories)
	}
	if m.categoryAssignments != nil {
		edges = append(edges, place.EdgeCategoryAssignments)
	}
	if m.faqs != nil {
		edges = append(edges, place.EdgeFaqs)
	}
	if m.likedByUsers != nil {
		edges = append(edges, place.EdgeLikedByUsers)
	}
	if m.followerUsers != nil {
		edges = append(edges, place.EdgeFollowerUsers)
	}
	if m.ratings != nil {
		edges = append(edges, place.EdgeRatings)
	}
	if m.inventories != nil {
		edges = append(edges, place.EdgeInventories)
	}
	if m.notifications != nil {
		edges = append(edges, place.EdgeNotifications)
	}
	if m.tables != nil {
		edges = append(edges, place.EdgeTables)
	}
	if m.staffs != nil {
		edges = append(edges, place.EdgeStaffs)
	}
	if m.room_categories != nil {
		edges = append(edges, place.EdgeRoomCategories)
	}
	if m.plans != nil {
		edges = append(edges, place.EdgePlans)
	}
	if m.trainers != nil {
		edges = append(edges, place.EdgeTrainers)
	}
	if m.members != nil {
		edges = append(edges, place.EdgeMembers)
	}
	if m.regularUsers != nil {
		edges = append(edges, place.EdgeRegularUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case place.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.amenities))
		for id := range m.amenities {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.medias))
		for id := range m.medias {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.reservations))
		for id := range m.reservations {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeFaqs:
		ids := make([]ent.Value, 0, len(m.faqs))
		for id := range m.faqs {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeLikedByUsers:
		ids := make([]ent.Value, 0, len(m.likedByUsers))
		for id := range m.likedByUsers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.followerUsers))
		for id := range m.followerUsers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.ratings))
		for id := range m.ratings {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeInventories:
		ids := make([]ent.Value, 0, len(m.inventories))
		for id := range m.inventories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeTables:
		ids := make([]ent.Value, 0, len(m.tables))
		for id := range m.tables {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRoomCategories:
		ids := make([]ent.Value, 0, len(m.room_categories))
		for id := range m.room_categories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeTrainers:
		ids := make([]ent.Value, 0, len(m.trainers))
		for id := range m.trainers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRegularUsers:
		ids := make([]ent.Value, 0, len(m.regularUsers))
		for id := range m.regularUsers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 25)
	if m.removedusers != nil {
		edges = append(edges, place.EdgeUsers)
	}
	if m.removedreviews != nil {
		edges = append(edges, place.EdgeReviews)
	}
	if m.removedevents != nil {
		edges = append(edges, place.EdgeEvents)
	}
	if m.removedamenities != nil {
		edges = append(edges, place.EdgeAmenities)
	}
	if m.removedmenus != nil {
		edges = append(edges, place.EdgeMenus)
	}
	if m.removedmedias != nil {
		edges = append(edges, place.EdgeMedias)
	}
	if m.removedrooms != nil {
		edges = append(edges, place.EdgeRooms)
	}
	if m.removedreservations != nil {
		edges = append(edges, place.EdgeReservations)
	}
	if m.removedbookings != nil {
		edges = append(edges, place.EdgeBookings)
	}
	if m.removedcategories != nil {
		edges = append(edges, place.EdgeCategories)
	}
	if m.removedcategoryAssignments != nil {
		edges = append(edges, place.EdgeCategoryAssignments)
	}
	if m.removedfaqs != nil {
		edges = append(edges, place.EdgeFaqs)
	}
	if m.removedlikedByUsers != nil {
		edges = append(edges, place.EdgeLikedByUsers)
	}
	if m.removedfollowerUsers != nil {
		edges = append(edges, place.EdgeFollowerUsers)
	}
	if m.removedratings != nil {
		edges = append(edges, place.EdgeRatings)
	}
	if m.removedinventories != nil {
		edges = append(edges, place.EdgeInventories)
	}
	if m.removednotifications != nil {
		edges = append(edges, place.EdgeNotifications)
	}
	if m.removedtables != nil {
		edges = append(edges, place.EdgeTables)
	}
	if m.removedstaffs != nil {
		edges = append(edges, place.EdgeStaffs)
	}
	if m.removedroom_categories != nil {
		edges = append(edges, place.EdgeRoomCategories)
	}
	if m.removedplans != nil {
		edges = append(edges, place.EdgePlans)
	}
	if m.removedtrainers != nil {
		edges = append(edges, place.EdgeTrainers)
	}
	if m.removedmembers != nil {
		edges = append(edges, place.EdgeMembers)
	}
	if m.removedregularUsers != nil {
		edges = append(edges, place.EdgeRegularUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.removedamenities))
		for id := range m.removedamenities {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.removedmedias))
		for id := range m.removedmedias {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.removedreservations))
		for id := range m.removedreservations {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeFaqs:
		ids := make([]ent.Value, 0, len(m.removedfaqs))
		for id := range m.removedfaqs {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeLikedByUsers:
		ids := make([]ent.Value, 0, len(m.removedlikedByUsers))
		for id := range m.removedlikedByUsers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowerUsers))
		for id := range m.removedfollowerUsers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.removedratings))
		for id := range m.removedratings {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeInventories:
		ids := make([]ent.Value, 0, len(m.removedinventories))
		for id := range m.removedinventories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeTables:
		ids := make([]ent.Value, 0, len(m.removedtables))
		for id := range m.removedtables {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRoomCategories:
		ids := make([]ent.Value, 0, len(m.removedroom_categories))
		for id := range m.removedroom_categories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeTrainers:
		ids := make([]ent.Value, 0, len(m.removedtrainers))
		for id := range m.removedtrainers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRegularUsers:
		ids := make([]ent.Value, 0, len(m.removedregularUsers))
		for id := range m.removedregularUsers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 25)
	if m.clearedbusiness {
		edges = append(edges, place.EdgeBusiness)
	}
	if m.clearedusers {
		edges = append(edges, place.EdgeUsers)
	}
	if m.clearedreviews {
		edges = append(edges, place.EdgeReviews)
	}
	if m.clearedevents {
		edges = append(edges, place.EdgeEvents)
	}
	if m.clearedamenities {
		edges = append(edges, place.EdgeAmenities)
	}
	if m.clearedmenus {
		edges = append(edges, place.EdgeMenus)
	}
	if m.clearedmedias {
		edges = append(edges, place.EdgeMedias)
	}
	if m.clearedrooms {
		edges = append(edges, place.EdgeRooms)
	}
	if m.clearedreservations {
		edges = append(edges, place.EdgeReservations)
	}
	if m.clearedbookings {
		edges = append(edges, place.EdgeBookings)
	}
	if m.clearedcategories {
		edges = append(edges, place.EdgeCategories)
	}
	if m.clearedcategoryAssignments {
		edges = append(edges, place.EdgeCategoryAssignments)
	}
	if m.clearedfaqs {
		edges = append(edges, place.EdgeFaqs)
	}
	if m.clearedlikedByUsers {
		edges = append(edges, place.EdgeLikedByUsers)
	}
	if m.clearedfollowerUsers {
		edges = append(edges, place.EdgeFollowerUsers)
	}
	if m.clearedratings {
		edges = append(edges, place.EdgeRatings)
	}
	if m.clearedinventories {
		edges = append(edges, place.EdgeInventories)
	}
	if m.clearednotifications {
		edges = append(edges, place.EdgeNotifications)
	}
	if m.clearedtables {
		edges = append(edges, place.EdgeTables)
	}
	if m.clearedstaffs {
		edges = append(edges, place.EdgeStaffs)
	}
	if m.clearedroom_categories {
		edges = append(edges, place.EdgeRoomCategories)
	}
	if m.clearedplans {
		edges = append(edges, place.EdgePlans)
	}
	if m.clearedtrainers {
		edges = append(edges, place.EdgeTrainers)
	}
	if m.clearedmembers {
		edges = append(edges, place.EdgeMembers)
	}
	if m.clearedregularUsers {
		edges = append(edges, place.EdgeRegularUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case place.EdgeBusiness:
		return m.clearedbusiness
	case place.EdgeUsers:
		return m.clearedusers
	case place.EdgeReviews:
		return m.clearedreviews
	case place.EdgeEvents:
		return m.clearedevents
	case place.EdgeAmenities:
		return m.clearedamenities
	case place.EdgeMenus:
		return m.clearedmenus
	case place.EdgeMedias:
		return m.clearedmedias
	case place.EdgeRooms:
		return m.clearedrooms
	case place.EdgeReservations:
		return m.clearedreservations
	case place.EdgeBookings:
		return m.clearedbookings
	case place.EdgeCategories:
		return m.clearedcategories
	case place.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	case place.EdgeFaqs:
		return m.clearedfaqs
	case place.EdgeLikedByUsers:
		return m.clearedlikedByUsers
	case place.EdgeFollowerUsers:
		return m.clearedfollowerUsers
	case place.EdgeRatings:
		return m.clearedratings
	case place.EdgeInventories:
		return m.clearedinventories
	case place.EdgeNotifications:
		return m.clearednotifications
	case place.EdgeTables:
		return m.clearedtables
	case place.EdgeStaffs:
		return m.clearedstaffs
	case place.EdgeRoomCategories:
		return m.clearedroom_categories
	case place.EdgePlans:
		return m.clearedplans
	case place.EdgeTrainers:
		return m.clearedtrainers
	case place.EdgeMembers:
		return m.clearedmembers
	case place.EdgeRegularUsers:
		return m.clearedregularUsers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	case place.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case place.EdgeUsers:
		m.ResetUsers()
		return nil
	case place.EdgeReviews:
		m.ResetReviews()
		return nil
	case place.EdgeEvents:
		m.ResetEvents()
		return nil
	case place.EdgeAmenities:
		m.ResetAmenities()
		return nil
	case place.EdgeMenus:
		m.ResetMenus()
		return nil
	case place.EdgeMedias:
		m.ResetMedias()
		return nil
	case place.EdgeRooms:
		m.ResetRooms()
		return nil
	case place.EdgeReservations:
		m.ResetReservations()
		return nil
	case place.EdgeBookings:
		m.ResetBookings()
		return nil
	case place.EdgeCategories:
		m.ResetCategories()
		return nil
	case place.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	case place.EdgeFaqs:
		m.ResetFaqs()
		return nil
	case place.EdgeLikedByUsers:
		m.ResetLikedByUsers()
		return nil
	case place.EdgeFollowerUsers:
		m.ResetFollowerUsers()
		return nil
	case place.EdgeRatings:
		m.ResetRatings()
		return nil
	case place.EdgeInventories:
		m.ResetInventories()
		return nil
	case place.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case place.EdgeTables:
		m.ResetTables()
		return nil
	case place.EdgeStaffs:
		m.ResetStaffs()
		return nil
	case place.EdgeRoomCategories:
		m.ResetRoomCategories()
		return nil
	case place.EdgePlans:
		m.ResetPlans()
		return nil
	case place.EdgeTrainers:
		m.ResetTrainers()
		return nil
	case place.EdgeMembers:
		m.ResetMembers()
		return nil
	case place.EdgeRegularUsers:
		m.ResetRegularUsers()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// PlaceInventoryMutation represents an operation that mutates the PlaceInventory nodes in the graph.
type PlaceInventoryMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	name                         *string
	price                        *float64
	addprice                     *float64
	stock_quantity               *int
	addstock_quantity            *int
	min_stock_threshold          *int
	addmin_stock_threshold       *int
	sku                          *string
	expiry_date                  *time.Time
	size                         *string
	color                        *string
	brand                        *string
	purchase_date                *time.Time
	last_updated                 *time.Time
	clearedFields                map[string]struct{}
	place                        *string
	clearedplace                 bool
	inventory_type               *string
	clearedinventory_type        bool
	attributes                   map[string]struct{}
	removedattributes            map[string]struct{}
	clearedattributes            bool
	media                        map[string]struct{}
	removedmedia                 map[string]struct{}
	clearedmedia                 bool
	transaction_histories        map[string]struct{}
	removedtransaction_histories map[string]struct{}
	clearedtransaction_histories bool
	reservation_blocks           map[string]struct{}
	removedreservation_blocks    map[string]struct{}
	clearedreservation_blocks    bool
	business                     *string
	clearedbusiness              bool
	category                     *string
	clearedcategory              bool
	menu_item                    *string
	clearedmenu_item             bool
	done                         bool
	oldValue                     func(context.Context) (*PlaceInventory, error)
	predicates                   []predicate.PlaceInventory
}

var _ ent.Mutation = (*PlaceInventoryMutation)(nil)

// placeinventoryOption allows management of the mutation configuration using functional options.
type placeinventoryOption func(*PlaceInventoryMutation)

// newPlaceInventoryMutation creates new mutation for the PlaceInventory entity.
func newPlaceInventoryMutation(c config, op Op, opts ...placeinventoryOption) *PlaceInventoryMutation {
	m := &PlaceInventoryMutation{
		config:        c,
		op:            op,
		typ:           TypePlaceInventory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceInventoryID sets the ID field of the mutation.
func withPlaceInventoryID(id string) placeinventoryOption {
	return func(m *PlaceInventoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaceInventory
		)
		m.oldValue = func(ctx context.Context) (*PlaceInventory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaceInventory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaceInventory sets the old PlaceInventory of the mutation.
func withPlaceInventory(node *PlaceInventory) placeinventoryOption {
	return func(m *PlaceInventoryMutation) {
		m.oldValue = func(context.Context) (*PlaceInventory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceInventoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceInventoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlaceInventory entities.
func (m *PlaceInventoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceInventoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceInventoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaceInventory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlaceInventoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaceInventoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaceInventoryMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *PlaceInventoryMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PlaceInventoryMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PlaceInventoryMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PlaceInventoryMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PlaceInventoryMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetStockQuantity sets the "stock_quantity" field.
func (m *PlaceInventoryMutation) SetStockQuantity(i int) {
	m.stock_quantity = &i
	m.addstock_quantity = nil
}

// StockQuantity returns the value of the "stock_quantity" field in the mutation.
func (m *PlaceInventoryMutation) StockQuantity() (r int, exists bool) {
	v := m.stock_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldStockQuantity returns the old "stock_quantity" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldStockQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockQuantity: %w", err)
	}
	return oldValue.StockQuantity, nil
}

// AddStockQuantity adds i to the "stock_quantity" field.
func (m *PlaceInventoryMutation) AddStockQuantity(i int) {
	if m.addstock_quantity != nil {
		*m.addstock_quantity += i
	} else {
		m.addstock_quantity = &i
	}
}

// AddedStockQuantity returns the value that was added to the "stock_quantity" field in this mutation.
func (m *PlaceInventoryMutation) AddedStockQuantity() (r int, exists bool) {
	v := m.addstock_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetStockQuantity resets all changes to the "stock_quantity" field.
func (m *PlaceInventoryMutation) ResetStockQuantity() {
	m.stock_quantity = nil
	m.addstock_quantity = nil
}

// SetMinStockThreshold sets the "min_stock_threshold" field.
func (m *PlaceInventoryMutation) SetMinStockThreshold(i int) {
	m.min_stock_threshold = &i
	m.addmin_stock_threshold = nil
}

// MinStockThreshold returns the value of the "min_stock_threshold" field in the mutation.
func (m *PlaceInventoryMutation) MinStockThreshold() (r int, exists bool) {
	v := m.min_stock_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldMinStockThreshold returns the old "min_stock_threshold" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldMinStockThreshold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinStockThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinStockThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinStockThreshold: %w", err)
	}
	return oldValue.MinStockThreshold, nil
}

// AddMinStockThreshold adds i to the "min_stock_threshold" field.
func (m *PlaceInventoryMutation) AddMinStockThreshold(i int) {
	if m.addmin_stock_threshold != nil {
		*m.addmin_stock_threshold += i
	} else {
		m.addmin_stock_threshold = &i
	}
}

// AddedMinStockThreshold returns the value that was added to the "min_stock_threshold" field in this mutation.
func (m *PlaceInventoryMutation) AddedMinStockThreshold() (r int, exists bool) {
	v := m.addmin_stock_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinStockThreshold clears the value of the "min_stock_threshold" field.
func (m *PlaceInventoryMutation) ClearMinStockThreshold() {
	m.min_stock_threshold = nil
	m.addmin_stock_threshold = nil
	m.clearedFields[placeinventory.FieldMinStockThreshold] = struct{}{}
}

// MinStockThresholdCleared returns if the "min_stock_threshold" field was cleared in this mutation.
func (m *PlaceInventoryMutation) MinStockThresholdCleared() bool {
	_, ok := m.clearedFields[placeinventory.FieldMinStockThreshold]
	return ok
}

// ResetMinStockThreshold resets all changes to the "min_stock_threshold" field.
func (m *PlaceInventoryMutation) ResetMinStockThreshold() {
	m.min_stock_threshold = nil
	m.addmin_stock_threshold = nil
	delete(m.clearedFields, placeinventory.FieldMinStockThreshold)
}

// SetSku sets the "sku" field.
func (m *PlaceInventoryMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *PlaceInventoryMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ClearSku clears the value of the "sku" field.
func (m *PlaceInventoryMutation) ClearSku() {
	m.sku = nil
	m.clearedFields[placeinventory.FieldSku] = struct{}{}
}

// SkuCleared returns if the "sku" field was cleared in this mutation.
func (m *PlaceInventoryMutation) SkuCleared() bool {
	_, ok := m.clearedFields[placeinventory.FieldSku]
	return ok
}

// ResetSku resets all changes to the "sku" field.
func (m *PlaceInventoryMutation) ResetSku() {
	m.sku = nil
	delete(m.clearedFields, placeinventory.FieldSku)
}

// SetExpiryDate sets the "expiry_date" field.
func (m *PlaceInventoryMutation) SetExpiryDate(t time.Time) {
	m.expiry_date = &t
}

// ExpiryDate returns the value of the "expiry_date" field in the mutation.
func (m *PlaceInventoryMutation) ExpiryDate() (r time.Time, exists bool) {
	v := m.expiry_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryDate returns the old "expiry_date" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldExpiryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryDate: %w", err)
	}
	return oldValue.ExpiryDate, nil
}

// ClearExpiryDate clears the value of the "expiry_date" field.
func (m *PlaceInventoryMutation) ClearExpiryDate() {
	m.expiry_date = nil
	m.clearedFields[placeinventory.FieldExpiryDate] = struct{}{}
}

// ExpiryDateCleared returns if the "expiry_date" field was cleared in this mutation.
func (m *PlaceInventoryMutation) ExpiryDateCleared() bool {
	_, ok := m.clearedFields[placeinventory.FieldExpiryDate]
	return ok
}

// ResetExpiryDate resets all changes to the "expiry_date" field.
func (m *PlaceInventoryMutation) ResetExpiryDate() {
	m.expiry_date = nil
	delete(m.clearedFields, placeinventory.FieldExpiryDate)
}

// SetSize sets the "size" field.
func (m *PlaceInventoryMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *PlaceInventoryMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ClearSize clears the value of the "size" field.
func (m *PlaceInventoryMutation) ClearSize() {
	m.size = nil
	m.clearedFields[placeinventory.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *PlaceInventoryMutation) SizeCleared() bool {
	_, ok := m.clearedFields[placeinventory.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *PlaceInventoryMutation) ResetSize() {
	m.size = nil
	delete(m.clearedFields, placeinventory.FieldSize)
}

// SetColor sets the "color" field.
func (m *PlaceInventoryMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *PlaceInventoryMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *PlaceInventoryMutation) ClearColor() {
	m.color = nil
	m.clearedFields[placeinventory.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *PlaceInventoryMutation) ColorCleared() bool {
	_, ok := m.clearedFields[placeinventory.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *PlaceInventoryMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, placeinventory.FieldColor)
}

// SetBrand sets the "brand" field.
func (m *PlaceInventoryMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *PlaceInventoryMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ClearBrand clears the value of the "brand" field.
func (m *PlaceInventoryMutation) ClearBrand() {
	m.brand = nil
	m.clearedFields[placeinventory.FieldBrand] = struct{}{}
}

// BrandCleared returns if the "brand" field was cleared in this mutation.
func (m *PlaceInventoryMutation) BrandCleared() bool {
	_, ok := m.clearedFields[placeinventory.FieldBrand]
	return ok
}

// ResetBrand resets all changes to the "brand" field.
func (m *PlaceInventoryMutation) ResetBrand() {
	m.brand = nil
	delete(m.clearedFields, placeinventory.FieldBrand)
}

// SetPurchaseDate sets the "purchase_date" field.
func (m *PlaceInventoryMutation) SetPurchaseDate(t time.Time) {
	m.purchase_date = &t
}

// PurchaseDate returns the value of the "purchase_date" field in the mutation.
func (m *PlaceInventoryMutation) PurchaseDate() (r time.Time, exists bool) {
	v := m.purchase_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseDate returns the old "purchase_date" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldPurchaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseDate: %w", err)
	}
	return oldValue.PurchaseDate, nil
}

// ClearPurchaseDate clears the value of the "purchase_date" field.
func (m *PlaceInventoryMutation) ClearPurchaseDate() {
	m.purchase_date = nil
	m.clearedFields[placeinventory.FieldPurchaseDate] = struct{}{}
}

// PurchaseDateCleared returns if the "purchase_date" field was cleared in this mutation.
func (m *PlaceInventoryMutation) PurchaseDateCleared() bool {
	_, ok := m.clearedFields[placeinventory.FieldPurchaseDate]
	return ok
}

// ResetPurchaseDate resets all changes to the "purchase_date" field.
func (m *PlaceInventoryMutation) ResetPurchaseDate() {
	m.purchase_date = nil
	delete(m.clearedFields, placeinventory.FieldPurchaseDate)
}

// SetLastUpdated sets the "last_updated" field.
func (m *PlaceInventoryMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *PlaceInventoryMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the PlaceInventory entity.
// If the PlaceInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *PlaceInventoryMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *PlaceInventoryMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *PlaceInventoryMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *PlaceInventoryMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *PlaceInventoryMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *PlaceInventoryMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *PlaceInventoryMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetInventoryTypeID sets the "inventory_type" edge to the InventoryType entity by id.
func (m *PlaceInventoryMutation) SetInventoryTypeID(id string) {
	m.inventory_type = &id
}

// ClearInventoryType clears the "inventory_type" edge to the InventoryType entity.
func (m *PlaceInventoryMutation) ClearInventoryType() {
	m.clearedinventory_type = true
}

// InventoryTypeCleared reports if the "inventory_type" edge to the InventoryType entity was cleared.
func (m *PlaceInventoryMutation) InventoryTypeCleared() bool {
	return m.clearedinventory_type
}

// InventoryTypeID returns the "inventory_type" edge ID in the mutation.
func (m *PlaceInventoryMutation) InventoryTypeID() (id string, exists bool) {
	if m.inventory_type != nil {
		return *m.inventory_type, true
	}
	return
}

// InventoryTypeIDs returns the "inventory_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryTypeID instead. It exists only for internal usage by the builders.
func (m *PlaceInventoryMutation) InventoryTypeIDs() (ids []string) {
	if id := m.inventory_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventoryType resets all changes to the "inventory_type" edge.
func (m *PlaceInventoryMutation) ResetInventoryType() {
	m.inventory_type = nil
	m.clearedinventory_type = false
}

// AddAttributeIDs adds the "attributes" edge to the PlaceInventoryAttribute entity by ids.
func (m *PlaceInventoryMutation) AddAttributeIDs(ids ...string) {
	if m.attributes == nil {
		m.attributes = make(map[string]struct{})
	}
	for i := range ids {
		m.attributes[ids[i]] = struct{}{}
	}
}

// ClearAttributes clears the "attributes" edge to the PlaceInventoryAttribute entity.
func (m *PlaceInventoryMutation) ClearAttributes() {
	m.clearedattributes = true
}

// AttributesCleared reports if the "attributes" edge to the PlaceInventoryAttribute entity was cleared.
func (m *PlaceInventoryMutation) AttributesCleared() bool {
	return m.clearedattributes
}

// RemoveAttributeIDs removes the "attributes" edge to the PlaceInventoryAttribute entity by IDs.
func (m *PlaceInventoryMutation) RemoveAttributeIDs(ids ...string) {
	if m.removedattributes == nil {
		m.removedattributes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attributes, ids[i])
		m.removedattributes[ids[i]] = struct{}{}
	}
}

// RemovedAttributes returns the removed IDs of the "attributes" edge to the PlaceInventoryAttribute entity.
func (m *PlaceInventoryMutation) RemovedAttributesIDs() (ids []string) {
	for id := range m.removedattributes {
		ids = append(ids, id)
	}
	return
}

// AttributesIDs returns the "attributes" edge IDs in the mutation.
func (m *PlaceInventoryMutation) AttributesIDs() (ids []string) {
	for id := range m.attributes {
		ids = append(ids, id)
	}
	return
}

// ResetAttributes resets all changes to the "attributes" edge.
func (m *PlaceInventoryMutation) ResetAttributes() {
	m.attributes = nil
	m.clearedattributes = false
	m.removedattributes = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *PlaceInventoryMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *PlaceInventoryMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *PlaceInventoryMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *PlaceInventoryMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *PlaceInventoryMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *PlaceInventoryMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *PlaceInventoryMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddTransactionHistoryIDs adds the "transaction_histories" edge to the TransactionHistory entity by ids.
func (m *PlaceInventoryMutation) AddTransactionHistoryIDs(ids ...string) {
	if m.transaction_histories == nil {
		m.transaction_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.transaction_histories[ids[i]] = struct{}{}
	}
}

// ClearTransactionHistories clears the "transaction_histories" edge to the TransactionHistory entity.
func (m *PlaceInventoryMutation) ClearTransactionHistories() {
	m.clearedtransaction_histories = true
}

// TransactionHistoriesCleared reports if the "transaction_histories" edge to the TransactionHistory entity was cleared.
func (m *PlaceInventoryMutation) TransactionHistoriesCleared() bool {
	return m.clearedtransaction_histories
}

// RemoveTransactionHistoryIDs removes the "transaction_histories" edge to the TransactionHistory entity by IDs.
func (m *PlaceInventoryMutation) RemoveTransactionHistoryIDs(ids ...string) {
	if m.removedtransaction_histories == nil {
		m.removedtransaction_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transaction_histories, ids[i])
		m.removedtransaction_histories[ids[i]] = struct{}{}
	}
}

// RemovedTransactionHistories returns the removed IDs of the "transaction_histories" edge to the TransactionHistory entity.
func (m *PlaceInventoryMutation) RemovedTransactionHistoriesIDs() (ids []string) {
	for id := range m.removedtransaction_histories {
		ids = append(ids, id)
	}
	return
}

// TransactionHistoriesIDs returns the "transaction_histories" edge IDs in the mutation.
func (m *PlaceInventoryMutation) TransactionHistoriesIDs() (ids []string) {
	for id := range m.transaction_histories {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionHistories resets all changes to the "transaction_histories" edge.
func (m *PlaceInventoryMutation) ResetTransactionHistories() {
	m.transaction_histories = nil
	m.clearedtransaction_histories = false
	m.removedtransaction_histories = nil
}

// AddReservationBlockIDs adds the "reservation_blocks" edge to the ReservationBlock entity by ids.
func (m *PlaceInventoryMutation) AddReservationBlockIDs(ids ...string) {
	if m.reservation_blocks == nil {
		m.reservation_blocks = make(map[string]struct{})
	}
	for i := range ids {
		m.reservation_blocks[ids[i]] = struct{}{}
	}
}

// ClearReservationBlocks clears the "reservation_blocks" edge to the ReservationBlock entity.
func (m *PlaceInventoryMutation) ClearReservationBlocks() {
	m.clearedreservation_blocks = true
}

// ReservationBlocksCleared reports if the "reservation_blocks" edge to the ReservationBlock entity was cleared.
func (m *PlaceInventoryMutation) ReservationBlocksCleared() bool {
	return m.clearedreservation_blocks
}

// RemoveReservationBlockIDs removes the "reservation_blocks" edge to the ReservationBlock entity by IDs.
func (m *PlaceInventoryMutation) RemoveReservationBlockIDs(ids ...string) {
	if m.removedreservation_blocks == nil {
		m.removedreservation_blocks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reservation_blocks, ids[i])
		m.removedreservation_blocks[ids[i]] = struct{}{}
	}
}

// RemovedReservationBlocks returns the removed IDs of the "reservation_blocks" edge to the ReservationBlock entity.
func (m *PlaceInventoryMutation) RemovedReservationBlocksIDs() (ids []string) {
	for id := range m.removedreservation_blocks {
		ids = append(ids, id)
	}
	return
}

// ReservationBlocksIDs returns the "reservation_blocks" edge IDs in the mutation.
func (m *PlaceInventoryMutation) ReservationBlocksIDs() (ids []string) {
	for id := range m.reservation_blocks {
		ids = append(ids, id)
	}
	return
}

// ResetReservationBlocks resets all changes to the "reservation_blocks" edge.
func (m *PlaceInventoryMutation) ResetReservationBlocks() {
	m.reservation_blocks = nil
	m.clearedreservation_blocks = false
	m.removedreservation_blocks = nil
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *PlaceInventoryMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *PlaceInventoryMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *PlaceInventoryMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *PlaceInventoryMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *PlaceInventoryMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *PlaceInventoryMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *PlaceInventoryMutation) SetCategoryID(id string) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *PlaceInventoryMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *PlaceInventoryMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *PlaceInventoryMutation) CategoryID() (id string, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *PlaceInventoryMutation) CategoryIDs() (ids []string) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *PlaceInventoryMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// SetMenuItemID sets the "menu_item" edge to the MenuItem entity by id.
func (m *PlaceInventoryMutation) SetMenuItemID(id string) {
	m.menu_item = &id
}

// ClearMenuItem clears the "menu_item" edge to the MenuItem entity.
func (m *PlaceInventoryMutation) ClearMenuItem() {
	m.clearedmenu_item = true
}

// MenuItemCleared reports if the "menu_item" edge to the MenuItem entity was cleared.
func (m *PlaceInventoryMutation) MenuItemCleared() bool {
	return m.clearedmenu_item
}

// MenuItemID returns the "menu_item" edge ID in the mutation.
func (m *PlaceInventoryMutation) MenuItemID() (id string, exists bool) {
	if m.menu_item != nil {
		return *m.menu_item, true
	}
	return
}

// MenuItemIDs returns the "menu_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenuItemID instead. It exists only for internal usage by the builders.
func (m *PlaceInventoryMutation) MenuItemIDs() (ids []string) {
	if id := m.menu_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenuItem resets all changes to the "menu_item" edge.
func (m *PlaceInventoryMutation) ResetMenuItem() {
	m.menu_item = nil
	m.clearedmenu_item = false
}

// Where appends a list predicates to the PlaceInventoryMutation builder.
func (m *PlaceInventoryMutation) Where(ps ...predicate.PlaceInventory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceInventoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceInventoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaceInventory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceInventoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceInventoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaceInventory).
func (m *PlaceInventoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceInventoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, placeinventory.FieldName)
	}
	if m.price != nil {
		fields = append(fields, placeinventory.FieldPrice)
	}
	if m.stock_quantity != nil {
		fields = append(fields, placeinventory.FieldStockQuantity)
	}
	if m.min_stock_threshold != nil {
		fields = append(fields, placeinventory.FieldMinStockThreshold)
	}
	if m.sku != nil {
		fields = append(fields, placeinventory.FieldSku)
	}
	if m.expiry_date != nil {
		fields = append(fields, placeinventory.FieldExpiryDate)
	}
	if m.size != nil {
		fields = append(fields, placeinventory.FieldSize)
	}
	if m.color != nil {
		fields = append(fields, placeinventory.FieldColor)
	}
	if m.brand != nil {
		fields = append(fields, placeinventory.FieldBrand)
	}
	if m.purchase_date != nil {
		fields = append(fields, placeinventory.FieldPurchaseDate)
	}
	if m.last_updated != nil {
		fields = append(fields, placeinventory.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceInventoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case placeinventory.FieldName:
		return m.Name()
	case placeinventory.FieldPrice:
		return m.Price()
	case placeinventory.FieldStockQuantity:
		return m.StockQuantity()
	case placeinventory.FieldMinStockThreshold:
		return m.MinStockThreshold()
	case placeinventory.FieldSku:
		return m.Sku()
	case placeinventory.FieldExpiryDate:
		return m.ExpiryDate()
	case placeinventory.FieldSize:
		return m.Size()
	case placeinventory.FieldColor:
		return m.Color()
	case placeinventory.FieldBrand:
		return m.Brand()
	case placeinventory.FieldPurchaseDate:
		return m.PurchaseDate()
	case placeinventory.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceInventoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case placeinventory.FieldName:
		return m.OldName(ctx)
	case placeinventory.FieldPrice:
		return m.OldPrice(ctx)
	case placeinventory.FieldStockQuantity:
		return m.OldStockQuantity(ctx)
	case placeinventory.FieldMinStockThreshold:
		return m.OldMinStockThreshold(ctx)
	case placeinventory.FieldSku:
		return m.OldSku(ctx)
	case placeinventory.FieldExpiryDate:
		return m.OldExpiryDate(ctx)
	case placeinventory.FieldSize:
		return m.OldSize(ctx)
	case placeinventory.FieldColor:
		return m.OldColor(ctx)
	case placeinventory.FieldBrand:
		return m.OldBrand(ctx)
	case placeinventory.FieldPurchaseDate:
		return m.OldPurchaseDate(ctx)
	case placeinventory.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown PlaceInventory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceInventoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case placeinventory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case placeinventory.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case placeinventory.FieldStockQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockQuantity(v)
		return nil
	case placeinventory.FieldMinStockThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinStockThreshold(v)
		return nil
	case placeinventory.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case placeinventory.FieldExpiryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryDate(v)
		return nil
	case placeinventory.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case placeinventory.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case placeinventory.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case placeinventory.FieldPurchaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseDate(v)
		return nil
	case placeinventory.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceInventory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceInventoryMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, placeinventory.FieldPrice)
	}
	if m.addstock_quantity != nil {
		fields = append(fields, placeinventory.FieldStockQuantity)
	}
	if m.addmin_stock_threshold != nil {
		fields = append(fields, placeinventory.FieldMinStockThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceInventoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case placeinventory.FieldPrice:
		return m.AddedPrice()
	case placeinventory.FieldStockQuantity:
		return m.AddedStockQuantity()
	case placeinventory.FieldMinStockThreshold:
		return m.AddedMinStockThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceInventoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case placeinventory.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case placeinventory.FieldStockQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockQuantity(v)
		return nil
	case placeinventory.FieldMinStockThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinStockThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceInventory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceInventoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(placeinventory.FieldMinStockThreshold) {
		fields = append(fields, placeinventory.FieldMinStockThreshold)
	}
	if m.FieldCleared(placeinventory.FieldSku) {
		fields = append(fields, placeinventory.FieldSku)
	}
	if m.FieldCleared(placeinventory.FieldExpiryDate) {
		fields = append(fields, placeinventory.FieldExpiryDate)
	}
	if m.FieldCleared(placeinventory.FieldSize) {
		fields = append(fields, placeinventory.FieldSize)
	}
	if m.FieldCleared(placeinventory.FieldColor) {
		fields = append(fields, placeinventory.FieldColor)
	}
	if m.FieldCleared(placeinventory.FieldBrand) {
		fields = append(fields, placeinventory.FieldBrand)
	}
	if m.FieldCleared(placeinventory.FieldPurchaseDate) {
		fields = append(fields, placeinventory.FieldPurchaseDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceInventoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceInventoryMutation) ClearField(name string) error {
	switch name {
	case placeinventory.FieldMinStockThreshold:
		m.ClearMinStockThreshold()
		return nil
	case placeinventory.FieldSku:
		m.ClearSku()
		return nil
	case placeinventory.FieldExpiryDate:
		m.ClearExpiryDate()
		return nil
	case placeinventory.FieldSize:
		m.ClearSize()
		return nil
	case placeinventory.FieldColor:
		m.ClearColor()
		return nil
	case placeinventory.FieldBrand:
		m.ClearBrand()
		return nil
	case placeinventory.FieldPurchaseDate:
		m.ClearPurchaseDate()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceInventoryMutation) ResetField(name string) error {
	switch name {
	case placeinventory.FieldName:
		m.ResetName()
		return nil
	case placeinventory.FieldPrice:
		m.ResetPrice()
		return nil
	case placeinventory.FieldStockQuantity:
		m.ResetStockQuantity()
		return nil
	case placeinventory.FieldMinStockThreshold:
		m.ResetMinStockThreshold()
		return nil
	case placeinventory.FieldSku:
		m.ResetSku()
		return nil
	case placeinventory.FieldExpiryDate:
		m.ResetExpiryDate()
		return nil
	case placeinventory.FieldSize:
		m.ResetSize()
		return nil
	case placeinventory.FieldColor:
		m.ResetColor()
		return nil
	case placeinventory.FieldBrand:
		m.ResetBrand()
		return nil
	case placeinventory.FieldPurchaseDate:
		m.ResetPurchaseDate()
		return nil
	case placeinventory.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceInventoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.place != nil {
		edges = append(edges, placeinventory.EdgePlace)
	}
	if m.inventory_type != nil {
		edges = append(edges, placeinventory.EdgeInventoryType)
	}
	if m.attributes != nil {
		edges = append(edges, placeinventory.EdgeAttributes)
	}
	if m.media != nil {
		edges = append(edges, placeinventory.EdgeMedia)
	}
	if m.transaction_histories != nil {
		edges = append(edges, placeinventory.EdgeTransactionHistories)
	}
	if m.reservation_blocks != nil {
		edges = append(edges, placeinventory.EdgeReservationBlocks)
	}
	if m.business != nil {
		edges = append(edges, placeinventory.EdgeBusiness)
	}
	if m.category != nil {
		edges = append(edges, placeinventory.EdgeCategory)
	}
	if m.menu_item != nil {
		edges = append(edges, placeinventory.EdgeMenuItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceInventoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case placeinventory.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case placeinventory.EdgeInventoryType:
		if id := m.inventory_type; id != nil {
			return []ent.Value{*id}
		}
	case placeinventory.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.attributes))
		for id := range m.attributes {
			ids = append(ids, id)
		}
		return ids
	case placeinventory.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case placeinventory.EdgeTransactionHistories:
		ids := make([]ent.Value, 0, len(m.transaction_histories))
		for id := range m.transaction_histories {
			ids = append(ids, id)
		}
		return ids
	case placeinventory.EdgeReservationBlocks:
		ids := make([]ent.Value, 0, len(m.reservation_blocks))
		for id := range m.reservation_blocks {
			ids = append(ids, id)
		}
		return ids
	case placeinventory.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case placeinventory.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case placeinventory.EdgeMenuItem:
		if id := m.menu_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceInventoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedattributes != nil {
		edges = append(edges, placeinventory.EdgeAttributes)
	}
	if m.removedmedia != nil {
		edges = append(edges, placeinventory.EdgeMedia)
	}
	if m.removedtransaction_histories != nil {
		edges = append(edges, placeinventory.EdgeTransactionHistories)
	}
	if m.removedreservation_blocks != nil {
		edges = append(edges, placeinventory.EdgeReservationBlocks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceInventoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case placeinventory.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.removedattributes))
		for id := range m.removedattributes {
			ids = append(ids, id)
		}
		return ids
	case placeinventory.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case placeinventory.EdgeTransactionHistories:
		ids := make([]ent.Value, 0, len(m.removedtransaction_histories))
		for id := range m.removedtransaction_histories {
			ids = append(ids, id)
		}
		return ids
	case placeinventory.EdgeReservationBlocks:
		ids := make([]ent.Value, 0, len(m.removedreservation_blocks))
		for id := range m.removedreservation_blocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceInventoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedplace {
		edges = append(edges, placeinventory.EdgePlace)
	}
	if m.clearedinventory_type {
		edges = append(edges, placeinventory.EdgeInventoryType)
	}
	if m.clearedattributes {
		edges = append(edges, placeinventory.EdgeAttributes)
	}
	if m.clearedmedia {
		edges = append(edges, placeinventory.EdgeMedia)
	}
	if m.clearedtransaction_histories {
		edges = append(edges, placeinventory.EdgeTransactionHistories)
	}
	if m.clearedreservation_blocks {
		edges = append(edges, placeinventory.EdgeReservationBlocks)
	}
	if m.clearedbusiness {
		edges = append(edges, placeinventory.EdgeBusiness)
	}
	if m.clearedcategory {
		edges = append(edges, placeinventory.EdgeCategory)
	}
	if m.clearedmenu_item {
		edges = append(edges, placeinventory.EdgeMenuItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceInventoryMutation) EdgeCleared(name string) bool {
	switch name {
	case placeinventory.EdgePlace:
		return m.clearedplace
	case placeinventory.EdgeInventoryType:
		return m.clearedinventory_type
	case placeinventory.EdgeAttributes:
		return m.clearedattributes
	case placeinventory.EdgeMedia:
		return m.clearedmedia
	case placeinventory.EdgeTransactionHistories:
		return m.clearedtransaction_histories
	case placeinventory.EdgeReservationBlocks:
		return m.clearedreservation_blocks
	case placeinventory.EdgeBusiness:
		return m.clearedbusiness
	case placeinventory.EdgeCategory:
		return m.clearedcategory
	case placeinventory.EdgeMenuItem:
		return m.clearedmenu_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceInventoryMutation) ClearEdge(name string) error {
	switch name {
	case placeinventory.EdgePlace:
		m.ClearPlace()
		return nil
	case placeinventory.EdgeInventoryType:
		m.ClearInventoryType()
		return nil
	case placeinventory.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case placeinventory.EdgeCategory:
		m.ClearCategory()
		return nil
	case placeinventory.EdgeMenuItem:
		m.ClearMenuItem()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceInventoryMutation) ResetEdge(name string) error {
	switch name {
	case placeinventory.EdgePlace:
		m.ResetPlace()
		return nil
	case placeinventory.EdgeInventoryType:
		m.ResetInventoryType()
		return nil
	case placeinventory.EdgeAttributes:
		m.ResetAttributes()
		return nil
	case placeinventory.EdgeMedia:
		m.ResetMedia()
		return nil
	case placeinventory.EdgeTransactionHistories:
		m.ResetTransactionHistories()
		return nil
	case placeinventory.EdgeReservationBlocks:
		m.ResetReservationBlocks()
		return nil
	case placeinventory.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case placeinventory.EdgeCategory:
		m.ResetCategory()
		return nil
	case placeinventory.EdgeMenuItem:
		m.ResetMenuItem()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventory edge %s", name)
}

// PlaceInventoryAttributeMutation represents an operation that mutates the PlaceInventoryAttribute nodes in the graph.
type PlaceInventoryAttributeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	value                   *string
	category_specific_value *map[string]interface{}
	clearedFields           map[string]struct{}
	inventory               *string
	clearedinventory        bool
	attribute_type          *string
	clearedattribute_type   bool
	done                    bool
	oldValue                func(context.Context) (*PlaceInventoryAttribute, error)
	predicates              []predicate.PlaceInventoryAttribute
}

var _ ent.Mutation = (*PlaceInventoryAttributeMutation)(nil)

// placeinventoryattributeOption allows management of the mutation configuration using functional options.
type placeinventoryattributeOption func(*PlaceInventoryAttributeMutation)

// newPlaceInventoryAttributeMutation creates new mutation for the PlaceInventoryAttribute entity.
func newPlaceInventoryAttributeMutation(c config, op Op, opts ...placeinventoryattributeOption) *PlaceInventoryAttributeMutation {
	m := &PlaceInventoryAttributeMutation{
		config:        c,
		op:            op,
		typ:           TypePlaceInventoryAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceInventoryAttributeID sets the ID field of the mutation.
func withPlaceInventoryAttributeID(id string) placeinventoryattributeOption {
	return func(m *PlaceInventoryAttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaceInventoryAttribute
		)
		m.oldValue = func(ctx context.Context) (*PlaceInventoryAttribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaceInventoryAttribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaceInventoryAttribute sets the old PlaceInventoryAttribute of the mutation.
func withPlaceInventoryAttribute(node *PlaceInventoryAttribute) placeinventoryattributeOption {
	return func(m *PlaceInventoryAttributeMutation) {
		m.oldValue = func(context.Context) (*PlaceInventoryAttribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceInventoryAttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceInventoryAttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlaceInventoryAttribute entities.
func (m *PlaceInventoryAttributeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceInventoryAttributeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceInventoryAttributeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaceInventoryAttribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *PlaceInventoryAttributeMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PlaceInventoryAttributeMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the PlaceInventoryAttribute entity.
// If the PlaceInventoryAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryAttributeMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PlaceInventoryAttributeMutation) ResetValue() {
	m.value = nil
}

// SetCategorySpecificValue sets the "category_specific_value" field.
func (m *PlaceInventoryAttributeMutation) SetCategorySpecificValue(value map[string]interface{}) {
	m.category_specific_value = &value
}

// CategorySpecificValue returns the value of the "category_specific_value" field in the mutation.
func (m *PlaceInventoryAttributeMutation) CategorySpecificValue() (r map[string]interface{}, exists bool) {
	v := m.category_specific_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCategorySpecificValue returns the old "category_specific_value" field's value of the PlaceInventoryAttribute entity.
// If the PlaceInventoryAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceInventoryAttributeMutation) OldCategorySpecificValue(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategorySpecificValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategorySpecificValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategorySpecificValue: %w", err)
	}
	return oldValue.CategorySpecificValue, nil
}

// ClearCategorySpecificValue clears the value of the "category_specific_value" field.
func (m *PlaceInventoryAttributeMutation) ClearCategorySpecificValue() {
	m.category_specific_value = nil
	m.clearedFields[placeinventoryattribute.FieldCategorySpecificValue] = struct{}{}
}

// CategorySpecificValueCleared returns if the "category_specific_value" field was cleared in this mutation.
func (m *PlaceInventoryAttributeMutation) CategorySpecificValueCleared() bool {
	_, ok := m.clearedFields[placeinventoryattribute.FieldCategorySpecificValue]
	return ok
}

// ResetCategorySpecificValue resets all changes to the "category_specific_value" field.
func (m *PlaceInventoryAttributeMutation) ResetCategorySpecificValue() {
	m.category_specific_value = nil
	delete(m.clearedFields, placeinventoryattribute.FieldCategorySpecificValue)
}

// SetInventoryID sets the "inventory" edge to the PlaceInventory entity by id.
func (m *PlaceInventoryAttributeMutation) SetInventoryID(id string) {
	m.inventory = &id
}

// ClearInventory clears the "inventory" edge to the PlaceInventory entity.
func (m *PlaceInventoryAttributeMutation) ClearInventory() {
	m.clearedinventory = true
}

// InventoryCleared reports if the "inventory" edge to the PlaceInventory entity was cleared.
func (m *PlaceInventoryAttributeMutation) InventoryCleared() bool {
	return m.clearedinventory
}

// InventoryID returns the "inventory" edge ID in the mutation.
func (m *PlaceInventoryAttributeMutation) InventoryID() (id string, exists bool) {
	if m.inventory != nil {
		return *m.inventory, true
	}
	return
}

// InventoryIDs returns the "inventory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryID instead. It exists only for internal usage by the builders.
func (m *PlaceInventoryAttributeMutation) InventoryIDs() (ids []string) {
	if id := m.inventory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventory resets all changes to the "inventory" edge.
func (m *PlaceInventoryAttributeMutation) ResetInventory() {
	m.inventory = nil
	m.clearedinventory = false
}

// SetAttributeTypeID sets the "attribute_type" edge to the InventoryAttribute entity by id.
func (m *PlaceInventoryAttributeMutation) SetAttributeTypeID(id string) {
	m.attribute_type = &id
}

// ClearAttributeType clears the "attribute_type" edge to the InventoryAttribute entity.
func (m *PlaceInventoryAttributeMutation) ClearAttributeType() {
	m.clearedattribute_type = true
}

// AttributeTypeCleared reports if the "attribute_type" edge to the InventoryAttribute entity was cleared.
func (m *PlaceInventoryAttributeMutation) AttributeTypeCleared() bool {
	return m.clearedattribute_type
}

// AttributeTypeID returns the "attribute_type" edge ID in the mutation.
func (m *PlaceInventoryAttributeMutation) AttributeTypeID() (id string, exists bool) {
	if m.attribute_type != nil {
		return *m.attribute_type, true
	}
	return
}

// AttributeTypeIDs returns the "attribute_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttributeTypeID instead. It exists only for internal usage by the builders.
func (m *PlaceInventoryAttributeMutation) AttributeTypeIDs() (ids []string) {
	if id := m.attribute_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttributeType resets all changes to the "attribute_type" edge.
func (m *PlaceInventoryAttributeMutation) ResetAttributeType() {
	m.attribute_type = nil
	m.clearedattribute_type = false
}

// Where appends a list predicates to the PlaceInventoryAttributeMutation builder.
func (m *PlaceInventoryAttributeMutation) Where(ps ...predicate.PlaceInventoryAttribute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceInventoryAttributeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceInventoryAttributeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaceInventoryAttribute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceInventoryAttributeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceInventoryAttributeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaceInventoryAttribute).
func (m *PlaceInventoryAttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceInventoryAttributeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.value != nil {
		fields = append(fields, placeinventoryattribute.FieldValue)
	}
	if m.category_specific_value != nil {
		fields = append(fields, placeinventoryattribute.FieldCategorySpecificValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceInventoryAttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case placeinventoryattribute.FieldValue:
		return m.Value()
	case placeinventoryattribute.FieldCategorySpecificValue:
		return m.CategorySpecificValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceInventoryAttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case placeinventoryattribute.FieldValue:
		return m.OldValue(ctx)
	case placeinventoryattribute.FieldCategorySpecificValue:
		return m.OldCategorySpecificValue(ctx)
	}
	return nil, fmt.Errorf("unknown PlaceInventoryAttribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceInventoryAttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case placeinventoryattribute.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case placeinventoryattribute.FieldCategorySpecificValue:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategorySpecificValue(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceInventoryAttribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceInventoryAttributeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceInventoryAttributeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceInventoryAttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlaceInventoryAttribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceInventoryAttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(placeinventoryattribute.FieldCategorySpecificValue) {
		fields = append(fields, placeinventoryattribute.FieldCategorySpecificValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceInventoryAttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceInventoryAttributeMutation) ClearField(name string) error {
	switch name {
	case placeinventoryattribute.FieldCategorySpecificValue:
		m.ClearCategorySpecificValue()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventoryAttribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceInventoryAttributeMutation) ResetField(name string) error {
	switch name {
	case placeinventoryattribute.FieldValue:
		m.ResetValue()
		return nil
	case placeinventoryattribute.FieldCategorySpecificValue:
		m.ResetCategorySpecificValue()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventoryAttribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceInventoryAttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.inventory != nil {
		edges = append(edges, placeinventoryattribute.EdgeInventory)
	}
	if m.attribute_type != nil {
		edges = append(edges, placeinventoryattribute.EdgeAttributeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceInventoryAttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case placeinventoryattribute.EdgeInventory:
		if id := m.inventory; id != nil {
			return []ent.Value{*id}
		}
	case placeinventoryattribute.EdgeAttributeType:
		if id := m.attribute_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceInventoryAttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceInventoryAttributeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceInventoryAttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinventory {
		edges = append(edges, placeinventoryattribute.EdgeInventory)
	}
	if m.clearedattribute_type {
		edges = append(edges, placeinventoryattribute.EdgeAttributeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceInventoryAttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case placeinventoryattribute.EdgeInventory:
		return m.clearedinventory
	case placeinventoryattribute.EdgeAttributeType:
		return m.clearedattribute_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceInventoryAttributeMutation) ClearEdge(name string) error {
	switch name {
	case placeinventoryattribute.EdgeInventory:
		m.ClearInventory()
		return nil
	case placeinventoryattribute.EdgeAttributeType:
		m.ClearAttributeType()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventoryAttribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceInventoryAttributeMutation) ResetEdge(name string) error {
	switch name {
	case placeinventoryattribute.EdgeInventory:
		m.ResetInventory()
		return nil
	case placeinventoryattribute.EdgeAttributeType:
		m.ResetAttributeType()
		return nil
	}
	return fmt.Errorf("unknown PlaceInventoryAttribute edge %s", name)
}

// PlaceTableMutation represents an operation that mutates the PlaceTable nodes in the graph.
type PlaceTableMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	number                     *int
	addnumber                  *int
	name                       *string
	capacity                   *int
	addcapacity                *int
	deleted_at                 *string
	is_deleted                 *bool
	qr_code                    *string
	description                *string
	status                     *string
	_type                      *placetable.Type
	is_active                  *bool
	is_reserved                *bool
	is_vip                     *bool
	is_premium                 *bool
	location_description       *string
	minimum_spend              *float64
	addminimum_spend           *float64
	reservation_time           *time.Time
	next_available_time        *time.Time
	special_requirements       *[]string
	appendspecial_requirements []string
	layout                     *string
	service_area               *string
	ambient                    *string
	image_url                  *string
	rating                     *float64
	addrating                  *float64
	tags                       *[]string
	appendtags                 []string
	metadata                   *map[string]interface{}
	clearedFields              map[string]struct{}
	place                      *string
	clearedplace               bool
	created_by                 *string
	clearedcreated_by          bool
	updated_by                 *string
	clearedupdated_by          bool
	deleted_by                 *string
	cleareddeleted_by          bool
	reserved_by                *string
	clearedreserved_by         bool
	waiter                     *string
	clearedwaiter              bool
	orders                     map[string]struct{}
	removedorders              map[string]struct{}
	clearedorders              bool
	done                       bool
	oldValue                   func(context.Context) (*PlaceTable, error)
	predicates                 []predicate.PlaceTable
}

var _ ent.Mutation = (*PlaceTableMutation)(nil)

// placetableOption allows management of the mutation configuration using functional options.
type placetableOption func(*PlaceTableMutation)

// newPlaceTableMutation creates new mutation for the PlaceTable entity.
func newPlaceTableMutation(c config, op Op, opts ...placetableOption) *PlaceTableMutation {
	m := &PlaceTableMutation{
		config:        c,
		op:            op,
		typ:           TypePlaceTable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceTableID sets the ID field of the mutation.
func withPlaceTableID(id string) placetableOption {
	return func(m *PlaceTableMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaceTable
		)
		m.oldValue = func(ctx context.Context) (*PlaceTable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaceTable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaceTable sets the old PlaceTable of the mutation.
func withPlaceTable(node *PlaceTable) placetableOption {
	return func(m *PlaceTableMutation) {
		m.oldValue = func(context.Context) (*PlaceTable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceTableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceTableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlaceTable entities.
func (m *PlaceTableMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceTableMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceTableMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaceTable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNumber sets the "number" field.
func (m *PlaceTableMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *PlaceTableMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *PlaceTableMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *PlaceTableMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *PlaceTableMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetName sets the "name" field.
func (m *PlaceTableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaceTableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PlaceTableMutation) ClearName() {
	m.name = nil
	m.clearedFields[placetable.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PlaceTableMutation) NameCleared() bool {
	_, ok := m.clearedFields[placetable.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PlaceTableMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, placetable.FieldName)
}

// SetCapacity sets the "capacity" field.
func (m *PlaceTableMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *PlaceTableMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *PlaceTableMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *PlaceTableMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *PlaceTableMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlaceTableMutation) SetDeletedAt(s string) {
	m.deleted_at = &s
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlaceTableMutation) DeletedAt() (r string, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldDeletedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlaceTableMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[placetable.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlaceTableMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[placetable.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlaceTableMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, placetable.FieldDeletedAt)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *PlaceTableMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *PlaceTableMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *PlaceTableMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetQrCode sets the "qr_code" field.
func (m *PlaceTableMutation) SetQrCode(s string) {
	m.qr_code = &s
}

// QrCode returns the value of the "qr_code" field in the mutation.
func (m *PlaceTableMutation) QrCode() (r string, exists bool) {
	v := m.qr_code
	if v == nil {
		return
	}
	return *v, true
}

// OldQrCode returns the old "qr_code" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldQrCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrCode: %w", err)
	}
	return oldValue.QrCode, nil
}

// ClearQrCode clears the value of the "qr_code" field.
func (m *PlaceTableMutation) ClearQrCode() {
	m.qr_code = nil
	m.clearedFields[placetable.FieldQrCode] = struct{}{}
}

// QrCodeCleared returns if the "qr_code" field was cleared in this mutation.
func (m *PlaceTableMutation) QrCodeCleared() bool {
	_, ok := m.clearedFields[placetable.FieldQrCode]
	return ok
}

// ResetQrCode resets all changes to the "qr_code" field.
func (m *PlaceTableMutation) ResetQrCode() {
	m.qr_code = nil
	delete(m.clearedFields, placetable.FieldQrCode)
}

// SetDescription sets the "description" field.
func (m *PlaceTableMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlaceTableMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlaceTableMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[placetable.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlaceTableMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[placetable.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlaceTableMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, placetable.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *PlaceTableMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PlaceTableMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PlaceTableMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *PlaceTableMutation) SetType(pl placetable.Type) {
	m._type = &pl
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlaceTableMutation) GetType() (r placetable.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldType(ctx context.Context) (v placetable.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *PlaceTableMutation) ClearType() {
	m._type = nil
	m.clearedFields[placetable.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *PlaceTableMutation) TypeCleared() bool {
	_, ok := m.clearedFields[placetable.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *PlaceTableMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, placetable.FieldType)
}

// SetIsActive sets the "is_active" field.
func (m *PlaceTableMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlaceTableMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlaceTableMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsReserved sets the "is_reserved" field.
func (m *PlaceTableMutation) SetIsReserved(b bool) {
	m.is_reserved = &b
}

// IsReserved returns the value of the "is_reserved" field in the mutation.
func (m *PlaceTableMutation) IsReserved() (r bool, exists bool) {
	v := m.is_reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReserved returns the old "is_reserved" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldIsReserved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReserved: %w", err)
	}
	return oldValue.IsReserved, nil
}

// ResetIsReserved resets all changes to the "is_reserved" field.
func (m *PlaceTableMutation) ResetIsReserved() {
	m.is_reserved = nil
}

// SetIsVip sets the "is_vip" field.
func (m *PlaceTableMutation) SetIsVip(b bool) {
	m.is_vip = &b
}

// IsVip returns the value of the "is_vip" field in the mutation.
func (m *PlaceTableMutation) IsVip() (r bool, exists bool) {
	v := m.is_vip
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVip returns the old "is_vip" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldIsVip(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVip: %w", err)
	}
	return oldValue.IsVip, nil
}

// ResetIsVip resets all changes to the "is_vip" field.
func (m *PlaceTableMutation) ResetIsVip() {
	m.is_vip = nil
}

// SetIsPremium sets the "is_premium" field.
func (m *PlaceTableMutation) SetIsPremium(b bool) {
	m.is_premium = &b
}

// IsPremium returns the value of the "is_premium" field in the mutation.
func (m *PlaceTableMutation) IsPremium() (r bool, exists bool) {
	v := m.is_premium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old "is_premium" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium resets all changes to the "is_premium" field.
func (m *PlaceTableMutation) ResetIsPremium() {
	m.is_premium = nil
}

// SetLocationDescription sets the "location_description" field.
func (m *PlaceTableMutation) SetLocationDescription(s string) {
	m.location_description = &s
}

// LocationDescription returns the value of the "location_description" field in the mutation.
func (m *PlaceTableMutation) LocationDescription() (r string, exists bool) {
	v := m.location_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationDescription returns the old "location_description" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldLocationDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationDescription: %w", err)
	}
	return oldValue.LocationDescription, nil
}

// ClearLocationDescription clears the value of the "location_description" field.
func (m *PlaceTableMutation) ClearLocationDescription() {
	m.location_description = nil
	m.clearedFields[placetable.FieldLocationDescription] = struct{}{}
}

// LocationDescriptionCleared returns if the "location_description" field was cleared in this mutation.
func (m *PlaceTableMutation) LocationDescriptionCleared() bool {
	_, ok := m.clearedFields[placetable.FieldLocationDescription]
	return ok
}

// ResetLocationDescription resets all changes to the "location_description" field.
func (m *PlaceTableMutation) ResetLocationDescription() {
	m.location_description = nil
	delete(m.clearedFields, placetable.FieldLocationDescription)
}

// SetMinimumSpend sets the "minimum_spend" field.
func (m *PlaceTableMutation) SetMinimumSpend(f float64) {
	m.minimum_spend = &f
	m.addminimum_spend = nil
}

// MinimumSpend returns the value of the "minimum_spend" field in the mutation.
func (m *PlaceTableMutation) MinimumSpend() (r float64, exists bool) {
	v := m.minimum_spend
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumSpend returns the old "minimum_spend" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldMinimumSpend(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumSpend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumSpend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumSpend: %w", err)
	}
	return oldValue.MinimumSpend, nil
}

// AddMinimumSpend adds f to the "minimum_spend" field.
func (m *PlaceTableMutation) AddMinimumSpend(f float64) {
	if m.addminimum_spend != nil {
		*m.addminimum_spend += f
	} else {
		m.addminimum_spend = &f
	}
}

// AddedMinimumSpend returns the value that was added to the "minimum_spend" field in this mutation.
func (m *PlaceTableMutation) AddedMinimumSpend() (r float64, exists bool) {
	v := m.addminimum_spend
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinimumSpend clears the value of the "minimum_spend" field.
func (m *PlaceTableMutation) ClearMinimumSpend() {
	m.minimum_spend = nil
	m.addminimum_spend = nil
	m.clearedFields[placetable.FieldMinimumSpend] = struct{}{}
}

// MinimumSpendCleared returns if the "minimum_spend" field was cleared in this mutation.
func (m *PlaceTableMutation) MinimumSpendCleared() bool {
	_, ok := m.clearedFields[placetable.FieldMinimumSpend]
	return ok
}

// ResetMinimumSpend resets all changes to the "minimum_spend" field.
func (m *PlaceTableMutation) ResetMinimumSpend() {
	m.minimum_spend = nil
	m.addminimum_spend = nil
	delete(m.clearedFields, placetable.FieldMinimumSpend)
}

// SetReservationTime sets the "reservation_time" field.
func (m *PlaceTableMutation) SetReservationTime(t time.Time) {
	m.reservation_time = &t
}

// ReservationTime returns the value of the "reservation_time" field in the mutation.
func (m *PlaceTableMutation) ReservationTime() (r time.Time, exists bool) {
	v := m.reservation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationTime returns the old "reservation_time" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldReservationTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationTime: %w", err)
	}
	return oldValue.ReservationTime, nil
}

// ClearReservationTime clears the value of the "reservation_time" field.
func (m *PlaceTableMutation) ClearReservationTime() {
	m.reservation_time = nil
	m.clearedFields[placetable.FieldReservationTime] = struct{}{}
}

// ReservationTimeCleared returns if the "reservation_time" field was cleared in this mutation.
func (m *PlaceTableMutation) ReservationTimeCleared() bool {
	_, ok := m.clearedFields[placetable.FieldReservationTime]
	return ok
}

// ResetReservationTime resets all changes to the "reservation_time" field.
func (m *PlaceTableMutation) ResetReservationTime() {
	m.reservation_time = nil
	delete(m.clearedFields, placetable.FieldReservationTime)
}

// SetNextAvailableTime sets the "next_available_time" field.
func (m *PlaceTableMutation) SetNextAvailableTime(t time.Time) {
	m.next_available_time = &t
}

// NextAvailableTime returns the value of the "next_available_time" field in the mutation.
func (m *PlaceTableMutation) NextAvailableTime() (r time.Time, exists bool) {
	v := m.next_available_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNextAvailableTime returns the old "next_available_time" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldNextAvailableTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextAvailableTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextAvailableTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextAvailableTime: %w", err)
	}
	return oldValue.NextAvailableTime, nil
}

// ClearNextAvailableTime clears the value of the "next_available_time" field.
func (m *PlaceTableMutation) ClearNextAvailableTime() {
	m.next_available_time = nil
	m.clearedFields[placetable.FieldNextAvailableTime] = struct{}{}
}

// NextAvailableTimeCleared returns if the "next_available_time" field was cleared in this mutation.
func (m *PlaceTableMutation) NextAvailableTimeCleared() bool {
	_, ok := m.clearedFields[placetable.FieldNextAvailableTime]
	return ok
}

// ResetNextAvailableTime resets all changes to the "next_available_time" field.
func (m *PlaceTableMutation) ResetNextAvailableTime() {
	m.next_available_time = nil
	delete(m.clearedFields, placetable.FieldNextAvailableTime)
}

// SetSpecialRequirements sets the "special_requirements" field.
func (m *PlaceTableMutation) SetSpecialRequirements(s []string) {
	m.special_requirements = &s
	m.appendspecial_requirements = nil
}

// SpecialRequirements returns the value of the "special_requirements" field in the mutation.
func (m *PlaceTableMutation) SpecialRequirements() (r []string, exists bool) {
	v := m.special_requirements
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialRequirements returns the old "special_requirements" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldSpecialRequirements(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialRequirements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialRequirements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialRequirements: %w", err)
	}
	return oldValue.SpecialRequirements, nil
}

// AppendSpecialRequirements adds s to the "special_requirements" field.
func (m *PlaceTableMutation) AppendSpecialRequirements(s []string) {
	m.appendspecial_requirements = append(m.appendspecial_requirements, s...)
}

// AppendedSpecialRequirements returns the list of values that were appended to the "special_requirements" field in this mutation.
func (m *PlaceTableMutation) AppendedSpecialRequirements() ([]string, bool) {
	if len(m.appendspecial_requirements) == 0 {
		return nil, false
	}
	return m.appendspecial_requirements, true
}

// ClearSpecialRequirements clears the value of the "special_requirements" field.
func (m *PlaceTableMutation) ClearSpecialRequirements() {
	m.special_requirements = nil
	m.appendspecial_requirements = nil
	m.clearedFields[placetable.FieldSpecialRequirements] = struct{}{}
}

// SpecialRequirementsCleared returns if the "special_requirements" field was cleared in this mutation.
func (m *PlaceTableMutation) SpecialRequirementsCleared() bool {
	_, ok := m.clearedFields[placetable.FieldSpecialRequirements]
	return ok
}

// ResetSpecialRequirements resets all changes to the "special_requirements" field.
func (m *PlaceTableMutation) ResetSpecialRequirements() {
	m.special_requirements = nil
	m.appendspecial_requirements = nil
	delete(m.clearedFields, placetable.FieldSpecialRequirements)
}

// SetLayout sets the "layout" field.
func (m *PlaceTableMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *PlaceTableMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ClearLayout clears the value of the "layout" field.
func (m *PlaceTableMutation) ClearLayout() {
	m.layout = nil
	m.clearedFields[placetable.FieldLayout] = struct{}{}
}

// LayoutCleared returns if the "layout" field was cleared in this mutation.
func (m *PlaceTableMutation) LayoutCleared() bool {
	_, ok := m.clearedFields[placetable.FieldLayout]
	return ok
}

// ResetLayout resets all changes to the "layout" field.
func (m *PlaceTableMutation) ResetLayout() {
	m.layout = nil
	delete(m.clearedFields, placetable.FieldLayout)
}

// SetServiceArea sets the "service_area" field.
func (m *PlaceTableMutation) SetServiceArea(s string) {
	m.service_area = &s
}

// ServiceArea returns the value of the "service_area" field in the mutation.
func (m *PlaceTableMutation) ServiceArea() (r string, exists bool) {
	v := m.service_area
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceArea returns the old "service_area" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldServiceArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceArea: %w", err)
	}
	return oldValue.ServiceArea, nil
}

// ClearServiceArea clears the value of the "service_area" field.
func (m *PlaceTableMutation) ClearServiceArea() {
	m.service_area = nil
	m.clearedFields[placetable.FieldServiceArea] = struct{}{}
}

// ServiceAreaCleared returns if the "service_area" field was cleared in this mutation.
func (m *PlaceTableMutation) ServiceAreaCleared() bool {
	_, ok := m.clearedFields[placetable.FieldServiceArea]
	return ok
}

// ResetServiceArea resets all changes to the "service_area" field.
func (m *PlaceTableMutation) ResetServiceArea() {
	m.service_area = nil
	delete(m.clearedFields, placetable.FieldServiceArea)
}

// SetAmbient sets the "ambient" field.
func (m *PlaceTableMutation) SetAmbient(s string) {
	m.ambient = &s
}

// Ambient returns the value of the "ambient" field in the mutation.
func (m *PlaceTableMutation) Ambient() (r string, exists bool) {
	v := m.ambient
	if v == nil {
		return
	}
	return *v, true
}

// OldAmbient returns the old "ambient" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldAmbient(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmbient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmbient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmbient: %w", err)
	}
	return oldValue.Ambient, nil
}

// ClearAmbient clears the value of the "ambient" field.
func (m *PlaceTableMutation) ClearAmbient() {
	m.ambient = nil
	m.clearedFields[placetable.FieldAmbient] = struct{}{}
}

// AmbientCleared returns if the "ambient" field was cleared in this mutation.
func (m *PlaceTableMutation) AmbientCleared() bool {
	_, ok := m.clearedFields[placetable.FieldAmbient]
	return ok
}

// ResetAmbient resets all changes to the "ambient" field.
func (m *PlaceTableMutation) ResetAmbient() {
	m.ambient = nil
	delete(m.clearedFields, placetable.FieldAmbient)
}

// SetImageURL sets the "image_url" field.
func (m *PlaceTableMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *PlaceTableMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *PlaceTableMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[placetable.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *PlaceTableMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[placetable.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *PlaceTableMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, placetable.FieldImageURL)
}

// SetRating sets the "rating" field.
func (m *PlaceTableMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *PlaceTableMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldRating(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *PlaceTableMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *PlaceTableMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ClearRating clears the value of the "rating" field.
func (m *PlaceTableMutation) ClearRating() {
	m.rating = nil
	m.addrating = nil
	m.clearedFields[placetable.FieldRating] = struct{}{}
}

// RatingCleared returns if the "rating" field was cleared in this mutation.
func (m *PlaceTableMutation) RatingCleared() bool {
	_, ok := m.clearedFields[placetable.FieldRating]
	return ok
}

// ResetRating resets all changes to the "rating" field.
func (m *PlaceTableMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
	delete(m.clearedFields, placetable.FieldRating)
}

// SetTags sets the "tags" field.
func (m *PlaceTableMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *PlaceTableMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *PlaceTableMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *PlaceTableMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *PlaceTableMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[placetable.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *PlaceTableMutation) TagsCleared() bool {
	_, ok := m.clearedFields[placetable.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *PlaceTableMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, placetable.FieldTags)
}

// SetMetadata sets the "metadata" field.
func (m *PlaceTableMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlaceTableMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PlaceTable entity.
// If the PlaceTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceTableMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlaceTableMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[placetable.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlaceTableMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[placetable.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlaceTableMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, placetable.FieldMetadata)
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *PlaceTableMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *PlaceTableMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *PlaceTableMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *PlaceTableMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *PlaceTableMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *PlaceTableMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *PlaceTableMutation) SetCreatedByID(id string) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *PlaceTableMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *PlaceTableMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *PlaceTableMutation) CreatedByID() (id string, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *PlaceTableMutation) CreatedByIDs() (ids []string) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *PlaceTableMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *PlaceTableMutation) SetUpdatedByID(id string) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *PlaceTableMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *PlaceTableMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *PlaceTableMutation) UpdatedByID() (id string, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *PlaceTableMutation) UpdatedByIDs() (ids []string) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *PlaceTableMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// SetDeletedByID sets the "deleted_by" edge to the User entity by id.
func (m *PlaceTableMutation) SetDeletedByID(id string) {
	m.deleted_by = &id
}

// ClearDeletedBy clears the "deleted_by" edge to the User entity.
func (m *PlaceTableMutation) ClearDeletedBy() {
	m.cleareddeleted_by = true
}

// DeletedByCleared reports if the "deleted_by" edge to the User entity was cleared.
func (m *PlaceTableMutation) DeletedByCleared() bool {
	return m.cleareddeleted_by
}

// DeletedByID returns the "deleted_by" edge ID in the mutation.
func (m *PlaceTableMutation) DeletedByID() (id string, exists bool) {
	if m.deleted_by != nil {
		return *m.deleted_by, true
	}
	return
}

// DeletedByIDs returns the "deleted_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeletedByID instead. It exists only for internal usage by the builders.
func (m *PlaceTableMutation) DeletedByIDs() (ids []string) {
	if id := m.deleted_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeletedBy resets all changes to the "deleted_by" edge.
func (m *PlaceTableMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.cleareddeleted_by = false
}

// SetReservedByID sets the "reserved_by" edge to the User entity by id.
func (m *PlaceTableMutation) SetReservedByID(id string) {
	m.reserved_by = &id
}

// ClearReservedBy clears the "reserved_by" edge to the User entity.
func (m *PlaceTableMutation) ClearReservedBy() {
	m.clearedreserved_by = true
}

// ReservedByCleared reports if the "reserved_by" edge to the User entity was cleared.
func (m *PlaceTableMutation) ReservedByCleared() bool {
	return m.clearedreserved_by
}

// ReservedByID returns the "reserved_by" edge ID in the mutation.
func (m *PlaceTableMutation) ReservedByID() (id string, exists bool) {
	if m.reserved_by != nil {
		return *m.reserved_by, true
	}
	return
}

// ReservedByIDs returns the "reserved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReservedByID instead. It exists only for internal usage by the builders.
func (m *PlaceTableMutation) ReservedByIDs() (ids []string) {
	if id := m.reserved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReservedBy resets all changes to the "reserved_by" edge.
func (m *PlaceTableMutation) ResetReservedBy() {
	m.reserved_by = nil
	m.clearedreserved_by = false
}

// SetWaiterID sets the "waiter" edge to the User entity by id.
func (m *PlaceTableMutation) SetWaiterID(id string) {
	m.waiter = &id
}

// ClearWaiter clears the "waiter" edge to the User entity.
func (m *PlaceTableMutation) ClearWaiter() {
	m.clearedwaiter = true
}

// WaiterCleared reports if the "waiter" edge to the User entity was cleared.
func (m *PlaceTableMutation) WaiterCleared() bool {
	return m.clearedwaiter
}

// WaiterID returns the "waiter" edge ID in the mutation.
func (m *PlaceTableMutation) WaiterID() (id string, exists bool) {
	if m.waiter != nil {
		return *m.waiter, true
	}
	return
}

// WaiterIDs returns the "waiter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WaiterID instead. It exists only for internal usage by the builders.
func (m *PlaceTableMutation) WaiterIDs() (ids []string) {
	if id := m.waiter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWaiter resets all changes to the "waiter" edge.
func (m *PlaceTableMutation) ResetWaiter() {
	m.waiter = nil
	m.clearedwaiter = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *PlaceTableMutation) AddOrderIDs(ids ...string) {
	if m.orders == nil {
		m.orders = make(map[string]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *PlaceTableMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *PlaceTableMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *PlaceTableMutation) RemoveOrderIDs(ids ...string) {
	if m.removedorders == nil {
		m.removedorders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *PlaceTableMutation) RemovedOrdersIDs() (ids []string) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *PlaceTableMutation) OrdersIDs() (ids []string) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *PlaceTableMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the PlaceTableMutation builder.
func (m *PlaceTableMutation) Where(ps ...predicate.PlaceTable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceTableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceTableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaceTable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceTableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceTableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaceTable).
func (m *PlaceTableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceTableMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.number != nil {
		fields = append(fields, placetable.FieldNumber)
	}
	if m.name != nil {
		fields = append(fields, placetable.FieldName)
	}
	if m.capacity != nil {
		fields = append(fields, placetable.FieldCapacity)
	}
	if m.deleted_at != nil {
		fields = append(fields, placetable.FieldDeletedAt)
	}
	if m.is_deleted != nil {
		fields = append(fields, placetable.FieldIsDeleted)
	}
	if m.qr_code != nil {
		fields = append(fields, placetable.FieldQrCode)
	}
	if m.description != nil {
		fields = append(fields, placetable.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, placetable.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, placetable.FieldType)
	}
	if m.is_active != nil {
		fields = append(fields, placetable.FieldIsActive)
	}
	if m.is_reserved != nil {
		fields = append(fields, placetable.FieldIsReserved)
	}
	if m.is_vip != nil {
		fields = append(fields, placetable.FieldIsVip)
	}
	if m.is_premium != nil {
		fields = append(fields, placetable.FieldIsPremium)
	}
	if m.location_description != nil {
		fields = append(fields, placetable.FieldLocationDescription)
	}
	if m.minimum_spend != nil {
		fields = append(fields, placetable.FieldMinimumSpend)
	}
	if m.reservation_time != nil {
		fields = append(fields, placetable.FieldReservationTime)
	}
	if m.next_available_time != nil {
		fields = append(fields, placetable.FieldNextAvailableTime)
	}
	if m.special_requirements != nil {
		fields = append(fields, placetable.FieldSpecialRequirements)
	}
	if m.layout != nil {
		fields = append(fields, placetable.FieldLayout)
	}
	if m.service_area != nil {
		fields = append(fields, placetable.FieldServiceArea)
	}
	if m.ambient != nil {
		fields = append(fields, placetable.FieldAmbient)
	}
	if m.image_url != nil {
		fields = append(fields, placetable.FieldImageURL)
	}
	if m.rating != nil {
		fields = append(fields, placetable.FieldRating)
	}
	if m.tags != nil {
		fields = append(fields, placetable.FieldTags)
	}
	if m.metadata != nil {
		fields = append(fields, placetable.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceTableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case placetable.FieldNumber:
		return m.Number()
	case placetable.FieldName:
		return m.Name()
	case placetable.FieldCapacity:
		return m.Capacity()
	case placetable.FieldDeletedAt:
		return m.DeletedAt()
	case placetable.FieldIsDeleted:
		return m.IsDeleted()
	case placetable.FieldQrCode:
		return m.QrCode()
	case placetable.FieldDescription:
		return m.Description()
	case placetable.FieldStatus:
		return m.Status()
	case placetable.FieldType:
		return m.GetType()
	case placetable.FieldIsActive:
		return m.IsActive()
	case placetable.FieldIsReserved:
		return m.IsReserved()
	case placetable.FieldIsVip:
		return m.IsVip()
	case placetable.FieldIsPremium:
		return m.IsPremium()
	case placetable.FieldLocationDescription:
		return m.LocationDescription()
	case placetable.FieldMinimumSpend:
		return m.MinimumSpend()
	case placetable.FieldReservationTime:
		return m.ReservationTime()
	case placetable.FieldNextAvailableTime:
		return m.NextAvailableTime()
	case placetable.FieldSpecialRequirements:
		return m.SpecialRequirements()
	case placetable.FieldLayout:
		return m.Layout()
	case placetable.FieldServiceArea:
		return m.ServiceArea()
	case placetable.FieldAmbient:
		return m.Ambient()
	case placetable.FieldImageURL:
		return m.ImageURL()
	case placetable.FieldRating:
		return m.Rating()
	case placetable.FieldTags:
		return m.Tags()
	case placetable.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceTableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case placetable.FieldNumber:
		return m.OldNumber(ctx)
	case placetable.FieldName:
		return m.OldName(ctx)
	case placetable.FieldCapacity:
		return m.OldCapacity(ctx)
	case placetable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case placetable.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case placetable.FieldQrCode:
		return m.OldQrCode(ctx)
	case placetable.FieldDescription:
		return m.OldDescription(ctx)
	case placetable.FieldStatus:
		return m.OldStatus(ctx)
	case placetable.FieldType:
		return m.OldType(ctx)
	case placetable.FieldIsActive:
		return m.OldIsActive(ctx)
	case placetable.FieldIsReserved:
		return m.OldIsReserved(ctx)
	case placetable.FieldIsVip:
		return m.OldIsVip(ctx)
	case placetable.FieldIsPremium:
		return m.OldIsPremium(ctx)
	case placetable.FieldLocationDescription:
		return m.OldLocationDescription(ctx)
	case placetable.FieldMinimumSpend:
		return m.OldMinimumSpend(ctx)
	case placetable.FieldReservationTime:
		return m.OldReservationTime(ctx)
	case placetable.FieldNextAvailableTime:
		return m.OldNextAvailableTime(ctx)
	case placetable.FieldSpecialRequirements:
		return m.OldSpecialRequirements(ctx)
	case placetable.FieldLayout:
		return m.OldLayout(ctx)
	case placetable.FieldServiceArea:
		return m.OldServiceArea(ctx)
	case placetable.FieldAmbient:
		return m.OldAmbient(ctx)
	case placetable.FieldImageURL:
		return m.OldImageURL(ctx)
	case placetable.FieldRating:
		return m.OldRating(ctx)
	case placetable.FieldTags:
		return m.OldTags(ctx)
	case placetable.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown PlaceTable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceTableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case placetable.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case placetable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case placetable.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case placetable.FieldDeletedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case placetable.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case placetable.FieldQrCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrCode(v)
		return nil
	case placetable.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case placetable.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case placetable.FieldType:
		v, ok := value.(placetable.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case placetable.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case placetable.FieldIsReserved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReserved(v)
		return nil
	case placetable.FieldIsVip:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVip(v)
		return nil
	case placetable.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	case placetable.FieldLocationDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationDescription(v)
		return nil
	case placetable.FieldMinimumSpend:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumSpend(v)
		return nil
	case placetable.FieldReservationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationTime(v)
		return nil
	case placetable.FieldNextAvailableTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextAvailableTime(v)
		return nil
	case placetable.FieldSpecialRequirements:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialRequirements(v)
		return nil
	case placetable.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case placetable.FieldServiceArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceArea(v)
		return nil
	case placetable.FieldAmbient:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmbient(v)
		return nil
	case placetable.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case placetable.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case placetable.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case placetable.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceTable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceTableMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, placetable.FieldNumber)
	}
	if m.addcapacity != nil {
		fields = append(fields, placetable.FieldCapacity)
	}
	if m.addminimum_spend != nil {
		fields = append(fields, placetable.FieldMinimumSpend)
	}
	if m.addrating != nil {
		fields = append(fields, placetable.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceTableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case placetable.FieldNumber:
		return m.AddedNumber()
	case placetable.FieldCapacity:
		return m.AddedCapacity()
	case placetable.FieldMinimumSpend:
		return m.AddedMinimumSpend()
	case placetable.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceTableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case placetable.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case placetable.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	case placetable.FieldMinimumSpend:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumSpend(v)
		return nil
	case placetable.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown PlaceTable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceTableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(placetable.FieldName) {
		fields = append(fields, placetable.FieldName)
	}
	if m.FieldCleared(placetable.FieldDeletedAt) {
		fields = append(fields, placetable.FieldDeletedAt)
	}
	if m.FieldCleared(placetable.FieldQrCode) {
		fields = append(fields, placetable.FieldQrCode)
	}
	if m.FieldCleared(placetable.FieldDescription) {
		fields = append(fields, placetable.FieldDescription)
	}
	if m.FieldCleared(placetable.FieldType) {
		fields = append(fields, placetable.FieldType)
	}
	if m.FieldCleared(placetable.FieldLocationDescription) {
		fields = append(fields, placetable.FieldLocationDescription)
	}
	if m.FieldCleared(placetable.FieldMinimumSpend) {
		fields = append(fields, placetable.FieldMinimumSpend)
	}
	if m.FieldCleared(placetable.FieldReservationTime) {
		fields = append(fields, placetable.FieldReservationTime)
	}
	if m.FieldCleared(placetable.FieldNextAvailableTime) {
		fields = append(fields, placetable.FieldNextAvailableTime)
	}
	if m.FieldCleared(placetable.FieldSpecialRequirements) {
		fields = append(fields, placetable.FieldSpecialRequirements)
	}
	if m.FieldCleared(placetable.FieldLayout) {
		fields = append(fields, placetable.FieldLayout)
	}
	if m.FieldCleared(placetable.FieldServiceArea) {
		fields = append(fields, placetable.FieldServiceArea)
	}
	if m.FieldCleared(placetable.FieldAmbient) {
		fields = append(fields, placetable.FieldAmbient)
	}
	if m.FieldCleared(placetable.FieldImageURL) {
		fields = append(fields, placetable.FieldImageURL)
	}
	if m.FieldCleared(placetable.FieldRating) {
		fields = append(fields, placetable.FieldRating)
	}
	if m.FieldCleared(placetable.FieldTags) {
		fields = append(fields, placetable.FieldTags)
	}
	if m.FieldCleared(placetable.FieldMetadata) {
		fields = append(fields, placetable.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceTableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceTableMutation) ClearField(name string) error {
	switch name {
	case placetable.FieldName:
		m.ClearName()
		return nil
	case placetable.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case placetable.FieldQrCode:
		m.ClearQrCode()
		return nil
	case placetable.FieldDescription:
		m.ClearDescription()
		return nil
	case placetable.FieldType:
		m.ClearType()
		return nil
	case placetable.FieldLocationDescription:
		m.ClearLocationDescription()
		return nil
	case placetable.FieldMinimumSpend:
		m.ClearMinimumSpend()
		return nil
	case placetable.FieldReservationTime:
		m.ClearReservationTime()
		return nil
	case placetable.FieldNextAvailableTime:
		m.ClearNextAvailableTime()
		return nil
	case placetable.FieldSpecialRequirements:
		m.ClearSpecialRequirements()
		return nil
	case placetable.FieldLayout:
		m.ClearLayout()
		return nil
	case placetable.FieldServiceArea:
		m.ClearServiceArea()
		return nil
	case placetable.FieldAmbient:
		m.ClearAmbient()
		return nil
	case placetable.FieldImageURL:
		m.ClearImageURL()
		return nil
	case placetable.FieldRating:
		m.ClearRating()
		return nil
	case placetable.FieldTags:
		m.ClearTags()
		return nil
	case placetable.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown PlaceTable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceTableMutation) ResetField(name string) error {
	switch name {
	case placetable.FieldNumber:
		m.ResetNumber()
		return nil
	case placetable.FieldName:
		m.ResetName()
		return nil
	case placetable.FieldCapacity:
		m.ResetCapacity()
		return nil
	case placetable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case placetable.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case placetable.FieldQrCode:
		m.ResetQrCode()
		return nil
	case placetable.FieldDescription:
		m.ResetDescription()
		return nil
	case placetable.FieldStatus:
		m.ResetStatus()
		return nil
	case placetable.FieldType:
		m.ResetType()
		return nil
	case placetable.FieldIsActive:
		m.ResetIsActive()
		return nil
	case placetable.FieldIsReserved:
		m.ResetIsReserved()
		return nil
	case placetable.FieldIsVip:
		m.ResetIsVip()
		return nil
	case placetable.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	case placetable.FieldLocationDescription:
		m.ResetLocationDescription()
		return nil
	case placetable.FieldMinimumSpend:
		m.ResetMinimumSpend()
		return nil
	case placetable.FieldReservationTime:
		m.ResetReservationTime()
		return nil
	case placetable.FieldNextAvailableTime:
		m.ResetNextAvailableTime()
		return nil
	case placetable.FieldSpecialRequirements:
		m.ResetSpecialRequirements()
		return nil
	case placetable.FieldLayout:
		m.ResetLayout()
		return nil
	case placetable.FieldServiceArea:
		m.ResetServiceArea()
		return nil
	case placetable.FieldAmbient:
		m.ResetAmbient()
		return nil
	case placetable.FieldImageURL:
		m.ResetImageURL()
		return nil
	case placetable.FieldRating:
		m.ResetRating()
		return nil
	case placetable.FieldTags:
		m.ResetTags()
		return nil
	case placetable.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown PlaceTable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceTableMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.place != nil {
		edges = append(edges, placetable.EdgePlace)
	}
	if m.created_by != nil {
		edges = append(edges, placetable.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, placetable.EdgeUpdatedBy)
	}
	if m.deleted_by != nil {
		edges = append(edges, placetable.EdgeDeletedBy)
	}
	if m.reserved_by != nil {
		edges = append(edges, placetable.EdgeReservedBy)
	}
	if m.waiter != nil {
		edges = append(edges, placetable.EdgeWaiter)
	}
	if m.orders != nil {
		edges = append(edges, placetable.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceTableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case placetable.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case placetable.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case placetable.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	case placetable.EdgeDeletedBy:
		if id := m.deleted_by; id != nil {
			return []ent.Value{*id}
		}
	case placetable.EdgeReservedBy:
		if id := m.reserved_by; id != nil {
			return []ent.Value{*id}
		}
	case placetable.EdgeWaiter:
		if id := m.waiter; id != nil {
			return []ent.Value{*id}
		}
	case placetable.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceTableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedorders != nil {
		edges = append(edges, placetable.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceTableMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case placetable.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceTableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedplace {
		edges = append(edges, placetable.EdgePlace)
	}
	if m.clearedcreated_by {
		edges = append(edges, placetable.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, placetable.EdgeUpdatedBy)
	}
	if m.cleareddeleted_by {
		edges = append(edges, placetable.EdgeDeletedBy)
	}
	if m.clearedreserved_by {
		edges = append(edges, placetable.EdgeReservedBy)
	}
	if m.clearedwaiter {
		edges = append(edges, placetable.EdgeWaiter)
	}
	if m.clearedorders {
		edges = append(edges, placetable.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceTableMutation) EdgeCleared(name string) bool {
	switch name {
	case placetable.EdgePlace:
		return m.clearedplace
	case placetable.EdgeCreatedBy:
		return m.clearedcreated_by
	case placetable.EdgeUpdatedBy:
		return m.clearedupdated_by
	case placetable.EdgeDeletedBy:
		return m.cleareddeleted_by
	case placetable.EdgeReservedBy:
		return m.clearedreserved_by
	case placetable.EdgeWaiter:
		return m.clearedwaiter
	case placetable.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceTableMutation) ClearEdge(name string) error {
	switch name {
	case placetable.EdgePlace:
		m.ClearPlace()
		return nil
	case placetable.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case placetable.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case placetable.EdgeDeletedBy:
		m.ClearDeletedBy()
		return nil
	case placetable.EdgeReservedBy:
		m.ClearReservedBy()
		return nil
	case placetable.EdgeWaiter:
		m.ClearWaiter()
		return nil
	}
	return fmt.Errorf("unknown PlaceTable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceTableMutation) ResetEdge(name string) error {
	switch name {
	case placetable.EdgePlace:
		m.ResetPlace()
		return nil
	case placetable.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case placetable.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case placetable.EdgeDeletedBy:
		m.ResetDeletedBy()
		return nil
	case placetable.EdgeReservedBy:
		m.ResetReservedBy()
		return nil
	case placetable.EdgeWaiter:
		m.ResetWaiter()
		return nil
	case placetable.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown PlaceTable edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	name                 *string
	description          *string
	overview             *string
	features             *[]string
	appendfeatures       []string
	clearedFields        map[string]struct{}
	users                map[string]struct{}
	removedusers         map[string]struct{}
	clearedusers         bool
	businesses           map[string]struct{}
	removedbusinesses    map[string]struct{}
	clearedbusinesses    bool
	places               map[string]struct{}
	removedplaces        map[string]struct{}
	clearedplaces        bool
	media                map[string]struct{}
	removedmedia         map[string]struct{}
	clearedmedia         bool
	prices               map[string]struct{}
	removedprices        map[string]struct{}
	clearedprices        bool
	subscriptions        map[string]struct{}
	removedsubscriptions map[string]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*Plan, error)
	predicates           []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id string) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plan entities.
func (m *PlanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PlanMutation) ClearName() {
	m.name = nil
	m.clearedFields[plan.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PlanMutation) NameCleared() bool {
	_, ok := m.clearedFields[plan.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, plan.FieldName)
}

// SetDescription sets the "description" field.
func (m *PlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[plan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[plan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, plan.FieldDescription)
}

// SetOverview sets the "overview" field.
func (m *PlanMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *PlanMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ClearOverview clears the value of the "overview" field.
func (m *PlanMutation) ClearOverview() {
	m.overview = nil
	m.clearedFields[plan.FieldOverview] = struct{}{}
}

// OverviewCleared returns if the "overview" field was cleared in this mutation.
func (m *PlanMutation) OverviewCleared() bool {
	_, ok := m.clearedFields[plan.FieldOverview]
	return ok
}

// ResetOverview resets all changes to the "overview" field.
func (m *PlanMutation) ResetOverview() {
	m.overview = nil
	delete(m.clearedFields, plan.FieldOverview)
}

// SetFeatures sets the "features" field.
func (m *PlanMutation) SetFeatures(s []string) {
	m.features = &s
	m.appendfeatures = nil
}

// Features returns the value of the "features" field in the mutation.
func (m *PlanMutation) Features() (r []string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// AppendFeatures adds s to the "features" field.
func (m *PlanMutation) AppendFeatures(s []string) {
	m.appendfeatures = append(m.appendfeatures, s...)
}

// AppendedFeatures returns the list of values that were appended to the "features" field in this mutation.
func (m *PlanMutation) AppendedFeatures() ([]string, bool) {
	if len(m.appendfeatures) == 0 {
		return nil, false
	}
	return m.appendfeatures, true
}

// ClearFeatures clears the value of the "features" field.
func (m *PlanMutation) ClearFeatures() {
	m.features = nil
	m.appendfeatures = nil
	m.clearedFields[plan.FieldFeatures] = struct{}{}
}

// FeaturesCleared returns if the "features" field was cleared in this mutation.
func (m *PlanMutation) FeaturesCleared() bool {
	_, ok := m.clearedFields[plan.FieldFeatures]
	return ok
}

// ResetFeatures resets all changes to the "features" field.
func (m *PlanMutation) ResetFeatures() {
	m.features = nil
	m.appendfeatures = nil
	delete(m.clearedFields, plan.FieldFeatures)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *PlanMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *PlanMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *PlanMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *PlanMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *PlanMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *PlanMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *PlanMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddBusinessIDs adds the "businesses" edge to the Business entity by ids.
func (m *PlanMutation) AddBusinessIDs(ids ...string) {
	if m.businesses == nil {
		m.businesses = make(map[string]struct{})
	}
	for i := range ids {
		m.businesses[ids[i]] = struct{}{}
	}
}

// ClearBusinesses clears the "businesses" edge to the Business entity.
func (m *PlanMutation) ClearBusinesses() {
	m.clearedbusinesses = true
}

// BusinessesCleared reports if the "businesses" edge to the Business entity was cleared.
func (m *PlanMutation) BusinessesCleared() bool {
	return m.clearedbusinesses
}

// RemoveBusinessIDs removes the "businesses" edge to the Business entity by IDs.
func (m *PlanMutation) RemoveBusinessIDs(ids ...string) {
	if m.removedbusinesses == nil {
		m.removedbusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.businesses, ids[i])
		m.removedbusinesses[ids[i]] = struct{}{}
	}
}

// RemovedBusinesses returns the removed IDs of the "businesses" edge to the Business entity.
func (m *PlanMutation) RemovedBusinessesIDs() (ids []string) {
	for id := range m.removedbusinesses {
		ids = append(ids, id)
	}
	return
}

// BusinessesIDs returns the "businesses" edge IDs in the mutation.
func (m *PlanMutation) BusinessesIDs() (ids []string) {
	for id := range m.businesses {
		ids = append(ids, id)
	}
	return
}

// ResetBusinesses resets all changes to the "businesses" edge.
func (m *PlanMutation) ResetBusinesses() {
	m.businesses = nil
	m.clearedbusinesses = false
	m.removedbusinesses = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *PlanMutation) AddPlaceIDs(ids ...string) {
	if m.places == nil {
		m.places = make(map[string]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *PlanMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *PlanMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *PlanMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *PlanMutation) RemovedPlacesIDs() (ids []string) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *PlanMutation) PlacesIDs() (ids []string) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *PlanMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *PlanMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *PlanMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *PlanMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *PlanMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *PlanMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *PlanMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *PlanMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddPriceIDs adds the "prices" edge to the Price entity by ids.
func (m *PlanMutation) AddPriceIDs(ids ...string) {
	if m.prices == nil {
		m.prices = make(map[string]struct{})
	}
	for i := range ids {
		m.prices[ids[i]] = struct{}{}
	}
}

// ClearPrices clears the "prices" edge to the Price entity.
func (m *PlanMutation) ClearPrices() {
	m.clearedprices = true
}

// PricesCleared reports if the "prices" edge to the Price entity was cleared.
func (m *PlanMutation) PricesCleared() bool {
	return m.clearedprices
}

// RemovePriceIDs removes the "prices" edge to the Price entity by IDs.
func (m *PlanMutation) RemovePriceIDs(ids ...string) {
	if m.removedprices == nil {
		m.removedprices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.prices, ids[i])
		m.removedprices[ids[i]] = struct{}{}
	}
}

// RemovedPrices returns the removed IDs of the "prices" edge to the Price entity.
func (m *PlanMutation) RemovedPricesIDs() (ids []string) {
	for id := range m.removedprices {
		ids = append(ids, id)
	}
	return
}

// PricesIDs returns the "prices" edge IDs in the mutation.
func (m *PlanMutation) PricesIDs() (ids []string) {
	for id := range m.prices {
		ids = append(ids, id)
	}
	return
}

// ResetPrices resets all changes to the "prices" edge.
func (m *PlanMutation) ResetPrices() {
	m.prices = nil
	m.clearedprices = false
	m.removedprices = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *PlanMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *PlanMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *PlanMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *PlanMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *PlanMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *PlanMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *PlanMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, plan.FieldDescription)
	}
	if m.overview != nil {
		fields = append(fields, plan.FieldOverview)
	}
	if m.features != nil {
		fields = append(fields, plan.FieldFeatures)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldName:
		return m.Name()
	case plan.FieldDescription:
		return m.Description()
	case plan.FieldOverview:
		return m.Overview()
	case plan.FieldFeatures:
		return m.Features()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldDescription:
		return m.OldDescription(ctx)
	case plan.FieldOverview:
		return m.OldOverview(ctx)
	case plan.FieldFeatures:
		return m.OldFeatures(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case plan.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case plan.FieldFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plan.FieldName) {
		fields = append(fields, plan.FieldName)
	}
	if m.FieldCleared(plan.FieldDescription) {
		fields = append(fields, plan.FieldDescription)
	}
	if m.FieldCleared(plan.FieldOverview) {
		fields = append(fields, plan.FieldOverview)
	}
	if m.FieldCleared(plan.FieldFeatures) {
		fields = append(fields, plan.FieldFeatures)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case plan.FieldName:
		m.ClearName()
		return nil
	case plan.FieldDescription:
		m.ClearDescription()
		return nil
	case plan.FieldOverview:
		m.ClearOverview()
		return nil
	case plan.FieldFeatures:
		m.ClearFeatures()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldDescription:
		m.ResetDescription()
		return nil
	case plan.FieldOverview:
		m.ResetOverview()
		return nil
	case plan.FieldFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.users != nil {
		edges = append(edges, plan.EdgeUsers)
	}
	if m.businesses != nil {
		edges = append(edges, plan.EdgeBusinesses)
	}
	if m.places != nil {
		edges = append(edges, plan.EdgePlaces)
	}
	if m.media != nil {
		edges = append(edges, plan.EdgeMedia)
	}
	if m.prices != nil {
		edges = append(edges, plan.EdgePrices)
	}
	if m.subscriptions != nil {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeBusinesses:
		ids := make([]ent.Value, 0, len(m.businesses))
		for id := range m.businesses {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePrices:
		ids := make([]ent.Value, 0, len(m.prices))
		for id := range m.prices {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedusers != nil {
		edges = append(edges, plan.EdgeUsers)
	}
	if m.removedbusinesses != nil {
		edges = append(edges, plan.EdgeBusinesses)
	}
	if m.removedplaces != nil {
		edges = append(edges, plan.EdgePlaces)
	}
	if m.removedmedia != nil {
		edges = append(edges, plan.EdgeMedia)
	}
	if m.removedprices != nil {
		edges = append(edges, plan.EdgePrices)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeBusinesses:
		ids := make([]ent.Value, 0, len(m.removedbusinesses))
		for id := range m.removedbusinesses {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePrices:
		ids := make([]ent.Value, 0, len(m.removedprices))
		for id := range m.removedprices {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedusers {
		edges = append(edges, plan.EdgeUsers)
	}
	if m.clearedbusinesses {
		edges = append(edges, plan.EdgeBusinesses)
	}
	if m.clearedplaces {
		edges = append(edges, plan.EdgePlaces)
	}
	if m.clearedmedia {
		edges = append(edges, plan.EdgeMedia)
	}
	if m.clearedprices {
		edges = append(edges, plan.EdgePrices)
	}
	if m.clearedsubscriptions {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgeUsers:
		return m.clearedusers
	case plan.EdgeBusinesses:
		return m.clearedbusinesses
	case plan.EdgePlaces:
		return m.clearedplaces
	case plan.EdgeMedia:
		return m.clearedmedia
	case plan.EdgePrices:
		return m.clearedprices
	case plan.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgeUsers:
		m.ResetUsers()
		return nil
	case plan.EdgeBusinesses:
		m.ResetBusinesses()
		return nil
	case plan.EdgePlaces:
		m.ResetPlaces()
		return nil
	case plan.EdgeMedia:
		m.ResetMedia()
		return nil
	case plan.EdgePrices:
		m.ResetPrices()
		return nil
	case plan.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	_Content                *string
	_CreatedAt              *time.Time
	_UpdatedAt              *time.Time
	_Privacy                *post.Privacy
	_LikedByMe              *bool
	_LikeCount              *int
	add_LikeCount           *int
	_CommentCount           *int
	add_CommentCount        *int
	_ShareCount             *int
	add_ShareCount          *int
	_ViewCount              *int
	add_ViewCount           *int
	_IsSponsored            *bool
	_IsPromoted             *bool
	_IsBoosted              *bool
	_IsPinned               *bool
	_IsHidden               *bool
	_RepostCount            *int
	add_RepostCount         *int
	_IsRepost               *bool
	_RelevanceScore         *int
	add_RelevanceScore      *int
	_SearchText             *string
	clearedFields           map[string]struct{}
	user                    *string
	cleareduser             bool
	business_account        *string
	clearedbusiness_account bool
	medias                  map[string]struct{}
	removedmedias           map[string]struct{}
	clearedmedias           bool
	comments                map[string]struct{}
	removedcomments         map[string]struct{}
	clearedcomments         bool
	likes                   map[string]struct{}
	removedlikes            map[string]struct{}
	clearedlikes            bool
	categories              map[string]struct{}
	removedcategories       map[string]struct{}
	clearedcategories       bool
	notifications           map[string]struct{}
	removednotifications    map[string]struct{}
	clearednotifications    bool
	reposts                 *string
	clearedreposts          bool
	original_post           map[string]struct{}
	removedoriginal_post    map[string]struct{}
	clearedoriginal_post    bool
	done                    bool
	oldValue                func(context.Context) (*Post, error)
	predicates              []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id string) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "Content" field.
func (m *PostMutation) SetContent(s string) {
	m._Content = &s
}

// Content returns the value of the "Content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m._Content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "Content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "Content" field.
func (m *PostMutation) ClearContent() {
	m._Content = nil
	m.clearedFields[post.FieldContent] = struct{}{}
}

// ContentCleared returns if the "Content" field was cleared in this mutation.
func (m *PostMutation) ContentCleared() bool {
	_, ok := m.clearedFields[post.FieldContent]
	return ok
}

// ResetContent resets all changes to the "Content" field.
func (m *PostMutation) ResetContent() {
	m._Content = nil
	delete(m.clearedFields, post.FieldContent)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *PostMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *PostMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetPrivacy sets the "Privacy" field.
func (m *PostMutation) SetPrivacy(po post.Privacy) {
	m._Privacy = &po
}

// Privacy returns the value of the "Privacy" field in the mutation.
func (m *PostMutation) Privacy() (r post.Privacy, exists bool) {
	v := m._Privacy
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivacy returns the old "Privacy" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPrivacy(ctx context.Context) (v post.Privacy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivacy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivacy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivacy: %w", err)
	}
	return oldValue.Privacy, nil
}

// ResetPrivacy resets all changes to the "Privacy" field.
func (m *PostMutation) ResetPrivacy() {
	m._Privacy = nil
}

// SetLikedByMe sets the "LikedByMe" field.
func (m *PostMutation) SetLikedByMe(b bool) {
	m._LikedByMe = &b
}

// LikedByMe returns the value of the "LikedByMe" field in the mutation.
func (m *PostMutation) LikedByMe() (r bool, exists bool) {
	v := m._LikedByMe
	if v == nil {
		return
	}
	return *v, true
}

// OldLikedByMe returns the old "LikedByMe" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLikedByMe(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikedByMe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikedByMe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikedByMe: %w", err)
	}
	return oldValue.LikedByMe, nil
}

// ResetLikedByMe resets all changes to the "LikedByMe" field.
func (m *PostMutation) ResetLikedByMe() {
	m._LikedByMe = nil
}

// SetLikeCount sets the "LikeCount" field.
func (m *PostMutation) SetLikeCount(i int) {
	m._LikeCount = &i
	m.add_LikeCount = nil
}

// LikeCount returns the value of the "LikeCount" field in the mutation.
func (m *PostMutation) LikeCount() (r int, exists bool) {
	v := m._LikeCount
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "LikeCount" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "LikeCount" field.
func (m *PostMutation) AddLikeCount(i int) {
	if m.add_LikeCount != nil {
		*m.add_LikeCount += i
	} else {
		m.add_LikeCount = &i
	}
}

// AddedLikeCount returns the value that was added to the "LikeCount" field in this mutation.
func (m *PostMutation) AddedLikeCount() (r int, exists bool) {
	v := m.add_LikeCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "LikeCount" field.
func (m *PostMutation) ResetLikeCount() {
	m._LikeCount = nil
	m.add_LikeCount = nil
}

// SetCommentCount sets the "CommentCount" field.
func (m *PostMutation) SetCommentCount(i int) {
	m._CommentCount = &i
	m.add_CommentCount = nil
}

// CommentCount returns the value of the "CommentCount" field in the mutation.
func (m *PostMutation) CommentCount() (r int, exists bool) {
	v := m._CommentCount
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "CommentCount" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCommentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "CommentCount" field.
func (m *PostMutation) AddCommentCount(i int) {
	if m.add_CommentCount != nil {
		*m.add_CommentCount += i
	} else {
		m.add_CommentCount = &i
	}
}

// AddedCommentCount returns the value that was added to the "CommentCount" field in this mutation.
func (m *PostMutation) AddedCommentCount() (r int, exists bool) {
	v := m.add_CommentCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "CommentCount" field.
func (m *PostMutation) ResetCommentCount() {
	m._CommentCount = nil
	m.add_CommentCount = nil
}

// SetShareCount sets the "ShareCount" field.
func (m *PostMutation) SetShareCount(i int) {
	m._ShareCount = &i
	m.add_ShareCount = nil
}

// ShareCount returns the value of the "ShareCount" field in the mutation.
func (m *PostMutation) ShareCount() (r int, exists bool) {
	v := m._ShareCount
	if v == nil {
		return
	}
	return *v, true
}

// OldShareCount returns the old "ShareCount" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldShareCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareCount: %w", err)
	}
	return oldValue.ShareCount, nil
}

// AddShareCount adds i to the "ShareCount" field.
func (m *PostMutation) AddShareCount(i int) {
	if m.add_ShareCount != nil {
		*m.add_ShareCount += i
	} else {
		m.add_ShareCount = &i
	}
}

// AddedShareCount returns the value that was added to the "ShareCount" field in this mutation.
func (m *PostMutation) AddedShareCount() (r int, exists bool) {
	v := m.add_ShareCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetShareCount resets all changes to the "ShareCount" field.
func (m *PostMutation) ResetShareCount() {
	m._ShareCount = nil
	m.add_ShareCount = nil
}

// SetViewCount sets the "ViewCount" field.
func (m *PostMutation) SetViewCount(i int) {
	m._ViewCount = &i
	m.add_ViewCount = nil
}

// ViewCount returns the value of the "ViewCount" field in the mutation.
func (m *PostMutation) ViewCount() (r int, exists bool) {
	v := m._ViewCount
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "ViewCount" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "ViewCount" field.
func (m *PostMutation) AddViewCount(i int) {
	if m.add_ViewCount != nil {
		*m.add_ViewCount += i
	} else {
		m.add_ViewCount = &i
	}
}

// AddedViewCount returns the value that was added to the "ViewCount" field in this mutation.
func (m *PostMutation) AddedViewCount() (r int, exists bool) {
	v := m.add_ViewCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "ViewCount" field.
func (m *PostMutation) ResetViewCount() {
	m._ViewCount = nil
	m.add_ViewCount = nil
}

// SetIsSponsored sets the "IsSponsored" field.
func (m *PostMutation) SetIsSponsored(b bool) {
	m._IsSponsored = &b
}

// IsSponsored returns the value of the "IsSponsored" field in the mutation.
func (m *PostMutation) IsSponsored() (r bool, exists bool) {
	v := m._IsSponsored
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSponsored returns the old "IsSponsored" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsSponsored(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSponsored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSponsored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSponsored: %w", err)
	}
	return oldValue.IsSponsored, nil
}

// ResetIsSponsored resets all changes to the "IsSponsored" field.
func (m *PostMutation) ResetIsSponsored() {
	m._IsSponsored = nil
}

// SetIsPromoted sets the "IsPromoted" field.
func (m *PostMutation) SetIsPromoted(b bool) {
	m._IsPromoted = &b
}

// IsPromoted returns the value of the "IsPromoted" field in the mutation.
func (m *PostMutation) IsPromoted() (r bool, exists bool) {
	v := m._IsPromoted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPromoted returns the old "IsPromoted" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsPromoted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPromoted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPromoted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPromoted: %w", err)
	}
	return oldValue.IsPromoted, nil
}

// ResetIsPromoted resets all changes to the "IsPromoted" field.
func (m *PostMutation) ResetIsPromoted() {
	m._IsPromoted = nil
}

// SetIsBoosted sets the "IsBoosted" field.
func (m *PostMutation) SetIsBoosted(b bool) {
	m._IsBoosted = &b
}

// IsBoosted returns the value of the "IsBoosted" field in the mutation.
func (m *PostMutation) IsBoosted() (r bool, exists bool) {
	v := m._IsBoosted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBoosted returns the old "IsBoosted" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsBoosted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBoosted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBoosted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBoosted: %w", err)
	}
	return oldValue.IsBoosted, nil
}

// ResetIsBoosted resets all changes to the "IsBoosted" field.
func (m *PostMutation) ResetIsBoosted() {
	m._IsBoosted = nil
}

// SetIsPinned sets the "IsPinned" field.
func (m *PostMutation) SetIsPinned(b bool) {
	m._IsPinned = &b
}

// IsPinned returns the value of the "IsPinned" field in the mutation.
func (m *PostMutation) IsPinned() (r bool, exists bool) {
	v := m._IsPinned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinned returns the old "IsPinned" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinned: %w", err)
	}
	return oldValue.IsPinned, nil
}

// ResetIsPinned resets all changes to the "IsPinned" field.
func (m *PostMutation) ResetIsPinned() {
	m._IsPinned = nil
}

// SetIsHidden sets the "IsHidden" field.
func (m *PostMutation) SetIsHidden(b bool) {
	m._IsHidden = &b
}

// IsHidden returns the value of the "IsHidden" field in the mutation.
func (m *PostMutation) IsHidden() (r bool, exists bool) {
	v := m._IsHidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "IsHidden" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "IsHidden" field.
func (m *PostMutation) ResetIsHidden() {
	m._IsHidden = nil
}

// SetRepostCount sets the "RepostCount" field.
func (m *PostMutation) SetRepostCount(i int) {
	m._RepostCount = &i
	m.add_RepostCount = nil
}

// RepostCount returns the value of the "RepostCount" field in the mutation.
func (m *PostMutation) RepostCount() (r int, exists bool) {
	v := m._RepostCount
	if v == nil {
		return
	}
	return *v, true
}

// OldRepostCount returns the old "RepostCount" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldRepostCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepostCount: %w", err)
	}
	return oldValue.RepostCount, nil
}

// AddRepostCount adds i to the "RepostCount" field.
func (m *PostMutation) AddRepostCount(i int) {
	if m.add_RepostCount != nil {
		*m.add_RepostCount += i
	} else {
		m.add_RepostCount = &i
	}
}

// AddedRepostCount returns the value that was added to the "RepostCount" field in this mutation.
func (m *PostMutation) AddedRepostCount() (r int, exists bool) {
	v := m.add_RepostCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepostCount resets all changes to the "RepostCount" field.
func (m *PostMutation) ResetRepostCount() {
	m._RepostCount = nil
	m.add_RepostCount = nil
}

// SetIsRepost sets the "IsRepost" field.
func (m *PostMutation) SetIsRepost(b bool) {
	m._IsRepost = &b
}

// IsRepost returns the value of the "IsRepost" field in the mutation.
func (m *PostMutation) IsRepost() (r bool, exists bool) {
	v := m._IsRepost
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRepost returns the old "IsRepost" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsRepost(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRepost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRepost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRepost: %w", err)
	}
	return oldValue.IsRepost, nil
}

// ResetIsRepost resets all changes to the "IsRepost" field.
func (m *PostMutation) ResetIsRepost() {
	m._IsRepost = nil
}

// SetRelevanceScore sets the "RelevanceScore" field.
func (m *PostMutation) SetRelevanceScore(i int) {
	m._RelevanceScore = &i
	m.add_RelevanceScore = nil
}

// RelevanceScore returns the value of the "RelevanceScore" field in the mutation.
func (m *PostMutation) RelevanceScore() (r int, exists bool) {
	v := m._RelevanceScore
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "RelevanceScore" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldRelevanceScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds i to the "RelevanceScore" field.
func (m *PostMutation) AddRelevanceScore(i int) {
	if m.add_RelevanceScore != nil {
		*m.add_RelevanceScore += i
	} else {
		m.add_RelevanceScore = &i
	}
}

// AddedRelevanceScore returns the value that was added to the "RelevanceScore" field in this mutation.
func (m *PostMutation) AddedRelevanceScore() (r int, exists bool) {
	v := m.add_RelevanceScore
	if v == nil {
		return
	}
	return *v, true
}

// ResetRelevanceScore resets all changes to the "RelevanceScore" field.
func (m *PostMutation) ResetRelevanceScore() {
	m._RelevanceScore = nil
	m.add_RelevanceScore = nil
}

// SetSearchText sets the "SearchText" field.
func (m *PostMutation) SetSearchText(s string) {
	m._SearchText = &s
}

// SearchText returns the value of the "SearchText" field in the mutation.
func (m *PostMutation) SearchText() (r string, exists bool) {
	v := m._SearchText
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "SearchText" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "SearchText" field.
func (m *PostMutation) ClearSearchText() {
	m._SearchText = nil
	m.clearedFields[post.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "SearchText" field was cleared in this mutation.
func (m *PostMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[post.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "SearchText" field.
func (m *PostMutation) ResetSearchText() {
	m._SearchText = nil
	delete(m.clearedFields, post.FieldSearchText)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PostMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PostMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PostMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PostMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessAccountID sets the "business_account" edge to the Business entity by id.
func (m *PostMutation) SetBusinessAccountID(id string) {
	m.business_account = &id
}

// ClearBusinessAccount clears the "business_account" edge to the Business entity.
func (m *PostMutation) ClearBusinessAccount() {
	m.clearedbusiness_account = true
}

// BusinessAccountCleared reports if the "business_account" edge to the Business entity was cleared.
func (m *PostMutation) BusinessAccountCleared() bool {
	return m.clearedbusiness_account
}

// BusinessAccountID returns the "business_account" edge ID in the mutation.
func (m *PostMutation) BusinessAccountID() (id string, exists bool) {
	if m.business_account != nil {
		return *m.business_account, true
	}
	return
}

// BusinessAccountIDs returns the "business_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessAccountID instead. It exists only for internal usage by the builders.
func (m *PostMutation) BusinessAccountIDs() (ids []string) {
	if id := m.business_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessAccount resets all changes to the "business_account" edge.
func (m *PostMutation) ResetBusinessAccount() {
	m.business_account = nil
	m.clearedbusiness_account = false
}

// AddMediaIDs adds the "medias" edge to the Media entity by ids.
func (m *PostMutation) AddMediaIDs(ids ...string) {
	if m.medias == nil {
		m.medias = make(map[string]struct{})
	}
	for i := range ids {
		m.medias[ids[i]] = struct{}{}
	}
}

// ClearMedias clears the "medias" edge to the Media entity.
func (m *PostMutation) ClearMedias() {
	m.clearedmedias = true
}

// MediasCleared reports if the "medias" edge to the Media entity was cleared.
func (m *PostMutation) MediasCleared() bool {
	return m.clearedmedias
}

// RemoveMediaIDs removes the "medias" edge to the Media entity by IDs.
func (m *PostMutation) RemoveMediaIDs(ids ...string) {
	if m.removedmedias == nil {
		m.removedmedias = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.medias, ids[i])
		m.removedmedias[ids[i]] = struct{}{}
	}
}

// RemovedMedias returns the removed IDs of the "medias" edge to the Media entity.
func (m *PostMutation) RemovedMediasIDs() (ids []string) {
	for id := range m.removedmedias {
		ids = append(ids, id)
	}
	return
}

// MediasIDs returns the "medias" edge IDs in the mutation.
func (m *PostMutation) MediasIDs() (ids []string) {
	for id := range m.medias {
		ids = append(ids, id)
	}
	return
}

// ResetMedias resets all changes to the "medias" edge.
func (m *PostMutation) ResetMedias() {
	m.medias = nil
	m.clearedmedias = false
	m.removedmedias = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *PostMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *PostMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *PostMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *PostMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *PostMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *PostMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *PostMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikeIDs adds the "likes" edge to the Like entity by ids.
func (m *PostMutation) AddLikeIDs(ids ...string) {
	if m.likes == nil {
		m.likes = make(map[string]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the Like entity.
func (m *PostMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the Like entity was cleared.
func (m *PostMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the Like entity by IDs.
func (m *PostMutation) RemoveLikeIDs(ids ...string) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the Like entity.
func (m *PostMutation) RemovedLikesIDs() (ids []string) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *PostMutation) LikesIDs() (ids []string) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *PostMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *PostMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *PostMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *PostMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *PostMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *PostMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *PostMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *PostMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *PostMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *PostMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *PostMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *PostMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *PostMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *PostMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// SetRepostsID sets the "reposts" edge to the Post entity by id.
func (m *PostMutation) SetRepostsID(id string) {
	m.reposts = &id
}

// ClearReposts clears the "reposts" edge to the Post entity.
func (m *PostMutation) ClearReposts() {
	m.clearedreposts = true
}

// RepostsCleared reports if the "reposts" edge to the Post entity was cleared.
func (m *PostMutation) RepostsCleared() bool {
	return m.clearedreposts
}

// RepostsID returns the "reposts" edge ID in the mutation.
func (m *PostMutation) RepostsID() (id string, exists bool) {
	if m.reposts != nil {
		return *m.reposts, true
	}
	return
}

// RepostsIDs returns the "reposts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepostsID instead. It exists only for internal usage by the builders.
func (m *PostMutation) RepostsIDs() (ids []string) {
	if id := m.reposts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReposts resets all changes to the "reposts" edge.
func (m *PostMutation) ResetReposts() {
	m.reposts = nil
	m.clearedreposts = false
}

// AddOriginalPostIDs adds the "original_post" edge to the Post entity by ids.
func (m *PostMutation) AddOriginalPostIDs(ids ...string) {
	if m.original_post == nil {
		m.original_post = make(map[string]struct{})
	}
	for i := range ids {
		m.original_post[ids[i]] = struct{}{}
	}
}

// ClearOriginalPost clears the "original_post" edge to the Post entity.
func (m *PostMutation) ClearOriginalPost() {
	m.clearedoriginal_post = true
}

// OriginalPostCleared reports if the "original_post" edge to the Post entity was cleared.
func (m *PostMutation) OriginalPostCleared() bool {
	return m.clearedoriginal_post
}

// RemoveOriginalPostIDs removes the "original_post" edge to the Post entity by IDs.
func (m *PostMutation) RemoveOriginalPostIDs(ids ...string) {
	if m.removedoriginal_post == nil {
		m.removedoriginal_post = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.original_post, ids[i])
		m.removedoriginal_post[ids[i]] = struct{}{}
	}
}

// RemovedOriginalPost returns the removed IDs of the "original_post" edge to the Post entity.
func (m *PostMutation) RemovedOriginalPostIDs() (ids []string) {
	for id := range m.removedoriginal_post {
		ids = append(ids, id)
	}
	return
}

// OriginalPostIDs returns the "original_post" edge IDs in the mutation.
func (m *PostMutation) OriginalPostIDs() (ids []string) {
	for id := range m.original_post {
		ids = append(ids, id)
	}
	return
}

// ResetOriginalPost resets all changes to the "original_post" edge.
func (m *PostMutation) ResetOriginalPost() {
	m.original_post = nil
	m.clearedoriginal_post = false
	m.removedoriginal_post = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m._Content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m._CreatedAt != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m._Privacy != nil {
		fields = append(fields, post.FieldPrivacy)
	}
	if m._LikedByMe != nil {
		fields = append(fields, post.FieldLikedByMe)
	}
	if m._LikeCount != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m._CommentCount != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	if m._ShareCount != nil {
		fields = append(fields, post.FieldShareCount)
	}
	if m._ViewCount != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m._IsSponsored != nil {
		fields = append(fields, post.FieldIsSponsored)
	}
	if m._IsPromoted != nil {
		fields = append(fields, post.FieldIsPromoted)
	}
	if m._IsBoosted != nil {
		fields = append(fields, post.FieldIsBoosted)
	}
	if m._IsPinned != nil {
		fields = append(fields, post.FieldIsPinned)
	}
	if m._IsHidden != nil {
		fields = append(fields, post.FieldIsHidden)
	}
	if m._RepostCount != nil {
		fields = append(fields, post.FieldRepostCount)
	}
	if m._IsRepost != nil {
		fields = append(fields, post.FieldIsRepost)
	}
	if m._RelevanceScore != nil {
		fields = append(fields, post.FieldRelevanceScore)
	}
	if m._SearchText != nil {
		fields = append(fields, post.FieldSearchText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldContent:
		return m.Content()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldPrivacy:
		return m.Privacy()
	case post.FieldLikedByMe:
		return m.LikedByMe()
	case post.FieldLikeCount:
		return m.LikeCount()
	case post.FieldCommentCount:
		return m.CommentCount()
	case post.FieldShareCount:
		return m.ShareCount()
	case post.FieldViewCount:
		return m.ViewCount()
	case post.FieldIsSponsored:
		return m.IsSponsored()
	case post.FieldIsPromoted:
		return m.IsPromoted()
	case post.FieldIsBoosted:
		return m.IsBoosted()
	case post.FieldIsPinned:
		return m.IsPinned()
	case post.FieldIsHidden:
		return m.IsHidden()
	case post.FieldRepostCount:
		return m.RepostCount()
	case post.FieldIsRepost:
		return m.IsRepost()
	case post.FieldRelevanceScore:
		return m.RelevanceScore()
	case post.FieldSearchText:
		return m.SearchText()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldPrivacy:
		return m.OldPrivacy(ctx)
	case post.FieldLikedByMe:
		return m.OldLikedByMe(ctx)
	case post.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case post.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case post.FieldShareCount:
		return m.OldShareCount(ctx)
	case post.FieldViewCount:
		return m.OldViewCount(ctx)
	case post.FieldIsSponsored:
		return m.OldIsSponsored(ctx)
	case post.FieldIsPromoted:
		return m.OldIsPromoted(ctx)
	case post.FieldIsBoosted:
		return m.OldIsBoosted(ctx)
	case post.FieldIsPinned:
		return m.OldIsPinned(ctx)
	case post.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case post.FieldRepostCount:
		return m.OldRepostCount(ctx)
	case post.FieldIsRepost:
		return m.OldIsRepost(ctx)
	case post.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	case post.FieldSearchText:
		return m.OldSearchText(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldPrivacy:
		v, ok := value.(post.Privacy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivacy(v)
		return nil
	case post.FieldLikedByMe:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedByMe(v)
		return nil
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case post.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareCount(v)
		return nil
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case post.FieldIsSponsored:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSponsored(v)
		return nil
	case post.FieldIsPromoted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPromoted(v)
		return nil
	case post.FieldIsBoosted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBoosted(v)
		return nil
	case post.FieldIsPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinned(v)
		return nil
	case post.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case post.FieldRepostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepostCount(v)
		return nil
	case post.FieldIsRepost:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRepost(v)
		return nil
	case post.FieldRelevanceScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	case post.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.add_LikeCount != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m.add_CommentCount != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	if m.add_ShareCount != nil {
		fields = append(fields, post.FieldShareCount)
	}
	if m.add_ViewCount != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m.add_RepostCount != nil {
		fields = append(fields, post.FieldRepostCount)
	}
	if m.add_RelevanceScore != nil {
		fields = append(fields, post.FieldRelevanceScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldLikeCount:
		return m.AddedLikeCount()
	case post.FieldCommentCount:
		return m.AddedCommentCount()
	case post.FieldShareCount:
		return m.AddedShareCount()
	case post.FieldViewCount:
		return m.AddedViewCount()
	case post.FieldRepostCount:
		return m.AddedRepostCount()
	case post.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case post.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShareCount(v)
		return nil
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case post.FieldRepostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepostCount(v)
		return nil
	case post.FieldRelevanceScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldContent) {
		fields = append(fields, post.FieldContent)
	}
	if m.FieldCleared(post.FieldSearchText) {
		fields = append(fields, post.FieldSearchText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldContent:
		m.ClearContent()
		return nil
	case post.FieldSearchText:
		m.ClearSearchText()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldPrivacy:
		m.ResetPrivacy()
		return nil
	case post.FieldLikedByMe:
		m.ResetLikedByMe()
		return nil
	case post.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case post.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case post.FieldShareCount:
		m.ResetShareCount()
		return nil
	case post.FieldViewCount:
		m.ResetViewCount()
		return nil
	case post.FieldIsSponsored:
		m.ResetIsSponsored()
		return nil
	case post.FieldIsPromoted:
		m.ResetIsPromoted()
		return nil
	case post.FieldIsBoosted:
		m.ResetIsBoosted()
		return nil
	case post.FieldIsPinned:
		m.ResetIsPinned()
		return nil
	case post.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case post.FieldRepostCount:
		m.ResetRepostCount()
		return nil
	case post.FieldIsRepost:
		m.ResetIsRepost()
		return nil
	case post.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	case post.FieldSearchText:
		m.ResetSearchText()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.user != nil {
		edges = append(edges, post.EdgeUser)
	}
	if m.business_account != nil {
		edges = append(edges, post.EdgeBusinessAccount)
	}
	if m.medias != nil {
		edges = append(edges, post.EdgeMedias)
	}
	if m.comments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.likes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.categories != nil {
		edges = append(edges, post.EdgeCategories)
	}
	if m.notifications != nil {
		edges = append(edges, post.EdgeNotifications)
	}
	if m.reposts != nil {
		edges = append(edges, post.EdgeReposts)
	}
	if m.original_post != nil {
		edges = append(edges, post.EdgeOriginalPost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeBusinessAccount:
		if id := m.business_account; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.medias))
		for id := range m.medias {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReposts:
		if id := m.reposts; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeOriginalPost:
		ids := make([]ent.Value, 0, len(m.original_post))
		for id := range m.original_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedmedias != nil {
		edges = append(edges, post.EdgeMedias)
	}
	if m.removedcomments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.removedlikes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.removedcategories != nil {
		edges = append(edges, post.EdgeCategories)
	}
	if m.removednotifications != nil {
		edges = append(edges, post.EdgeNotifications)
	}
	if m.removedoriginal_post != nil {
		edges = append(edges, post.EdgeOriginalPost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.removedmedias))
		for id := range m.removedmedias {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeOriginalPost:
		ids := make([]ent.Value, 0, len(m.removedoriginal_post))
		for id := range m.removedoriginal_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.cleareduser {
		edges = append(edges, post.EdgeUser)
	}
	if m.clearedbusiness_account {
		edges = append(edges, post.EdgeBusinessAccount)
	}
	if m.clearedmedias {
		edges = append(edges, post.EdgeMedias)
	}
	if m.clearedcomments {
		edges = append(edges, post.EdgeComments)
	}
	if m.clearedlikes {
		edges = append(edges, post.EdgeLikes)
	}
	if m.clearedcategories {
		edges = append(edges, post.EdgeCategories)
	}
	if m.clearednotifications {
		edges = append(edges, post.EdgeNotifications)
	}
	if m.clearedreposts {
		edges = append(edges, post.EdgeReposts)
	}
	if m.clearedoriginal_post {
		edges = append(edges, post.EdgeOriginalPost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeUser:
		return m.cleareduser
	case post.EdgeBusinessAccount:
		return m.clearedbusiness_account
	case post.EdgeMedias:
		return m.clearedmedias
	case post.EdgeComments:
		return m.clearedcomments
	case post.EdgeLikes:
		return m.clearedlikes
	case post.EdgeCategories:
		return m.clearedcategories
	case post.EdgeNotifications:
		return m.clearednotifications
	case post.EdgeReposts:
		return m.clearedreposts
	case post.EdgeOriginalPost:
		return m.clearedoriginal_post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ClearUser()
		return nil
	case post.EdgeBusinessAccount:
		m.ClearBusinessAccount()
		return nil
	case post.EdgeReposts:
		m.ClearReposts()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ResetUser()
		return nil
	case post.EdgeBusinessAccount:
		m.ResetBusinessAccount()
		return nil
	case post.EdgeMedias:
		m.ResetMedias()
		return nil
	case post.EdgeComments:
		m.ResetComments()
		return nil
	case post.EdgeLikes:
		m.ResetLikes()
		return nil
	case post.EdgeCategories:
		m.ResetCategories()
		return nil
	case post.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case post.EdgeReposts:
		m.ResetReposts()
		return nil
	case post.EdgeOriginalPost:
		m.ResetOriginalPost()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PriceMutation represents an operation that mutates the Price nodes in the graph.
type PriceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	price                *float64
	addprice             *float64
	currency             *string
	description          *string
	_type                *price.Type
	duration             *int
	addduration          *int
	session              *int
	addsession           *int
	clearedFields        map[string]struct{}
	plan                 *string
	clearedplan          bool
	subscriptions        map[string]struct{}
	removedsubscriptions map[string]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*Price, error)
	predicates           []predicate.Price
}

var _ ent.Mutation = (*PriceMutation)(nil)

// priceOption allows management of the mutation configuration using functional options.
type priceOption func(*PriceMutation)

// newPriceMutation creates new mutation for the Price entity.
func newPriceMutation(c config, op Op, opts ...priceOption) *PriceMutation {
	m := &PriceMutation{
		config:        c,
		op:            op,
		typ:           TypePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceID sets the ID field of the mutation.
func withPriceID(id string) priceOption {
	return func(m *PriceMutation) {
		var (
			err   error
			once  sync.Once
			value *Price
		)
		m.oldValue = func(ctx context.Context) (*Price, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Price.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrice sets the old Price of the mutation.
func withPrice(node *Price) priceOption {
	return func(m *PriceMutation) {
		m.oldValue = func(context.Context) (*Price, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Price entities.
func (m *PriceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Price.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrice sets the "price" field.
func (m *PriceMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PriceMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PriceMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PriceMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PriceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetCurrency sets the "currency" field.
func (m *PriceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PriceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *PriceMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[price.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *PriceMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[price.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PriceMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, price.FieldCurrency)
}

// SetDescription sets the "description" field.
func (m *PriceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PriceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PriceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[price.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PriceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[price.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PriceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, price.FieldDescription)
}

// SetType sets the "type" field.
func (m *PriceMutation) SetType(pr price.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *PriceMutation) GetType() (r price.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldType(ctx context.Context) (v price.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PriceMutation) ResetType() {
	m._type = nil
}

// SetDuration sets the "duration" field.
func (m *PriceMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *PriceMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *PriceMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *PriceMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *PriceMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[price.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *PriceMutation) DurationCleared() bool {
	_, ok := m.clearedFields[price.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *PriceMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, price.FieldDuration)
}

// SetSession sets the "session" field.
func (m *PriceMutation) SetSession(i int) {
	m.session = &i
	m.addsession = nil
}

// Session returns the value of the "session" field in the mutation.
func (m *PriceMutation) Session() (r int, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSession returns the old "session" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldSession(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSession: %w", err)
	}
	return oldValue.Session, nil
}

// AddSession adds i to the "session" field.
func (m *PriceMutation) AddSession(i int) {
	if m.addsession != nil {
		*m.addsession += i
	} else {
		m.addsession = &i
	}
}

// AddedSession returns the value that was added to the "session" field in this mutation.
func (m *PriceMutation) AddedSession() (r int, exists bool) {
	v := m.addsession
	if v == nil {
		return
	}
	return *v, true
}

// ClearSession clears the value of the "session" field.
func (m *PriceMutation) ClearSession() {
	m.session = nil
	m.addsession = nil
	m.clearedFields[price.FieldSession] = struct{}{}
}

// SessionCleared returns if the "session" field was cleared in this mutation.
func (m *PriceMutation) SessionCleared() bool {
	_, ok := m.clearedFields[price.FieldSession]
	return ok
}

// ResetSession resets all changes to the "session" field.
func (m *PriceMutation) ResetSession() {
	m.session = nil
	m.addsession = nil
	delete(m.clearedFields, price.FieldSession)
}

// SetPlanID sets the "plan" edge to the Plan entity by id.
func (m *PriceMutation) SetPlanID(id string) {
	m.plan = &id
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *PriceMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *PriceMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanID returns the "plan" edge ID in the mutation.
func (m *PriceMutation) PlanID() (id string, exists bool) {
	if m.plan != nil {
		return *m.plan, true
	}
	return
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *PriceMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *PriceMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *PriceMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *PriceMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *PriceMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *PriceMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *PriceMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *PriceMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *PriceMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the PriceMutation builder.
func (m *PriceMutation) Where(ps ...predicate.Price) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Price, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Price).
func (m *PriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.price != nil {
		fields = append(fields, price.FieldPrice)
	}
	if m.currency != nil {
		fields = append(fields, price.FieldCurrency)
	}
	if m.description != nil {
		fields = append(fields, price.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, price.FieldType)
	}
	if m.duration != nil {
		fields = append(fields, price.FieldDuration)
	}
	if m.session != nil {
		fields = append(fields, price.FieldSession)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case price.FieldPrice:
		return m.Price()
	case price.FieldCurrency:
		return m.Currency()
	case price.FieldDescription:
		return m.Description()
	case price.FieldType:
		return m.GetType()
	case price.FieldDuration:
		return m.Duration()
	case price.FieldSession:
		return m.Session()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case price.FieldPrice:
		return m.OldPrice(ctx)
	case price.FieldCurrency:
		return m.OldCurrency(ctx)
	case price.FieldDescription:
		return m.OldDescription(ctx)
	case price.FieldType:
		return m.OldType(ctx)
	case price.FieldDuration:
		return m.OldDuration(ctx)
	case price.FieldSession:
		return m.OldSession(ctx)
	}
	return nil, fmt.Errorf("unknown Price field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case price.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case price.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case price.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case price.FieldType:
		v, ok := value.(price.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case price.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case price.FieldSession:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSession(v)
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, price.FieldPrice)
	}
	if m.addduration != nil {
		fields = append(fields, price.FieldDuration)
	}
	if m.addsession != nil {
		fields = append(fields, price.FieldSession)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case price.FieldPrice:
		return m.AddedPrice()
	case price.FieldDuration:
		return m.AddedDuration()
	case price.FieldSession:
		return m.AddedSession()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case price.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case price.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case price.FieldSession:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSession(v)
		return nil
	}
	return fmt.Errorf("unknown Price numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(price.FieldCurrency) {
		fields = append(fields, price.FieldCurrency)
	}
	if m.FieldCleared(price.FieldDescription) {
		fields = append(fields, price.FieldDescription)
	}
	if m.FieldCleared(price.FieldDuration) {
		fields = append(fields, price.FieldDuration)
	}
	if m.FieldCleared(price.FieldSession) {
		fields = append(fields, price.FieldSession)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceMutation) ClearField(name string) error {
	switch name {
	case price.FieldCurrency:
		m.ClearCurrency()
		return nil
	case price.FieldDescription:
		m.ClearDescription()
		return nil
	case price.FieldDuration:
		m.ClearDuration()
		return nil
	case price.FieldSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown Price nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceMutation) ResetField(name string) error {
	switch name {
	case price.FieldPrice:
		m.ResetPrice()
		return nil
	case price.FieldCurrency:
		m.ResetCurrency()
		return nil
	case price.FieldDescription:
		m.ResetDescription()
		return nil
	case price.FieldType:
		m.ResetType()
		return nil
	case price.FieldDuration:
		m.ResetDuration()
		return nil
	case price.FieldSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.plan != nil {
		edges = append(edges, price.EdgePlan)
	}
	if m.subscriptions != nil {
		edges = append(edges, price.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case price.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case price.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubscriptions != nil {
		edges = append(edges, price.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case price.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplan {
		edges = append(edges, price.EdgePlan)
	}
	if m.clearedsubscriptions {
		edges = append(edges, price.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceMutation) EdgeCleared(name string) bool {
	switch name {
	case price.EdgePlan:
		return m.clearedplan
	case price.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceMutation) ClearEdge(name string) error {
	switch name {
	case price.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown Price unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceMutation) ResetEdge(name string) error {
	switch name {
	case price.EdgePlan:
		m.ResetPlan()
		return nil
	case price.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown Price edge %s", name)
}

// RatingMutation represents an operation that mutates the Rating nodes in the graph.
type RatingMutation struct {
	config
	op              Op
	typ             string
	id              *string
	score           *int
	addscore        *int
	review          *string
	ratedAt         *time.Time
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	place           *string
	clearedplace    bool
	event           *string
	clearedevent    bool
	done            bool
	oldValue        func(context.Context) (*Rating, error)
	predicates      []predicate.Rating
}

var _ ent.Mutation = (*RatingMutation)(nil)

// ratingOption allows management of the mutation configuration using functional options.
type ratingOption func(*RatingMutation)

// newRatingMutation creates new mutation for the Rating entity.
func newRatingMutation(c config, op Op, opts ...ratingOption) *RatingMutation {
	m := &RatingMutation{
		config:        c,
		op:            op,
		typ:           TypeRating,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRatingID sets the ID field of the mutation.
func withRatingID(id string) ratingOption {
	return func(m *RatingMutation) {
		var (
			err   error
			once  sync.Once
			value *Rating
		)
		m.oldValue = func(ctx context.Context) (*Rating, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rating.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRating sets the old Rating of the mutation.
func withRating(node *Rating) ratingOption {
	return func(m *RatingMutation) {
		m.oldValue = func(context.Context) (*Rating, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RatingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RatingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Rating entities.
func (m *RatingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RatingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RatingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rating.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *RatingMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *RatingMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Rating entity.
// If the Rating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RatingMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *RatingMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *RatingMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *RatingMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetReview sets the "review" field.
func (m *RatingMutation) SetReview(s string) {
	m.review = &s
}

// Review returns the value of the "review" field in the mutation.
func (m *RatingMutation) Review() (r string, exists bool) {
	v := m.review
	if v == nil {
		return
	}
	return *v, true
}

// OldReview returns the old "review" field's value of the Rating entity.
// If the Rating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RatingMutation) OldReview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReview: %w", err)
	}
	return oldValue.Review, nil
}

// ClearReview clears the value of the "review" field.
func (m *RatingMutation) ClearReview() {
	m.review = nil
	m.clearedFields[rating.FieldReview] = struct{}{}
}

// ReviewCleared returns if the "review" field was cleared in this mutation.
func (m *RatingMutation) ReviewCleared() bool {
	_, ok := m.clearedFields[rating.FieldReview]
	return ok
}

// ResetReview resets all changes to the "review" field.
func (m *RatingMutation) ResetReview() {
	m.review = nil
	delete(m.clearedFields, rating.FieldReview)
}

// SetRatedAt sets the "ratedAt" field.
func (m *RatingMutation) SetRatedAt(t time.Time) {
	m.ratedAt = &t
}

// RatedAt returns the value of the "ratedAt" field in the mutation.
func (m *RatingMutation) RatedAt() (r time.Time, exists bool) {
	v := m.ratedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldRatedAt returns the old "ratedAt" field's value of the Rating entity.
// If the Rating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RatingMutation) OldRatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatedAt: %w", err)
	}
	return oldValue.RatedAt, nil
}

// ResetRatedAt resets all changes to the "ratedAt" field.
func (m *RatingMutation) ResetRatedAt() {
	m.ratedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RatingMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RatingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RatingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RatingMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RatingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RatingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *RatingMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *RatingMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *RatingMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *RatingMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *RatingMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *RatingMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *RatingMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *RatingMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *RatingMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *RatingMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *RatingMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *RatingMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *RatingMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *RatingMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *RatingMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *RatingMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *RatingMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *RatingMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the RatingMutation builder.
func (m *RatingMutation) Where(ps ...predicate.Rating) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RatingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RatingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rating, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RatingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RatingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rating).
func (m *RatingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RatingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.score != nil {
		fields = append(fields, rating.FieldScore)
	}
	if m.review != nil {
		fields = append(fields, rating.FieldReview)
	}
	if m.ratedAt != nil {
		fields = append(fields, rating.FieldRatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RatingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rating.FieldScore:
		return m.Score()
	case rating.FieldReview:
		return m.Review()
	case rating.FieldRatedAt:
		return m.RatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RatingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rating.FieldScore:
		return m.OldScore(ctx)
	case rating.FieldReview:
		return m.OldReview(ctx)
	case rating.FieldRatedAt:
		return m.OldRatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Rating field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RatingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rating.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case rating.FieldReview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReview(v)
		return nil
	case rating.FieldRatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Rating field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RatingMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, rating.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RatingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rating.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RatingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rating.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown Rating numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RatingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rating.FieldReview) {
		fields = append(fields, rating.FieldReview)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RatingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RatingMutation) ClearField(name string) error {
	switch name {
	case rating.FieldReview:
		m.ClearReview()
		return nil
	}
	return fmt.Errorf("unknown Rating nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RatingMutation) ResetField(name string) error {
	switch name {
	case rating.FieldScore:
		m.ResetScore()
		return nil
	case rating.FieldReview:
		m.ResetReview()
		return nil
	case rating.FieldRatedAt:
		m.ResetRatedAt()
		return nil
	}
	return fmt.Errorf("unknown Rating field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RatingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, rating.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, rating.EdgeBusiness)
	}
	if m.place != nil {
		edges = append(edges, rating.EdgePlace)
	}
	if m.event != nil {
		edges = append(edges, rating.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RatingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rating.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case rating.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case rating.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case rating.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RatingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RatingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RatingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, rating.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, rating.EdgeBusiness)
	}
	if m.clearedplace {
		edges = append(edges, rating.EdgePlace)
	}
	if m.clearedevent {
		edges = append(edges, rating.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RatingMutation) EdgeCleared(name string) bool {
	switch name {
	case rating.EdgeUser:
		return m.cleareduser
	case rating.EdgeBusiness:
		return m.clearedbusiness
	case rating.EdgePlace:
		return m.clearedplace
	case rating.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RatingMutation) ClearEdge(name string) error {
	switch name {
	case rating.EdgeUser:
		m.ClearUser()
		return nil
	case rating.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case rating.EdgePlace:
		m.ClearPlace()
		return nil
	case rating.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Rating unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RatingMutation) ResetEdge(name string) error {
	switch name {
	case rating.EdgeUser:
		m.ResetUser()
		return nil
	case rating.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case rating.EdgePlace:
		m.ResetPlace()
		return nil
	case rating.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Rating edge %s", name)
}

// ReactionMutation represents an operation that mutates the Reaction nodes in the graph.
type ReactionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Reaction, error)
	predicates    []predicate.Reaction
}

var _ ent.Mutation = (*ReactionMutation)(nil)

// reactionOption allows management of the mutation configuration using functional options.
type reactionOption func(*ReactionMutation)

// newReactionMutation creates new mutation for the Reaction entity.
func newReactionMutation(c config, op Op, opts ...reactionOption) *ReactionMutation {
	m := &ReactionMutation{
		config:        c,
		op:            op,
		typ:           TypeReaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReactionID sets the ID field of the mutation.
func withReactionID(id string) reactionOption {
	return func(m *ReactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Reaction
		)
		m.oldValue = func(ctx context.Context) (*Reaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReaction sets the old Reaction of the mutation.
func withReaction(node *Reaction) reactionOption {
	return func(m *ReactionMutation) {
		m.oldValue = func(context.Context) (*Reaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ReactionMutation builder.
func (m *ReactionMutation) Where(ps ...predicate.Reaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reaction).
func (m *ReactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReactionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReactionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Reaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Reaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Reaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Reaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReactionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Reaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Reaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Reaction edge %s", name)
}

// ReservationMutation represents an operation that mutates the Reservation nodes in the graph.
type ReservationMutation struct {
	config
	op            Op
	typ           string
	id            *string
	startDate     *time.Time
	endDate       *time.Time
	status        *string
	clearedFields map[string]struct{}
	place         *string
	clearedplace  bool
	room          *string
	clearedroom   bool
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Reservation, error)
	predicates    []predicate.Reservation
}

var _ ent.Mutation = (*ReservationMutation)(nil)

// reservationOption allows management of the mutation configuration using functional options.
type reservationOption func(*ReservationMutation)

// newReservationMutation creates new mutation for the Reservation entity.
func newReservationMutation(c config, op Op, opts ...reservationOption) *ReservationMutation {
	m := &ReservationMutation{
		config:        c,
		op:            op,
		typ:           TypeReservation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReservationID sets the ID field of the mutation.
func withReservationID(id string) reservationOption {
	return func(m *ReservationMutation) {
		var (
			err   error
			once  sync.Once
			value *Reservation
		)
		m.oldValue = func(ctx context.Context) (*Reservation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reservation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReservation sets the old Reservation of the mutation.
func withReservation(node *Reservation) reservationOption {
	return func(m *ReservationMutation) {
		m.oldValue = func(context.Context) (*Reservation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReservationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReservationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reservation entities.
func (m *ReservationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReservationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReservationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reservation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartDate sets the "startDate" field.
func (m *ReservationMutation) SetStartDate(t time.Time) {
	m.startDate = &t
}

// StartDate returns the value of the "startDate" field in the mutation.
func (m *ReservationMutation) StartDate() (r time.Time, exists bool) {
	v := m.startDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "startDate" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "startDate" field.
func (m *ReservationMutation) ResetStartDate() {
	m.startDate = nil
}

// SetEndDate sets the "endDate" field.
func (m *ReservationMutation) SetEndDate(t time.Time) {
	m.endDate = &t
}

// EndDate returns the value of the "endDate" field in the mutation.
func (m *ReservationMutation) EndDate() (r time.Time, exists bool) {
	v := m.endDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "endDate" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "endDate" field.
func (m *ReservationMutation) ResetEndDate() {
	m.endDate = nil
}

// SetStatus sets the "status" field.
func (m *ReservationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ReservationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReservationMutation) ResetStatus() {
	m.status = nil
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *ReservationMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *ReservationMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *ReservationMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *ReservationMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *ReservationMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *ReservationMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetRoomID sets the "room" edge to the Room entity by id.
func (m *ReservationMutation) SetRoomID(id string) {
	m.room = &id
}

// ClearRoom clears the "room" edge to the Room entity.
func (m *ReservationMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared reports if the "room" edge to the Room entity was cleared.
func (m *ReservationMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the "room" edge ID in the mutation.
func (m *ReservationMutation) RoomID() (id string, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the "room" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *ReservationMutation) RoomIDs() (ids []string) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom resets all changes to the "room" edge.
func (m *ReservationMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ReservationMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReservationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReservationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ReservationMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReservationMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReservationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ReservationMutation builder.
func (m *ReservationMutation) Where(ps ...predicate.Reservation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReservationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReservationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reservation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReservationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReservationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reservation).
func (m *ReservationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReservationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.startDate != nil {
		fields = append(fields, reservation.FieldStartDate)
	}
	if m.endDate != nil {
		fields = append(fields, reservation.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, reservation.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReservationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reservation.FieldStartDate:
		return m.StartDate()
	case reservation.FieldEndDate:
		return m.EndDate()
	case reservation.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReservationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reservation.FieldStartDate:
		return m.OldStartDate(ctx)
	case reservation.FieldEndDate:
		return m.OldEndDate(ctx)
	case reservation.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Reservation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reservation.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case reservation.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case reservation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Reservation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReservationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReservationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Reservation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReservationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReservationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReservationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Reservation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReservationMutation) ResetField(name string) error {
	switch name {
	case reservation.FieldStartDate:
		m.ResetStartDate()
		return nil
	case reservation.FieldEndDate:
		m.ResetEndDate()
		return nil
	case reservation.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Reservation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReservationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.place != nil {
		edges = append(edges, reservation.EdgePlace)
	}
	if m.room != nil {
		edges = append(edges, reservation.EdgeRoom)
	}
	if m.user != nil {
		edges = append(edges, reservation.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReservationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reservation.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case reservation.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case reservation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReservationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReservationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReservationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplace {
		edges = append(edges, reservation.EdgePlace)
	}
	if m.clearedroom {
		edges = append(edges, reservation.EdgeRoom)
	}
	if m.cleareduser {
		edges = append(edges, reservation.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReservationMutation) EdgeCleared(name string) bool {
	switch name {
	case reservation.EdgePlace:
		return m.clearedplace
	case reservation.EdgeRoom:
		return m.clearedroom
	case reservation.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReservationMutation) ClearEdge(name string) error {
	switch name {
	case reservation.EdgePlace:
		m.ClearPlace()
		return nil
	case reservation.EdgeRoom:
		m.ClearRoom()
		return nil
	case reservation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Reservation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReservationMutation) ResetEdge(name string) error {
	switch name {
	case reservation.EdgePlace:
		m.ResetPlace()
		return nil
	case reservation.EdgeRoom:
		m.ResetRoom()
		return nil
	case reservation.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Reservation edge %s", name)
}

// ReservationBlockMutation represents an operation that mutates the ReservationBlock nodes in the graph.
type ReservationBlockMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	start_time             *time.Time
	end_time               *time.Time
	status                 *reservationblock.Status
	clearedFields          map[string]struct{}
	place_inventory        *string
	clearedplace_inventory bool
	user                   *string
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*ReservationBlock, error)
	predicates             []predicate.ReservationBlock
}

var _ ent.Mutation = (*ReservationBlockMutation)(nil)

// reservationblockOption allows management of the mutation configuration using functional options.
type reservationblockOption func(*ReservationBlockMutation)

// newReservationBlockMutation creates new mutation for the ReservationBlock entity.
func newReservationBlockMutation(c config, op Op, opts ...reservationblockOption) *ReservationBlockMutation {
	m := &ReservationBlockMutation{
		config:        c,
		op:            op,
		typ:           TypeReservationBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReservationBlockID sets the ID field of the mutation.
func withReservationBlockID(id string) reservationblockOption {
	return func(m *ReservationBlockMutation) {
		var (
			err   error
			once  sync.Once
			value *ReservationBlock
		)
		m.oldValue = func(ctx context.Context) (*ReservationBlock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReservationBlock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReservationBlock sets the old ReservationBlock of the mutation.
func withReservationBlock(node *ReservationBlock) reservationblockOption {
	return func(m *ReservationBlockMutation) {
		m.oldValue = func(context.Context) (*ReservationBlock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReservationBlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReservationBlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReservationBlockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReservationBlockMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReservationBlock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "start_time" field.
func (m *ReservationBlockMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ReservationBlockMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ReservationBlock entity.
// If the ReservationBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationBlockMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ReservationBlockMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ReservationBlockMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ReservationBlockMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ReservationBlock entity.
// If the ReservationBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationBlockMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ReservationBlockMutation) ResetEndTime() {
	m.end_time = nil
}

// SetStatus sets the "status" field.
func (m *ReservationBlockMutation) SetStatus(r reservationblock.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReservationBlockMutation) Status() (r reservationblock.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ReservationBlock entity.
// If the ReservationBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationBlockMutation) OldStatus(ctx context.Context) (v reservationblock.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReservationBlockMutation) ResetStatus() {
	m.status = nil
}

// SetPlaceInventoryID sets the "place_inventory" edge to the PlaceInventory entity by id.
func (m *ReservationBlockMutation) SetPlaceInventoryID(id string) {
	m.place_inventory = &id
}

// ClearPlaceInventory clears the "place_inventory" edge to the PlaceInventory entity.
func (m *ReservationBlockMutation) ClearPlaceInventory() {
	m.clearedplace_inventory = true
}

// PlaceInventoryCleared reports if the "place_inventory" edge to the PlaceInventory entity was cleared.
func (m *ReservationBlockMutation) PlaceInventoryCleared() bool {
	return m.clearedplace_inventory
}

// PlaceInventoryID returns the "place_inventory" edge ID in the mutation.
func (m *ReservationBlockMutation) PlaceInventoryID() (id string, exists bool) {
	if m.place_inventory != nil {
		return *m.place_inventory, true
	}
	return
}

// PlaceInventoryIDs returns the "place_inventory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceInventoryID instead. It exists only for internal usage by the builders.
func (m *ReservationBlockMutation) PlaceInventoryIDs() (ids []string) {
	if id := m.place_inventory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlaceInventory resets all changes to the "place_inventory" edge.
func (m *ReservationBlockMutation) ResetPlaceInventory() {
	m.place_inventory = nil
	m.clearedplace_inventory = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ReservationBlockMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReservationBlockMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReservationBlockMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ReservationBlockMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReservationBlockMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReservationBlockMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ReservationBlockMutation builder.
func (m *ReservationBlockMutation) Where(ps ...predicate.ReservationBlock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReservationBlockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReservationBlockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReservationBlock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReservationBlockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReservationBlockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReservationBlock).
func (m *ReservationBlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReservationBlockMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.start_time != nil {
		fields = append(fields, reservationblock.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, reservationblock.FieldEndTime)
	}
	if m.status != nil {
		fields = append(fields, reservationblock.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReservationBlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reservationblock.FieldStartTime:
		return m.StartTime()
	case reservationblock.FieldEndTime:
		return m.EndTime()
	case reservationblock.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReservationBlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reservationblock.FieldStartTime:
		return m.OldStartTime(ctx)
	case reservationblock.FieldEndTime:
		return m.OldEndTime(ctx)
	case reservationblock.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ReservationBlock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationBlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reservationblock.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case reservationblock.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case reservationblock.FieldStatus:
		v, ok := value.(reservationblock.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ReservationBlock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReservationBlockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReservationBlockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationBlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReservationBlock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReservationBlockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReservationBlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReservationBlockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReservationBlock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReservationBlockMutation) ResetField(name string) error {
	switch name {
	case reservationblock.FieldStartTime:
		m.ResetStartTime()
		return nil
	case reservationblock.FieldEndTime:
		m.ResetEndTime()
		return nil
	case reservationblock.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ReservationBlock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReservationBlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.place_inventory != nil {
		edges = append(edges, reservationblock.EdgePlaceInventory)
	}
	if m.user != nil {
		edges = append(edges, reservationblock.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReservationBlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reservationblock.EdgePlaceInventory:
		if id := m.place_inventory; id != nil {
			return []ent.Value{*id}
		}
	case reservationblock.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReservationBlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReservationBlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReservationBlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplace_inventory {
		edges = append(edges, reservationblock.EdgePlaceInventory)
	}
	if m.cleareduser {
		edges = append(edges, reservationblock.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReservationBlockMutation) EdgeCleared(name string) bool {
	switch name {
	case reservationblock.EdgePlaceInventory:
		return m.clearedplace_inventory
	case reservationblock.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReservationBlockMutation) ClearEdge(name string) error {
	switch name {
	case reservationblock.EdgePlaceInventory:
		m.ClearPlaceInventory()
		return nil
	case reservationblock.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ReservationBlock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReservationBlockMutation) ResetEdge(name string) error {
	switch name {
	case reservationblock.EdgePlaceInventory:
		m.ResetPlaceInventory()
		return nil
	case reservationblock.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ReservationBlock edge %s", name)
}

// ResourseMutation represents an operation that mutates the Resourse nodes in the graph.
type ResourseMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Resourse, error)
	predicates    []predicate.Resourse
}

var _ ent.Mutation = (*ResourseMutation)(nil)

// resourseOption allows management of the mutation configuration using functional options.
type resourseOption func(*ResourseMutation)

// newResourseMutation creates new mutation for the Resourse entity.
func newResourseMutation(c config, op Op, opts ...resourseOption) *ResourseMutation {
	m := &ResourseMutation{
		config:        c,
		op:            op,
		typ:           TypeResourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourseID sets the ID field of the mutation.
func withResourseID(id string) resourseOption {
	return func(m *ResourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Resourse
		)
		m.oldValue = func(ctx context.Context) (*Resourse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourse sets the old Resourse of the mutation.
func withResourse(node *Resourse) resourseOption {
	return func(m *ResourseMutation) {
		m.oldValue = func(context.Context) (*Resourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resourse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ResourseMutation builder.
func (m *ResourseMutation) Where(ps ...predicate.Resourse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resourse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resourse).
func (m *ResourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourseMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourseMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Resourse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourseMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Resourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resourse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourseMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Resourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Resourse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Resourse edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op              Op
	typ             string
	id              *string
	score           *float64
	addscore        *float64
	content         *string
	createdAt       *time.Time
	likeCount       *int
	addlikeCount    *int
	dislikeCount    *int
	adddislikeCount *int
	flag            *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	place           *string
	clearedplace    bool
	event           *string
	clearedevent    bool
	medias          map[string]struct{}
	removedmedias   map[string]struct{}
	clearedmedias   bool
	comments        map[string]struct{}
	removedcomments map[string]struct{}
	clearedcomments bool
	likes           map[string]struct{}
	removedlikes    map[string]struct{}
	clearedlikes    bool
	done            bool
	oldValue        func(context.Context) (*Review, error)
	predicates      []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id string) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Review entities.
func (m *ReviewMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *ReviewMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ReviewMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ReviewMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ReviewMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *ReviewMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetContent sets the "content" field.
func (m *ReviewMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ReviewMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ReviewMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ReviewMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ReviewMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetLikeCount sets the "likeCount" field.
func (m *ReviewMutation) SetLikeCount(i int) {
	m.likeCount = &i
	m.addlikeCount = nil
}

// LikeCount returns the value of the "likeCount" field in the mutation.
func (m *ReviewMutation) LikeCount() (r int, exists bool) {
	v := m.likeCount
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "likeCount" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "likeCount" field.
func (m *ReviewMutation) AddLikeCount(i int) {
	if m.addlikeCount != nil {
		*m.addlikeCount += i
	} else {
		m.addlikeCount = &i
	}
}

// AddedLikeCount returns the value that was added to the "likeCount" field in this mutation.
func (m *ReviewMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlikeCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "likeCount" field.
func (m *ReviewMutation) ResetLikeCount() {
	m.likeCount = nil
	m.addlikeCount = nil
}

// SetDislikeCount sets the "dislikeCount" field.
func (m *ReviewMutation) SetDislikeCount(i int) {
	m.dislikeCount = &i
	m.adddislikeCount = nil
}

// DislikeCount returns the value of the "dislikeCount" field in the mutation.
func (m *ReviewMutation) DislikeCount() (r int, exists bool) {
	v := m.dislikeCount
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislikeCount" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislikeCount" field.
func (m *ReviewMutation) AddDislikeCount(i int) {
	if m.adddislikeCount != nil {
		*m.adddislikeCount += i
	} else {
		m.adddislikeCount = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislikeCount" field in this mutation.
func (m *ReviewMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislikeCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislikeCount" field.
func (m *ReviewMutation) ResetDislikeCount() {
	m.dislikeCount = nil
	m.adddislikeCount = nil
}

// SetFlag sets the "flag" field.
func (m *ReviewMutation) SetFlag(s string) {
	m.flag = &s
}

// Flag returns the value of the "flag" field in the mutation.
func (m *ReviewMutation) Flag() (r string, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// ResetFlag resets all changes to the "flag" field.
func (m *ReviewMutation) ResetFlag() {
	m.flag = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ReviewMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReviewMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReviewMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ReviewMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReviewMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *ReviewMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *ReviewMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *ReviewMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *ReviewMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *ReviewMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *ReviewMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *ReviewMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *ReviewMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *ReviewMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *ReviewMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *ReviewMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *ReviewMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *ReviewMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *ReviewMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *ReviewMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// AddMediaIDs adds the "medias" edge to the Media entity by ids.
func (m *ReviewMutation) AddMediaIDs(ids ...string) {
	if m.medias == nil {
		m.medias = make(map[string]struct{})
	}
	for i := range ids {
		m.medias[ids[i]] = struct{}{}
	}
}

// ClearMedias clears the "medias" edge to the Media entity.
func (m *ReviewMutation) ClearMedias() {
	m.clearedmedias = true
}

// MediasCleared reports if the "medias" edge to the Media entity was cleared.
func (m *ReviewMutation) MediasCleared() bool {
	return m.clearedmedias
}

// RemoveMediaIDs removes the "medias" edge to the Media entity by IDs.
func (m *ReviewMutation) RemoveMediaIDs(ids ...string) {
	if m.removedmedias == nil {
		m.removedmedias = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.medias, ids[i])
		m.removedmedias[ids[i]] = struct{}{}
	}
}

// RemovedMedias returns the removed IDs of the "medias" edge to the Media entity.
func (m *ReviewMutation) RemovedMediasIDs() (ids []string) {
	for id := range m.removedmedias {
		ids = append(ids, id)
	}
	return
}

// MediasIDs returns the "medias" edge IDs in the mutation.
func (m *ReviewMutation) MediasIDs() (ids []string) {
	for id := range m.medias {
		ids = append(ids, id)
	}
	return
}

// ResetMedias resets all changes to the "medias" edge.
func (m *ReviewMutation) ResetMedias() {
	m.medias = nil
	m.clearedmedias = false
	m.removedmedias = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *ReviewMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *ReviewMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *ReviewMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *ReviewMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *ReviewMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ReviewMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ReviewMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikeIDs adds the "likes" edge to the Like entity by ids.
func (m *ReviewMutation) AddLikeIDs(ids ...string) {
	if m.likes == nil {
		m.likes = make(map[string]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the Like entity.
func (m *ReviewMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the Like entity was cleared.
func (m *ReviewMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the Like entity by IDs.
func (m *ReviewMutation) RemoveLikeIDs(ids ...string) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the Like entity.
func (m *ReviewMutation) RemovedLikesIDs() (ids []string) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *ReviewMutation) LikesIDs() (ids []string) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *ReviewMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Review, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.score != nil {
		fields = append(fields, review.FieldScore)
	}
	if m.content != nil {
		fields = append(fields, review.FieldContent)
	}
	if m.createdAt != nil {
		fields = append(fields, review.FieldCreatedAt)
	}
	if m.likeCount != nil {
		fields = append(fields, review.FieldLikeCount)
	}
	if m.dislikeCount != nil {
		fields = append(fields, review.FieldDislikeCount)
	}
	if m.flag != nil {
		fields = append(fields, review.FieldFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldScore:
		return m.Score()
	case review.FieldContent:
		return m.Content()
	case review.FieldCreatedAt:
		return m.CreatedAt()
	case review.FieldLikeCount:
		return m.LikeCount()
	case review.FieldDislikeCount:
		return m.DislikeCount()
	case review.FieldFlag:
		return m.Flag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldScore:
		return m.OldScore(ctx)
	case review.FieldContent:
		return m.OldContent(ctx)
	case review.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case review.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case review.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case review.FieldFlag:
		return m.OldFlag(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case review.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case review.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case review.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case review.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case review.FieldFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, review.FieldScore)
	}
	if m.addlikeCount != nil {
		fields = append(fields, review.FieldLikeCount)
	}
	if m.adddislikeCount != nil {
		fields = append(fields, review.FieldDislikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldScore:
		return m.AddedScore()
	case review.FieldLikeCount:
		return m.AddedLikeCount()
	case review.FieldDislikeCount:
		return m.AddedDislikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case review.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case review.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldScore:
		m.ResetScore()
		return nil
	case review.FieldContent:
		m.ResetContent()
		return nil
	case review.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case review.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case review.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case review.FieldFlag:
		m.ResetFlag()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.user != nil {
		edges = append(edges, review.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, review.EdgeBusiness)
	}
	if m.place != nil {
		edges = append(edges, review.EdgePlace)
	}
	if m.event != nil {
		edges = append(edges, review.EdgeEvent)
	}
	if m.medias != nil {
		edges = append(edges, review.EdgeMedias)
	}
	if m.comments != nil {
		edges = append(edges, review.EdgeComments)
	}
	if m.likes != nil {
		edges = append(edges, review.EdgeLikes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.medias))
		for id := range m.medias {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmedias != nil {
		edges = append(edges, review.EdgeMedias)
	}
	if m.removedcomments != nil {
		edges = append(edges, review.EdgeComments)
	}
	if m.removedlikes != nil {
		edges = append(edges, review.EdgeLikes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.removedmedias))
		for id := range m.removedmedias {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareduser {
		edges = append(edges, review.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, review.EdgeBusiness)
	}
	if m.clearedplace {
		edges = append(edges, review.EdgePlace)
	}
	if m.clearedevent {
		edges = append(edges, review.EdgeEvent)
	}
	if m.clearedmedias {
		edges = append(edges, review.EdgeMedias)
	}
	if m.clearedcomments {
		edges = append(edges, review.EdgeComments)
	}
	if m.clearedlikes {
		edges = append(edges, review.EdgeLikes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeUser:
		return m.cleareduser
	case review.EdgeBusiness:
		return m.clearedbusiness
	case review.EdgePlace:
		return m.clearedplace
	case review.EdgeEvent:
		return m.clearedevent
	case review.EdgeMedias:
		return m.clearedmedias
	case review.EdgeComments:
		return m.clearedcomments
	case review.EdgeLikes:
		return m.clearedlikes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	case review.EdgeUser:
		m.ClearUser()
		return nil
	case review.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case review.EdgePlace:
		m.ClearPlace()
		return nil
	case review.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeUser:
		m.ResetUser()
		return nil
	case review.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case review.EdgePlace:
		m.ResetPlace()
		return nil
	case review.EdgeEvent:
		m.ResetEvent()
		return nil
	case review.EdgeMedias:
		m.ResetMedias()
		return nil
	case review.EdgeComments:
		m.ResetComments()
		return nil
	case review.EdgeLikes:
		m.ResetLikes()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	name                 *string
	room_number          *int
	addroom_number       *int
	room_type            *string
	room_status          *string
	room_rating          *string
	room_price           *float64
	addroom_price        *float64
	guest_capacity       *string
	qr_code              *string
	status               *room.Status
	extras               *map[string]interface{}
	description          *string
	availability         *bool
	image                *string
	clearedFields        map[string]struct{}
	place                map[string]struct{}
	removedplace         map[string]struct{}
	clearedplace         bool
	room_category        map[string]struct{}
	removedroom_category map[string]struct{}
	clearedroom_category bool
	bookings             map[string]struct{}
	removedbookings      map[string]struct{}
	clearedbookings      bool
	amenities            map[string]struct{}
	removedamenities     map[string]struct{}
	clearedamenities     bool
	media                map[string]struct{}
	removedmedia         map[string]struct{}
	clearedmedia         bool
	reservations         map[string]struct{}
	removedreservations  map[string]struct{}
	clearedreservations  bool
	done                 bool
	oldValue             func(context.Context) (*Room, error)
	predicates           []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id string) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Room entities.
func (m *RoomMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Room.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoomMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *RoomMutation) ClearName() {
	m.name = nil
	m.clearedFields[room.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *RoomMutation) NameCleared() bool {
	_, ok := m.clearedFields[room.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *RoomMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, room.FieldName)
}

// SetRoomNumber sets the "room_number" field.
func (m *RoomMutation) SetRoomNumber(i int) {
	m.room_number = &i
	m.addroom_number = nil
}

// RoomNumber returns the value of the "room_number" field in the mutation.
func (m *RoomMutation) RoomNumber() (r int, exists bool) {
	v := m.room_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomNumber returns the old "room_number" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldRoomNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomNumber: %w", err)
	}
	return oldValue.RoomNumber, nil
}

// AddRoomNumber adds i to the "room_number" field.
func (m *RoomMutation) AddRoomNumber(i int) {
	if m.addroom_number != nil {
		*m.addroom_number += i
	} else {
		m.addroom_number = &i
	}
}

// AddedRoomNumber returns the value that was added to the "room_number" field in this mutation.
func (m *RoomMutation) AddedRoomNumber() (r int, exists bool) {
	v := m.addroom_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoomNumber clears the value of the "room_number" field.
func (m *RoomMutation) ClearRoomNumber() {
	m.room_number = nil
	m.addroom_number = nil
	m.clearedFields[room.FieldRoomNumber] = struct{}{}
}

// RoomNumberCleared returns if the "room_number" field was cleared in this mutation.
func (m *RoomMutation) RoomNumberCleared() bool {
	_, ok := m.clearedFields[room.FieldRoomNumber]
	return ok
}

// ResetRoomNumber resets all changes to the "room_number" field.
func (m *RoomMutation) ResetRoomNumber() {
	m.room_number = nil
	m.addroom_number = nil
	delete(m.clearedFields, room.FieldRoomNumber)
}

// SetRoomType sets the "room_type" field.
func (m *RoomMutation) SetRoomType(s string) {
	m.room_type = &s
}

// RoomType returns the value of the "room_type" field in the mutation.
func (m *RoomMutation) RoomType() (r string, exists bool) {
	v := m.room_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomType returns the old "room_type" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldRoomType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomType: %w", err)
	}
	return oldValue.RoomType, nil
}

// ClearRoomType clears the value of the "room_type" field.
func (m *RoomMutation) ClearRoomType() {
	m.room_type = nil
	m.clearedFields[room.FieldRoomType] = struct{}{}
}

// RoomTypeCleared returns if the "room_type" field was cleared in this mutation.
func (m *RoomMutation) RoomTypeCleared() bool {
	_, ok := m.clearedFields[room.FieldRoomType]
	return ok
}

// ResetRoomType resets all changes to the "room_type" field.
func (m *RoomMutation) ResetRoomType() {
	m.room_type = nil
	delete(m.clearedFields, room.FieldRoomType)
}

// SetRoomStatus sets the "room_status" field.
func (m *RoomMutation) SetRoomStatus(s string) {
	m.room_status = &s
}

// RoomStatus returns the value of the "room_status" field in the mutation.
func (m *RoomMutation) RoomStatus() (r string, exists bool) {
	v := m.room_status
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomStatus returns the old "room_status" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldRoomStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomStatus: %w", err)
	}
	return oldValue.RoomStatus, nil
}

// ClearRoomStatus clears the value of the "room_status" field.
func (m *RoomMutation) ClearRoomStatus() {
	m.room_status = nil
	m.clearedFields[room.FieldRoomStatus] = struct{}{}
}

// RoomStatusCleared returns if the "room_status" field was cleared in this mutation.
func (m *RoomMutation) RoomStatusCleared() bool {
	_, ok := m.clearedFields[room.FieldRoomStatus]
	return ok
}

// ResetRoomStatus resets all changes to the "room_status" field.
func (m *RoomMutation) ResetRoomStatus() {
	m.room_status = nil
	delete(m.clearedFields, room.FieldRoomStatus)
}

// SetRoomRating sets the "room_rating" field.
func (m *RoomMutation) SetRoomRating(s string) {
	m.room_rating = &s
}

// RoomRating returns the value of the "room_rating" field in the mutation.
func (m *RoomMutation) RoomRating() (r string, exists bool) {
	v := m.room_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomRating returns the old "room_rating" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldRoomRating(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomRating: %w", err)
	}
	return oldValue.RoomRating, nil
}

// ClearRoomRating clears the value of the "room_rating" field.
func (m *RoomMutation) ClearRoomRating() {
	m.room_rating = nil
	m.clearedFields[room.FieldRoomRating] = struct{}{}
}

// RoomRatingCleared returns if the "room_rating" field was cleared in this mutation.
func (m *RoomMutation) RoomRatingCleared() bool {
	_, ok := m.clearedFields[room.FieldRoomRating]
	return ok
}

// ResetRoomRating resets all changes to the "room_rating" field.
func (m *RoomMutation) ResetRoomRating() {
	m.room_rating = nil
	delete(m.clearedFields, room.FieldRoomRating)
}

// SetRoomPrice sets the "room_price" field.
func (m *RoomMutation) SetRoomPrice(f float64) {
	m.room_price = &f
	m.addroom_price = nil
}

// RoomPrice returns the value of the "room_price" field in the mutation.
func (m *RoomMutation) RoomPrice() (r float64, exists bool) {
	v := m.room_price
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomPrice returns the old "room_price" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldRoomPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomPrice: %w", err)
	}
	return oldValue.RoomPrice, nil
}

// AddRoomPrice adds f to the "room_price" field.
func (m *RoomMutation) AddRoomPrice(f float64) {
	if m.addroom_price != nil {
		*m.addroom_price += f
	} else {
		m.addroom_price = &f
	}
}

// AddedRoomPrice returns the value that was added to the "room_price" field in this mutation.
func (m *RoomMutation) AddedRoomPrice() (r float64, exists bool) {
	v := m.addroom_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoomPrice clears the value of the "room_price" field.
func (m *RoomMutation) ClearRoomPrice() {
	m.room_price = nil
	m.addroom_price = nil
	m.clearedFields[room.FieldRoomPrice] = struct{}{}
}

// RoomPriceCleared returns if the "room_price" field was cleared in this mutation.
func (m *RoomMutation) RoomPriceCleared() bool {
	_, ok := m.clearedFields[room.FieldRoomPrice]
	return ok
}

// ResetRoomPrice resets all changes to the "room_price" field.
func (m *RoomMutation) ResetRoomPrice() {
	m.room_price = nil
	m.addroom_price = nil
	delete(m.clearedFields, room.FieldRoomPrice)
}

// SetGuestCapacity sets the "guest_capacity" field.
func (m *RoomMutation) SetGuestCapacity(s string) {
	m.guest_capacity = &s
}

// GuestCapacity returns the value of the "guest_capacity" field in the mutation.
func (m *RoomMutation) GuestCapacity() (r string, exists bool) {
	v := m.guest_capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestCapacity returns the old "guest_capacity" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldGuestCapacity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestCapacity: %w", err)
	}
	return oldValue.GuestCapacity, nil
}

// ClearGuestCapacity clears the value of the "guest_capacity" field.
func (m *RoomMutation) ClearGuestCapacity() {
	m.guest_capacity = nil
	m.clearedFields[room.FieldGuestCapacity] = struct{}{}
}

// GuestCapacityCleared returns if the "guest_capacity" field was cleared in this mutation.
func (m *RoomMutation) GuestCapacityCleared() bool {
	_, ok := m.clearedFields[room.FieldGuestCapacity]
	return ok
}

// ResetGuestCapacity resets all changes to the "guest_capacity" field.
func (m *RoomMutation) ResetGuestCapacity() {
	m.guest_capacity = nil
	delete(m.clearedFields, room.FieldGuestCapacity)
}

// SetQrCode sets the "qr_code" field.
func (m *RoomMutation) SetQrCode(s string) {
	m.qr_code = &s
}

// QrCode returns the value of the "qr_code" field in the mutation.
func (m *RoomMutation) QrCode() (r string, exists bool) {
	v := m.qr_code
	if v == nil {
		return
	}
	return *v, true
}

// OldQrCode returns the old "qr_code" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldQrCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrCode: %w", err)
	}
	return oldValue.QrCode, nil
}

// ClearQrCode clears the value of the "qr_code" field.
func (m *RoomMutation) ClearQrCode() {
	m.qr_code = nil
	m.clearedFields[room.FieldQrCode] = struct{}{}
}

// QrCodeCleared returns if the "qr_code" field was cleared in this mutation.
func (m *RoomMutation) QrCodeCleared() bool {
	_, ok := m.clearedFields[room.FieldQrCode]
	return ok
}

// ResetQrCode resets all changes to the "qr_code" field.
func (m *RoomMutation) ResetQrCode() {
	m.qr_code = nil
	delete(m.clearedFields, room.FieldQrCode)
}

// SetStatus sets the "status" field.
func (m *RoomMutation) SetStatus(r room.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RoomMutation) Status() (r room.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldStatus(ctx context.Context) (v room.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RoomMutation) ResetStatus() {
	m.status = nil
}

// SetExtras sets the "extras" field.
func (m *RoomMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *RoomMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *RoomMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[room.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *RoomMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[room.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *RoomMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, room.FieldExtras)
}

// SetDescription sets the "description" field.
func (m *RoomMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoomMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoomMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[room.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoomMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[room.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoomMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, room.FieldDescription)
}

// SetAvailability sets the "availability" field.
func (m *RoomMutation) SetAvailability(b bool) {
	m.availability = &b
}

// Availability returns the value of the "availability" field in the mutation.
func (m *RoomMutation) Availability() (r bool, exists bool) {
	v := m.availability
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailability returns the old "availability" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldAvailability(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailability: %w", err)
	}
	return oldValue.Availability, nil
}

// ResetAvailability resets all changes to the "availability" field.
func (m *RoomMutation) ResetAvailability() {
	m.availability = nil
}

// SetImage sets the "image" field.
func (m *RoomMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *RoomMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *RoomMutation) ClearImage() {
	m.image = nil
	m.clearedFields[room.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *RoomMutation) ImageCleared() bool {
	_, ok := m.clearedFields[room.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *RoomMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, room.FieldImage)
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *RoomMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *RoomMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *RoomMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *RoomMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *RoomMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *RoomMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *RoomMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddRoomCategoryIDs adds the "room_category" edge to the RoomCategory entity by ids.
func (m *RoomMutation) AddRoomCategoryIDs(ids ...string) {
	if m.room_category == nil {
		m.room_category = make(map[string]struct{})
	}
	for i := range ids {
		m.room_category[ids[i]] = struct{}{}
	}
}

// ClearRoomCategory clears the "room_category" edge to the RoomCategory entity.
func (m *RoomMutation) ClearRoomCategory() {
	m.clearedroom_category = true
}

// RoomCategoryCleared reports if the "room_category" edge to the RoomCategory entity was cleared.
func (m *RoomMutation) RoomCategoryCleared() bool {
	return m.clearedroom_category
}

// RemoveRoomCategoryIDs removes the "room_category" edge to the RoomCategory entity by IDs.
func (m *RoomMutation) RemoveRoomCategoryIDs(ids ...string) {
	if m.removedroom_category == nil {
		m.removedroom_category = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.room_category, ids[i])
		m.removedroom_category[ids[i]] = struct{}{}
	}
}

// RemovedRoomCategory returns the removed IDs of the "room_category" edge to the RoomCategory entity.
func (m *RoomMutation) RemovedRoomCategoryIDs() (ids []string) {
	for id := range m.removedroom_category {
		ids = append(ids, id)
	}
	return
}

// RoomCategoryIDs returns the "room_category" edge IDs in the mutation.
func (m *RoomMutation) RoomCategoryIDs() (ids []string) {
	for id := range m.room_category {
		ids = append(ids, id)
	}
	return
}

// ResetRoomCategory resets all changes to the "room_category" edge.
func (m *RoomMutation) ResetRoomCategory() {
	m.room_category = nil
	m.clearedroom_category = false
	m.removedroom_category = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *RoomMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *RoomMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *RoomMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *RoomMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *RoomMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *RoomMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *RoomMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddAmenityIDs adds the "amenities" edge to the Amenity entity by ids.
func (m *RoomMutation) AddAmenityIDs(ids ...string) {
	if m.amenities == nil {
		m.amenities = make(map[string]struct{})
	}
	for i := range ids {
		m.amenities[ids[i]] = struct{}{}
	}
}

// ClearAmenities clears the "amenities" edge to the Amenity entity.
func (m *RoomMutation) ClearAmenities() {
	m.clearedamenities = true
}

// AmenitiesCleared reports if the "amenities" edge to the Amenity entity was cleared.
func (m *RoomMutation) AmenitiesCleared() bool {
	return m.clearedamenities
}

// RemoveAmenityIDs removes the "amenities" edge to the Amenity entity by IDs.
func (m *RoomMutation) RemoveAmenityIDs(ids ...string) {
	if m.removedamenities == nil {
		m.removedamenities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.amenities, ids[i])
		m.removedamenities[ids[i]] = struct{}{}
	}
}

// RemovedAmenities returns the removed IDs of the "amenities" edge to the Amenity entity.
func (m *RoomMutation) RemovedAmenitiesIDs() (ids []string) {
	for id := range m.removedamenities {
		ids = append(ids, id)
	}
	return
}

// AmenitiesIDs returns the "amenities" edge IDs in the mutation.
func (m *RoomMutation) AmenitiesIDs() (ids []string) {
	for id := range m.amenities {
		ids = append(ids, id)
	}
	return
}

// ResetAmenities resets all changes to the "amenities" edge.
func (m *RoomMutation) ResetAmenities() {
	m.amenities = nil
	m.clearedamenities = false
	m.removedamenities = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *RoomMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *RoomMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *RoomMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *RoomMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *RoomMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *RoomMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *RoomMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddReservationIDs adds the "reservations" edge to the Reservation entity by ids.
func (m *RoomMutation) AddReservationIDs(ids ...string) {
	if m.reservations == nil {
		m.reservations = make(map[string]struct{})
	}
	for i := range ids {
		m.reservations[ids[i]] = struct{}{}
	}
}

// ClearReservations clears the "reservations" edge to the Reservation entity.
func (m *RoomMutation) ClearReservations() {
	m.clearedreservations = true
}

// ReservationsCleared reports if the "reservations" edge to the Reservation entity was cleared.
func (m *RoomMutation) ReservationsCleared() bool {
	return m.clearedreservations
}

// RemoveReservationIDs removes the "reservations" edge to the Reservation entity by IDs.
func (m *RoomMutation) RemoveReservationIDs(ids ...string) {
	if m.removedreservations == nil {
		m.removedreservations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reservations, ids[i])
		m.removedreservations[ids[i]] = struct{}{}
	}
}

// RemovedReservations returns the removed IDs of the "reservations" edge to the Reservation entity.
func (m *RoomMutation) RemovedReservationsIDs() (ids []string) {
	for id := range m.removedreservations {
		ids = append(ids, id)
	}
	return
}

// ReservationsIDs returns the "reservations" edge IDs in the mutation.
func (m *RoomMutation) ReservationsIDs() (ids []string) {
	for id := range m.reservations {
		ids = append(ids, id)
	}
	return
}

// ResetReservations resets all changes to the "reservations" edge.
func (m *RoomMutation) ResetReservations() {
	m.reservations = nil
	m.clearedreservations = false
	m.removedreservations = nil
}

// Where appends a list predicates to the RoomMutation builder.
func (m *RoomMutation) Where(ps ...predicate.Room) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Room, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, room.FieldName)
	}
	if m.room_number != nil {
		fields = append(fields, room.FieldRoomNumber)
	}
	if m.room_type != nil {
		fields = append(fields, room.FieldRoomType)
	}
	if m.room_status != nil {
		fields = append(fields, room.FieldRoomStatus)
	}
	if m.room_rating != nil {
		fields = append(fields, room.FieldRoomRating)
	}
	if m.room_price != nil {
		fields = append(fields, room.FieldRoomPrice)
	}
	if m.guest_capacity != nil {
		fields = append(fields, room.FieldGuestCapacity)
	}
	if m.qr_code != nil {
		fields = append(fields, room.FieldQrCode)
	}
	if m.status != nil {
		fields = append(fields, room.FieldStatus)
	}
	if m.extras != nil {
		fields = append(fields, room.FieldExtras)
	}
	if m.description != nil {
		fields = append(fields, room.FieldDescription)
	}
	if m.availability != nil {
		fields = append(fields, room.FieldAvailability)
	}
	if m.image != nil {
		fields = append(fields, room.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldName:
		return m.Name()
	case room.FieldRoomNumber:
		return m.RoomNumber()
	case room.FieldRoomType:
		return m.RoomType()
	case room.FieldRoomStatus:
		return m.RoomStatus()
	case room.FieldRoomRating:
		return m.RoomRating()
	case room.FieldRoomPrice:
		return m.RoomPrice()
	case room.FieldGuestCapacity:
		return m.GuestCapacity()
	case room.FieldQrCode:
		return m.QrCode()
	case room.FieldStatus:
		return m.Status()
	case room.FieldExtras:
		return m.Extras()
	case room.FieldDescription:
		return m.Description()
	case room.FieldAvailability:
		return m.Availability()
	case room.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldName:
		return m.OldName(ctx)
	case room.FieldRoomNumber:
		return m.OldRoomNumber(ctx)
	case room.FieldRoomType:
		return m.OldRoomType(ctx)
	case room.FieldRoomStatus:
		return m.OldRoomStatus(ctx)
	case room.FieldRoomRating:
		return m.OldRoomRating(ctx)
	case room.FieldRoomPrice:
		return m.OldRoomPrice(ctx)
	case room.FieldGuestCapacity:
		return m.OldGuestCapacity(ctx)
	case room.FieldQrCode:
		return m.OldQrCode(ctx)
	case room.FieldStatus:
		return m.OldStatus(ctx)
	case room.FieldExtras:
		return m.OldExtras(ctx)
	case room.FieldDescription:
		return m.OldDescription(ctx)
	case room.FieldAvailability:
		return m.OldAvailability(ctx)
	case room.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case room.FieldRoomNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomNumber(v)
		return nil
	case room.FieldRoomType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomType(v)
		return nil
	case room.FieldRoomStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomStatus(v)
		return nil
	case room.FieldRoomRating:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomRating(v)
		return nil
	case room.FieldRoomPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomPrice(v)
		return nil
	case room.FieldGuestCapacity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestCapacity(v)
		return nil
	case room.FieldQrCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrCode(v)
		return nil
	case room.FieldStatus:
		v, ok := value.(room.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case room.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case room.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case room.FieldAvailability:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailability(v)
		return nil
	case room.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	var fields []string
	if m.addroom_number != nil {
		fields = append(fields, room.FieldRoomNumber)
	}
	if m.addroom_price != nil {
		fields = append(fields, room.FieldRoomPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRoomNumber:
		return m.AddedRoomNumber()
	case room.FieldRoomPrice:
		return m.AddedRoomPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case room.FieldRoomNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoomNumber(v)
		return nil
	case room.FieldRoomPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoomPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(room.FieldName) {
		fields = append(fields, room.FieldName)
	}
	if m.FieldCleared(room.FieldRoomNumber) {
		fields = append(fields, room.FieldRoomNumber)
	}
	if m.FieldCleared(room.FieldRoomType) {
		fields = append(fields, room.FieldRoomType)
	}
	if m.FieldCleared(room.FieldRoomStatus) {
		fields = append(fields, room.FieldRoomStatus)
	}
	if m.FieldCleared(room.FieldRoomRating) {
		fields = append(fields, room.FieldRoomRating)
	}
	if m.FieldCleared(room.FieldRoomPrice) {
		fields = append(fields, room.FieldRoomPrice)
	}
	if m.FieldCleared(room.FieldGuestCapacity) {
		fields = append(fields, room.FieldGuestCapacity)
	}
	if m.FieldCleared(room.FieldQrCode) {
		fields = append(fields, room.FieldQrCode)
	}
	if m.FieldCleared(room.FieldExtras) {
		fields = append(fields, room.FieldExtras)
	}
	if m.FieldCleared(room.FieldDescription) {
		fields = append(fields, room.FieldDescription)
	}
	if m.FieldCleared(room.FieldImage) {
		fields = append(fields, room.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	switch name {
	case room.FieldName:
		m.ClearName()
		return nil
	case room.FieldRoomNumber:
		m.ClearRoomNumber()
		return nil
	case room.FieldRoomType:
		m.ClearRoomType()
		return nil
	case room.FieldRoomStatus:
		m.ClearRoomStatus()
		return nil
	case room.FieldRoomRating:
		m.ClearRoomRating()
		return nil
	case room.FieldRoomPrice:
		m.ClearRoomPrice()
		return nil
	case room.FieldGuestCapacity:
		m.ClearGuestCapacity()
		return nil
	case room.FieldQrCode:
		m.ClearQrCode()
		return nil
	case room.FieldExtras:
		m.ClearExtras()
		return nil
	case room.FieldDescription:
		m.ClearDescription()
		return nil
	case room.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldName:
		m.ResetName()
		return nil
	case room.FieldRoomNumber:
		m.ResetRoomNumber()
		return nil
	case room.FieldRoomType:
		m.ResetRoomType()
		return nil
	case room.FieldRoomStatus:
		m.ResetRoomStatus()
		return nil
	case room.FieldRoomRating:
		m.ResetRoomRating()
		return nil
	case room.FieldRoomPrice:
		m.ResetRoomPrice()
		return nil
	case room.FieldGuestCapacity:
		m.ResetGuestCapacity()
		return nil
	case room.FieldQrCode:
		m.ResetQrCode()
		return nil
	case room.FieldStatus:
		m.ResetStatus()
		return nil
	case room.FieldExtras:
		m.ResetExtras()
		return nil
	case room.FieldDescription:
		m.ResetDescription()
		return nil
	case room.FieldAvailability:
		m.ResetAvailability()
		return nil
	case room.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.place != nil {
		edges = append(edges, room.EdgePlace)
	}
	if m.room_category != nil {
		edges = append(edges, room.EdgeRoomCategory)
	}
	if m.bookings != nil {
		edges = append(edges, room.EdgeBookings)
	}
	if m.amenities != nil {
		edges = append(edges, room.EdgeAmenities)
	}
	if m.media != nil {
		edges = append(edges, room.EdgeMedia)
	}
	if m.reservations != nil {
		edges = append(edges, room.EdgeReservations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeRoomCategory:
		ids := make([]ent.Value, 0, len(m.room_category))
		for id := range m.room_category {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.amenities))
		for id := range m.amenities {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.reservations))
		for id := range m.reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedplace != nil {
		edges = append(edges, room.EdgePlace)
	}
	if m.removedroom_category != nil {
		edges = append(edges, room.EdgeRoomCategory)
	}
	if m.removedbookings != nil {
		edges = append(edges, room.EdgeBookings)
	}
	if m.removedamenities != nil {
		edges = append(edges, room.EdgeAmenities)
	}
	if m.removedmedia != nil {
		edges = append(edges, room.EdgeMedia)
	}
	if m.removedreservations != nil {
		edges = append(edges, room.EdgeReservations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeRoomCategory:
		ids := make([]ent.Value, 0, len(m.removedroom_category))
		for id := range m.removedroom_category {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.removedamenities))
		for id := range m.removedamenities {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case room.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.removedreservations))
		for id := range m.removedreservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedplace {
		edges = append(edges, room.EdgePlace)
	}
	if m.clearedroom_category {
		edges = append(edges, room.EdgeRoomCategory)
	}
	if m.clearedbookings {
		edges = append(edges, room.EdgeBookings)
	}
	if m.clearedamenities {
		edges = append(edges, room.EdgeAmenities)
	}
	if m.clearedmedia {
		edges = append(edges, room.EdgeMedia)
	}
	if m.clearedreservations {
		edges = append(edges, room.EdgeReservations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgePlace:
		return m.clearedplace
	case room.EdgeRoomCategory:
		return m.clearedroom_category
	case room.EdgeBookings:
		return m.clearedbookings
	case room.EdgeAmenities:
		return m.clearedamenities
	case room.EdgeMedia:
		return m.clearedmedia
	case room.EdgeReservations:
		return m.clearedreservations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgePlace:
		m.ResetPlace()
		return nil
	case room.EdgeRoomCategory:
		m.ResetRoomCategory()
		return nil
	case room.EdgeBookings:
		m.ResetBookings()
		return nil
	case room.EdgeAmenities:
		m.ResetAmenities()
		return nil
	case room.EdgeMedia:
		m.ResetMedia()
		return nil
	case room.EdgeReservations:
		m.ResetReservations()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// RoomCategoryMutation represents an operation that mutates the RoomCategory nodes in the graph.
type RoomCategoryMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	description      *string
	price            *string
	clearedFields    map[string]struct{}
	place            map[string]struct{}
	removedplace     map[string]struct{}
	clearedplace     bool
	rooms            map[string]struct{}
	removedrooms     map[string]struct{}
	clearedrooms     bool
	media            map[string]struct{}
	removedmedia     map[string]struct{}
	clearedmedia     bool
	amenities        map[string]struct{}
	removedamenities map[string]struct{}
	clearedamenities bool
	done             bool
	oldValue         func(context.Context) (*RoomCategory, error)
	predicates       []predicate.RoomCategory
}

var _ ent.Mutation = (*RoomCategoryMutation)(nil)

// roomcategoryOption allows management of the mutation configuration using functional options.
type roomcategoryOption func(*RoomCategoryMutation)

// newRoomCategoryMutation creates new mutation for the RoomCategory entity.
func newRoomCategoryMutation(c config, op Op, opts ...roomcategoryOption) *RoomCategoryMutation {
	m := &RoomCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomCategoryID sets the ID field of the mutation.
func withRoomCategoryID(id string) roomcategoryOption {
	return func(m *RoomCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RoomCategory
		)
		m.oldValue = func(ctx context.Context) (*RoomCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoomCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomCategory sets the old RoomCategory of the mutation.
func withRoomCategory(node *RoomCategory) roomcategoryOption {
	return func(m *RoomCategoryMutation) {
		m.oldValue = func(context.Context) (*RoomCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoomCategory entities.
func (m *RoomCategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomCategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomCategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoomCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoomCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RoomCategory entity.
// If the RoomCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoomCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoomCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoomCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RoomCategory entity.
// If the RoomCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoomCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[roomcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoomCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[roomcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoomCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, roomcategory.FieldDescription)
}

// SetPrice sets the "price" field.
func (m *RoomCategoryMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *RoomCategoryMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the RoomCategory entity.
// If the RoomCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomCategoryMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *RoomCategoryMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[roomcategory.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *RoomCategoryMutation) PriceCleared() bool {
	_, ok := m.clearedFields[roomcategory.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *RoomCategoryMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, roomcategory.FieldPrice)
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *RoomCategoryMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *RoomCategoryMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *RoomCategoryMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *RoomCategoryMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *RoomCategoryMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *RoomCategoryMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *RoomCategoryMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddRoomIDs adds the "rooms" edge to the Room entity by ids.
func (m *RoomCategoryMutation) AddRoomIDs(ids ...string) {
	if m.rooms == nil {
		m.rooms = make(map[string]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// ClearRooms clears the "rooms" edge to the Room entity.
func (m *RoomCategoryMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared reports if the "rooms" edge to the Room entity was cleared.
func (m *RoomCategoryMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RemoveRoomIDs removes the "rooms" edge to the Room entity by IDs.
func (m *RoomCategoryMutation) RemoveRoomIDs(ids ...string) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rooms, ids[i])
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed IDs of the "rooms" edge to the Room entity.
func (m *RoomCategoryMutation) RemovedRoomsIDs() (ids []string) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the "rooms" edge IDs in the mutation.
func (m *RoomCategoryMutation) RoomsIDs() (ids []string) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms resets all changes to the "rooms" edge.
func (m *RoomCategoryMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
	m.removedrooms = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *RoomCategoryMutation) AddMediumIDs(ids ...string) {
	if m.media == nil {
		m.media = make(map[string]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *RoomCategoryMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *RoomCategoryMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *RoomCategoryMutation) RemoveMediumIDs(ids ...string) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *RoomCategoryMutation) RemovedMediaIDs() (ids []string) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *RoomCategoryMutation) MediaIDs() (ids []string) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *RoomCategoryMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddAmenityIDs adds the "amenities" edge to the Amenity entity by ids.
func (m *RoomCategoryMutation) AddAmenityIDs(ids ...string) {
	if m.amenities == nil {
		m.amenities = make(map[string]struct{})
	}
	for i := range ids {
		m.amenities[ids[i]] = struct{}{}
	}
}

// ClearAmenities clears the "amenities" edge to the Amenity entity.
func (m *RoomCategoryMutation) ClearAmenities() {
	m.clearedamenities = true
}

// AmenitiesCleared reports if the "amenities" edge to the Amenity entity was cleared.
func (m *RoomCategoryMutation) AmenitiesCleared() bool {
	return m.clearedamenities
}

// RemoveAmenityIDs removes the "amenities" edge to the Amenity entity by IDs.
func (m *RoomCategoryMutation) RemoveAmenityIDs(ids ...string) {
	if m.removedamenities == nil {
		m.removedamenities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.amenities, ids[i])
		m.removedamenities[ids[i]] = struct{}{}
	}
}

// RemovedAmenities returns the removed IDs of the "amenities" edge to the Amenity entity.
func (m *RoomCategoryMutation) RemovedAmenitiesIDs() (ids []string) {
	for id := range m.removedamenities {
		ids = append(ids, id)
	}
	return
}

// AmenitiesIDs returns the "amenities" edge IDs in the mutation.
func (m *RoomCategoryMutation) AmenitiesIDs() (ids []string) {
	for id := range m.amenities {
		ids = append(ids, id)
	}
	return
}

// ResetAmenities resets all changes to the "amenities" edge.
func (m *RoomCategoryMutation) ResetAmenities() {
	m.amenities = nil
	m.clearedamenities = false
	m.removedamenities = nil
}

// Where appends a list predicates to the RoomCategoryMutation builder.
func (m *RoomCategoryMutation) Where(ps ...predicate.RoomCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoomCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoomCategory).
func (m *RoomCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, roomcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, roomcategory.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, roomcategory.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomcategory.FieldName:
		return m.Name()
	case roomcategory.FieldDescription:
		return m.Description()
	case roomcategory.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomcategory.FieldName:
		return m.OldName(ctx)
	case roomcategory.FieldDescription:
		return m.OldDescription(ctx)
	case roomcategory.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown RoomCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case roomcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case roomcategory.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown RoomCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoomCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(roomcategory.FieldDescription) {
		fields = append(fields, roomcategory.FieldDescription)
	}
	if m.FieldCleared(roomcategory.FieldPrice) {
		fields = append(fields, roomcategory.FieldPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomCategoryMutation) ClearField(name string) error {
	switch name {
	case roomcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case roomcategory.FieldPrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown RoomCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomCategoryMutation) ResetField(name string) error {
	switch name {
	case roomcategory.FieldName:
		m.ResetName()
		return nil
	case roomcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case roomcategory.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown RoomCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.place != nil {
		edges = append(edges, roomcategory.EdgePlace)
	}
	if m.rooms != nil {
		edges = append(edges, roomcategory.EdgeRooms)
	}
	if m.media != nil {
		edges = append(edges, roomcategory.EdgeMedia)
	}
	if m.amenities != nil {
		edges = append(edges, roomcategory.EdgeAmenities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomcategory.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case roomcategory.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	case roomcategory.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case roomcategory.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.amenities))
		for id := range m.amenities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedplace != nil {
		edges = append(edges, roomcategory.EdgePlace)
	}
	if m.removedrooms != nil {
		edges = append(edges, roomcategory.EdgeRooms)
	}
	if m.removedmedia != nil {
		edges = append(edges, roomcategory.EdgeMedia)
	}
	if m.removedamenities != nil {
		edges = append(edges, roomcategory.EdgeAmenities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roomcategory.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case roomcategory.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	case roomcategory.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case roomcategory.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.removedamenities))
		for id := range m.removedamenities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedplace {
		edges = append(edges, roomcategory.EdgePlace)
	}
	if m.clearedrooms {
		edges = append(edges, roomcategory.EdgeRooms)
	}
	if m.clearedmedia {
		edges = append(edges, roomcategory.EdgeMedia)
	}
	if m.clearedamenities {
		edges = append(edges, roomcategory.EdgeAmenities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case roomcategory.EdgePlace:
		return m.clearedplace
	case roomcategory.EdgeRooms:
		return m.clearedrooms
	case roomcategory.EdgeMedia:
		return m.clearedmedia
	case roomcategory.EdgeAmenities:
		return m.clearedamenities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RoomCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomCategoryMutation) ResetEdge(name string) error {
	switch name {
	case roomcategory.EdgePlace:
		m.ResetPlace()
		return nil
	case roomcategory.EdgeRooms:
		m.ResetRooms()
		return nil
	case roomcategory.EdgeMedia:
		m.ResetMedia()
		return nil
	case roomcategory.EdgeAmenities:
		m.ResetAmenities()
		return nil
	}
	return fmt.Errorf("unknown RoomCategory edge %s", name)
}

// StaffMutation represents an operation that mutates the Staff nodes in the graph.
type StaffMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	position           *string
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	place              map[string]struct{}
	removedplace       map[string]struct{}
	clearedplace       bool
	permissions        map[string]struct{}
	removedpermissions map[string]struct{}
	clearedpermissions bool
	business           map[string]struct{}
	removedbusiness    map[string]struct{}
	clearedbusiness    bool
	done               bool
	oldValue           func(context.Context) (*Staff, error)
	predicates         []predicate.Staff
}

var _ ent.Mutation = (*StaffMutation)(nil)

// staffOption allows management of the mutation configuration using functional options.
type staffOption func(*StaffMutation)

// newStaffMutation creates new mutation for the Staff entity.
func newStaffMutation(c config, op Op, opts ...staffOption) *StaffMutation {
	m := &StaffMutation{
		config:        c,
		op:            op,
		typ:           TypeStaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffID sets the ID field of the mutation.
func withStaffID(id string) staffOption {
	return func(m *StaffMutation) {
		var (
			err   error
			once  sync.Once
			value *Staff
		)
		m.oldValue = func(ctx context.Context) (*Staff, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaff sets the old Staff of the mutation.
func withStaff(node *Staff) staffOption {
	return func(m *StaffMutation) {
		m.oldValue = func(context.Context) (*Staff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Staff entities.
func (m *StaffMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Staff.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPosition sets the "position" field.
func (m *StaffMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *StaffMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *StaffMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[staff.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *StaffMutation) PositionCleared() bool {
	_, ok := m.clearedFields[staff.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *StaffMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, staff.FieldPosition)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StaffMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StaffMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StaffMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StaffMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StaffMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StaffMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *StaffMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *StaffMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *StaffMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *StaffMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *StaffMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *StaffMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *StaffMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *StaffMutation) AddPermissionIDs(ids ...string) {
	if m.permissions == nil {
		m.permissions = make(map[string]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *StaffMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *StaffMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *StaffMutation) RemovePermissionIDs(ids ...string) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *StaffMutation) RemovedPermissionsIDs() (ids []string) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *StaffMutation) PermissionsIDs() (ids []string) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *StaffMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddBusinesIDs adds the "business" edge to the Business entity by ids.
func (m *StaffMutation) AddBusinesIDs(ids ...string) {
	if m.business == nil {
		m.business = make(map[string]struct{})
	}
	for i := range ids {
		m.business[ids[i]] = struct{}{}
	}
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *StaffMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *StaffMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// RemoveBusinesIDs removes the "business" edge to the Business entity by IDs.
func (m *StaffMutation) RemoveBusinesIDs(ids ...string) {
	if m.removedbusiness == nil {
		m.removedbusiness = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.business, ids[i])
		m.removedbusiness[ids[i]] = struct{}{}
	}
}

// RemovedBusiness returns the removed IDs of the "business" edge to the Business entity.
func (m *StaffMutation) RemovedBusinessIDs() (ids []string) {
	for id := range m.removedbusiness {
		ids = append(ids, id)
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
func (m *StaffMutation) BusinessIDs() (ids []string) {
	for id := range m.business {
		ids = append(ids, id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *StaffMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
	m.removedbusiness = nil
}

// Where appends a list predicates to the StaffMutation builder.
func (m *StaffMutation) Where(ps ...predicate.Staff) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StaffMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StaffMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Staff, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StaffMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StaffMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Staff).
func (m *StaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.position != nil {
		fields = append(fields, staff.FieldPosition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staff.FieldPosition:
		return m.Position()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staff.FieldPosition:
		return m.OldPosition(ctx)
	}
	return nil, fmt.Errorf("unknown Staff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staff.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(staff.FieldPosition) {
		fields = append(fields, staff.FieldPosition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffMutation) ClearField(name string) error {
	switch name {
	case staff.FieldPosition:
		m.ClearPosition()
		return nil
	}
	return fmt.Errorf("unknown Staff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffMutation) ResetField(name string) error {
	switch name {
	case staff.FieldPosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, staff.EdgeUser)
	}
	if m.place != nil {
		edges = append(edges, staff.EdgePlace)
	}
	if m.permissions != nil {
		edges = append(edges, staff.EdgePermissions)
	}
	if m.business != nil {
		edges = append(edges, staff.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case staff.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	case staff.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case staff.EdgeBusiness:
		ids := make([]ent.Value, 0, len(m.business))
		for id := range m.business {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedplace != nil {
		edges = append(edges, staff.EdgePlace)
	}
	if m.removedpermissions != nil {
		edges = append(edges, staff.EdgePermissions)
	}
	if m.removedbusiness != nil {
		edges = append(edges, staff.EdgeBusiness)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	case staff.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case staff.EdgeBusiness:
		ids := make([]ent.Value, 0, len(m.removedbusiness))
		for id := range m.removedbusiness {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, staff.EdgeUser)
	}
	if m.clearedplace {
		edges = append(edges, staff.EdgePlace)
	}
	if m.clearedpermissions {
		edges = append(edges, staff.EdgePermissions)
	}
	if m.clearedbusiness {
		edges = append(edges, staff.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffMutation) EdgeCleared(name string) bool {
	switch name {
	case staff.EdgeUser:
		return m.cleareduser
	case staff.EdgePlace:
		return m.clearedplace
	case staff.EdgePermissions:
		return m.clearedpermissions
	case staff.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffMutation) ClearEdge(name string) error {
	switch name {
	case staff.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Staff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffMutation) ResetEdge(name string) error {
	switch name {
	case staff.EdgeUser:
		m.ResetUser()
		return nil
	case staff.EdgePlace:
		m.ResetPlace()
		return nil
	case staff.EdgePermissions:
		m.ResetPermissions()
		return nil
	case staff.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown Staff edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	start_date                  *time.Time
	end_date                    *time.Time
	flutterwave_subscription_id *string
	clearedFields               map[string]struct{}
	user                        *string
	cleareduser                 bool
	plan                        *string
	clearedplan                 bool
	price                       *string
	clearedprice                bool
	done                        bool
	oldValue                    func(context.Context) (*Subscription, error)
	predicates                  []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id string) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartDate sets the "start_date" field.
func (m *SubscriptionMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *SubscriptionMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *SubscriptionMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *SubscriptionMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *SubscriptionMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *SubscriptionMutation) ResetEndDate() {
	m.end_date = nil
}

// SetFlutterwaveSubscriptionID sets the "flutterwave_subscription_id" field.
func (m *SubscriptionMutation) SetFlutterwaveSubscriptionID(s string) {
	m.flutterwave_subscription_id = &s
}

// FlutterwaveSubscriptionID returns the value of the "flutterwave_subscription_id" field in the mutation.
func (m *SubscriptionMutation) FlutterwaveSubscriptionID() (r string, exists bool) {
	v := m.flutterwave_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlutterwaveSubscriptionID returns the old "flutterwave_subscription_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldFlutterwaveSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlutterwaveSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlutterwaveSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlutterwaveSubscriptionID: %w", err)
	}
	return oldValue.FlutterwaveSubscriptionID, nil
}

// ClearFlutterwaveSubscriptionID clears the value of the "flutterwave_subscription_id" field.
func (m *SubscriptionMutation) ClearFlutterwaveSubscriptionID() {
	m.flutterwave_subscription_id = nil
	m.clearedFields[subscription.FieldFlutterwaveSubscriptionID] = struct{}{}
}

// FlutterwaveSubscriptionIDCleared returns if the "flutterwave_subscription_id" field was cleared in this mutation.
func (m *SubscriptionMutation) FlutterwaveSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldFlutterwaveSubscriptionID]
	return ok
}

// ResetFlutterwaveSubscriptionID resets all changes to the "flutterwave_subscription_id" field.
func (m *SubscriptionMutation) ResetFlutterwaveSubscriptionID() {
	m.flutterwave_subscription_id = nil
	delete(m.clearedFields, subscription.FieldFlutterwaveSubscriptionID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SubscriptionMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubscriptionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SubscriptionMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPlanID sets the "plan" edge to the Plan entity by id.
func (m *SubscriptionMutation) SetPlanID(id string) {
	m.plan = &id
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *SubscriptionMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *SubscriptionMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanID returns the "plan" edge ID in the mutation.
func (m *SubscriptionMutation) PlanID() (id string, exists bool) {
	if m.plan != nil {
		return *m.plan, true
	}
	return
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *SubscriptionMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// SetPriceID sets the "price" edge to the Price entity by id.
func (m *SubscriptionMutation) SetPriceID(id string) {
	m.price = &id
}

// ClearPrice clears the "price" edge to the Price entity.
func (m *SubscriptionMutation) ClearPrice() {
	m.clearedprice = true
}

// PriceCleared reports if the "price" edge to the Price entity was cleared.
func (m *SubscriptionMutation) PriceCleared() bool {
	return m.clearedprice
}

// PriceID returns the "price" edge ID in the mutation.
func (m *SubscriptionMutation) PriceID() (id string, exists bool) {
	if m.price != nil {
		return *m.price, true
	}
	return
}

// PriceIDs returns the "price" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PriceID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) PriceIDs() (ids []string) {
	if id := m.price; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrice resets all changes to the "price" edge.
func (m *SubscriptionMutation) ResetPrice() {
	m.price = nil
	m.clearedprice = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.start_date != nil {
		fields = append(fields, subscription.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, subscription.FieldEndDate)
	}
	if m.flutterwave_subscription_id != nil {
		fields = append(fields, subscription.FieldFlutterwaveSubscriptionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldStartDate:
		return m.StartDate()
	case subscription.FieldEndDate:
		return m.EndDate()
	case subscription.FieldFlutterwaveSubscriptionID:
		return m.FlutterwaveSubscriptionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldStartDate:
		return m.OldStartDate(ctx)
	case subscription.FieldEndDate:
		return m.OldEndDate(ctx)
	case subscription.FieldFlutterwaveSubscriptionID:
		return m.OldFlutterwaveSubscriptionID(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case subscription.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case subscription.FieldFlutterwaveSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlutterwaveSubscriptionID(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldFlutterwaveSubscriptionID) {
		fields = append(fields, subscription.FieldFlutterwaveSubscriptionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldFlutterwaveSubscriptionID:
		m.ClearFlutterwaveSubscriptionID()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldStartDate:
		m.ResetStartDate()
		return nil
	case subscription.FieldEndDate:
		m.ResetEndDate()
		return nil
	case subscription.FieldFlutterwaveSubscriptionID:
		m.ResetFlutterwaveSubscriptionID()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.plan != nil {
		edges = append(edges, subscription.EdgePlan)
	}
	if m.price != nil {
		edges = append(edges, subscription.EdgePrice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgePrice:
		if id := m.price; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.clearedplan {
		edges = append(edges, subscription.EdgePlan)
	}
	if m.clearedprice {
		edges = append(edges, subscription.EdgePrice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeUser:
		return m.cleareduser
	case subscription.EdgePlan:
		return m.clearedplan
	case subscription.EdgePrice:
		return m.clearedprice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ClearUser()
		return nil
	case subscription.EdgePlan:
		m.ClearPlan()
		return nil
	case subscription.EdgePrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ResetUser()
		return nil
	case subscription.EdgePlan:
		m.ResetPlan()
		return nil
	case subscription.EdgePrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	defaultHTML     *string
	defaultCSS      *string
	clearedFields   map[string]struct{}
	websites        map[string]struct{}
	removedwebsites map[string]struct{}
	clearedwebsites bool
	done            bool
	oldValue        func(context.Context) (*Template, error)
	predicates      []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id string) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetDefaultHTML sets the "defaultHTML" field.
func (m *TemplateMutation) SetDefaultHTML(s string) {
	m.defaultHTML = &s
}

// DefaultHTML returns the value of the "defaultHTML" field in the mutation.
func (m *TemplateMutation) DefaultHTML() (r string, exists bool) {
	v := m.defaultHTML
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultHTML returns the old "defaultHTML" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDefaultHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultHTML: %w", err)
	}
	return oldValue.DefaultHTML, nil
}

// ResetDefaultHTML resets all changes to the "defaultHTML" field.
func (m *TemplateMutation) ResetDefaultHTML() {
	m.defaultHTML = nil
}

// SetDefaultCSS sets the "defaultCSS" field.
func (m *TemplateMutation) SetDefaultCSS(s string) {
	m.defaultCSS = &s
}

// DefaultCSS returns the value of the "defaultCSS" field in the mutation.
func (m *TemplateMutation) DefaultCSS() (r string, exists bool) {
	v := m.defaultCSS
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultCSS returns the old "defaultCSS" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDefaultCSS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultCSS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultCSS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultCSS: %w", err)
	}
	return oldValue.DefaultCSS, nil
}

// ResetDefaultCSS resets all changes to the "defaultCSS" field.
func (m *TemplateMutation) ResetDefaultCSS() {
	m.defaultCSS = nil
}

// AddWebsiteIDs adds the "websites" edge to the Website entity by ids.
func (m *TemplateMutation) AddWebsiteIDs(ids ...string) {
	if m.websites == nil {
		m.websites = make(map[string]struct{})
	}
	for i := range ids {
		m.websites[ids[i]] = struct{}{}
	}
}

// ClearWebsites clears the "websites" edge to the Website entity.
func (m *TemplateMutation) ClearWebsites() {
	m.clearedwebsites = true
}

// WebsitesCleared reports if the "websites" edge to the Website entity was cleared.
func (m *TemplateMutation) WebsitesCleared() bool {
	return m.clearedwebsites
}

// RemoveWebsiteIDs removes the "websites" edge to the Website entity by IDs.
func (m *TemplateMutation) RemoveWebsiteIDs(ids ...string) {
	if m.removedwebsites == nil {
		m.removedwebsites = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.websites, ids[i])
		m.removedwebsites[ids[i]] = struct{}{}
	}
}

// RemovedWebsites returns the removed IDs of the "websites" edge to the Website entity.
func (m *TemplateMutation) RemovedWebsitesIDs() (ids []string) {
	for id := range m.removedwebsites {
		ids = append(ids, id)
	}
	return
}

// WebsitesIDs returns the "websites" edge IDs in the mutation.
func (m *TemplateMutation) WebsitesIDs() (ids []string) {
	for id := range m.websites {
		ids = append(ids, id)
	}
	return
}

// ResetWebsites resets all changes to the "websites" edge.
func (m *TemplateMutation) ResetWebsites() {
	m.websites = nil
	m.clearedwebsites = false
	m.removedwebsites = nil
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.defaultHTML != nil {
		fields = append(fields, template.FieldDefaultHTML)
	}
	if m.defaultCSS != nil {
		fields = append(fields, template.FieldDefaultCSS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldName:
		return m.Name()
	case template.FieldDefaultHTML:
		return m.DefaultHTML()
	case template.FieldDefaultCSS:
		return m.DefaultCSS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldDefaultHTML:
		return m.OldDefaultHTML(ctx)
	case template.FieldDefaultCSS:
		return m.OldDefaultCSS(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldDefaultHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultHTML(v)
		return nil
	case template.FieldDefaultCSS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultCSS(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldDefaultHTML:
		m.ResetDefaultHTML()
		return nil
	case template.FieldDefaultCSS:
		m.ResetDefaultCSS()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.websites != nil {
		edges = append(edges, template.EdgeWebsites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeWebsites:
		ids := make([]ent.Value, 0, len(m.websites))
		for id := range m.websites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedwebsites != nil {
		edges = append(edges, template.EdgeWebsites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeWebsites:
		ids := make([]ent.Value, 0, len(m.removedwebsites))
		for id := range m.removedwebsites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwebsites {
		edges = append(edges, template.EdgeWebsites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeWebsites:
		return m.clearedwebsites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeWebsites:
		m.ResetWebsites()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	createdAt             *time.Time
	updatedAt             *time.Time
	clearedFields         map[string]struct{}
	event                 *string
	clearedevent          bool
	ticket_options        map[string]struct{}
	removedticket_options map[string]struct{}
	clearedticket_options bool
	done                  bool
	oldValue              func(context.Context) (*Ticket, error)
	predicates            []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id string) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ticket entities.
func (m *TicketMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *TicketMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *TicketMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *TicketMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *TicketMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *TicketMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// AddTicketOptionIDs adds the "ticket_options" edge to the TicketOption entity by ids.
func (m *TicketMutation) AddTicketOptionIDs(ids ...string) {
	if m.ticket_options == nil {
		m.ticket_options = make(map[string]struct{})
	}
	for i := range ids {
		m.ticket_options[ids[i]] = struct{}{}
	}
}

// ClearTicketOptions clears the "ticket_options" edge to the TicketOption entity.
func (m *TicketMutation) ClearTicketOptions() {
	m.clearedticket_options = true
}

// TicketOptionsCleared reports if the "ticket_options" edge to the TicketOption entity was cleared.
func (m *TicketMutation) TicketOptionsCleared() bool {
	return m.clearedticket_options
}

// RemoveTicketOptionIDs removes the "ticket_options" edge to the TicketOption entity by IDs.
func (m *TicketMutation) RemoveTicketOptionIDs(ids ...string) {
	if m.removedticket_options == nil {
		m.removedticket_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ticket_options, ids[i])
		m.removedticket_options[ids[i]] = struct{}{}
	}
}

// RemovedTicketOptions returns the removed IDs of the "ticket_options" edge to the TicketOption entity.
func (m *TicketMutation) RemovedTicketOptionsIDs() (ids []string) {
	for id := range m.removedticket_options {
		ids = append(ids, id)
	}
	return
}

// TicketOptionsIDs returns the "ticket_options" edge IDs in the mutation.
func (m *TicketMutation) TicketOptionsIDs() (ids []string) {
	for id := range m.ticket_options {
		ids = append(ids, id)
	}
	return
}

// ResetTicketOptions resets all changes to the "ticket_options" edge.
func (m *TicketMutation) ResetTicketOptions() {
	m.ticket_options = nil
	m.clearedticket_options = false
	m.removedticket_options = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.createdAt != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, ticket.EdgeEvent)
	}
	if m.ticket_options != nil {
		edges = append(edges, ticket.EdgeTicketOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.ticket_options))
		for id := range m.ticket_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedticket_options != nil {
		edges = append(edges, ticket.EdgeTicketOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.removedticket_options))
		for id := range m.removedticket_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, ticket.EdgeEvent)
	}
	if m.clearedticket_options {
		edges = append(edges, ticket.EdgeTicketOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeEvent:
		return m.clearedevent
	case ticket.EdgeTicketOptions:
		return m.clearedticket_options
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeEvent:
		m.ResetEvent()
		return nil
	case ticket.EdgeTicketOptions:
		m.ResetTicketOptions()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// TicketOptionMutation represents an operation that mutates the TicketOption nodes in the graph.
type TicketOptionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	event         *string
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*TicketOption, error)
	predicates    []predicate.TicketOption
}

var _ ent.Mutation = (*TicketOptionMutation)(nil)

// ticketoptionOption allows management of the mutation configuration using functional options.
type ticketoptionOption func(*TicketOptionMutation)

// newTicketOptionMutation creates new mutation for the TicketOption entity.
func newTicketOptionMutation(c config, op Op, opts ...ticketoptionOption) *TicketOptionMutation {
	m := &TicketOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketOptionID sets the ID field of the mutation.
func withTicketOptionID(id string) ticketoptionOption {
	return func(m *TicketOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketOption
		)
		m.oldValue = func(ctx context.Context) (*TicketOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketOption sets the old TicketOption of the mutation.
func withTicketOption(node *TicketOption) ticketoptionOption {
	return func(m *TicketOptionMutation) {
		m.oldValue = func(context.Context) (*TicketOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TicketOption entities.
func (m *TicketOptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketOptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketOptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *TicketOptionMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TicketOptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the TicketOption entity.
// If the TicketOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketOptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TicketOptionMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TicketOptionMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TicketOptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the TicketOption entity.
// If the TicketOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketOptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TicketOptionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *TicketOptionMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *TicketOptionMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *TicketOptionMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *TicketOptionMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *TicketOptionMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *TicketOptionMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the TicketOptionMutation builder.
func (m *TicketOptionMutation) Where(ps ...predicate.TicketOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketOption).
func (m *TicketOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketOptionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.createdAt != nil {
		fields = append(fields, ticketoption.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, ticketoption.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketoption.FieldCreatedAt:
		return m.CreatedAt()
	case ticketoption.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketoption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketoption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketoption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketoption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketOptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketOptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TicketOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketOptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketOptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TicketOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketOptionMutation) ResetField(name string) error {
	switch name {
	case ticketoption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketoption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, ticketoption.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketoption.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketOptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, ticketoption.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketoption.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketOptionMutation) ClearEdge(name string) error {
	switch name {
	case ticketoption.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown TicketOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketOptionMutation) ResetEdge(name string) error {
	switch name {
	case ticketoption.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown TicketOption edge %s", name)
}

// TrainerMutation represents an operation that mutates the Trainer nodes in the graph.
type TrainerMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	email         *string
	phone         *string
	clearedFields map[string]struct{}
	user          map[string]struct{}
	removeduser   map[string]struct{}
	cleareduser   bool
	place         map[string]struct{}
	removedplace  map[string]struct{}
	clearedplace  bool
	done          bool
	oldValue      func(context.Context) (*Trainer, error)
	predicates    []predicate.Trainer
}

var _ ent.Mutation = (*TrainerMutation)(nil)

// trainerOption allows management of the mutation configuration using functional options.
type trainerOption func(*TrainerMutation)

// newTrainerMutation creates new mutation for the Trainer entity.
func newTrainerMutation(c config, op Op, opts ...trainerOption) *TrainerMutation {
	m := &TrainerMutation{
		config:        c,
		op:            op,
		typ:           TypeTrainer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrainerID sets the ID field of the mutation.
func withTrainerID(id string) trainerOption {
	return func(m *TrainerMutation) {
		var (
			err   error
			once  sync.Once
			value *Trainer
		)
		m.oldValue = func(ctx context.Context) (*Trainer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trainer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrainer sets the old Trainer of the mutation.
func withTrainer(node *Trainer) trainerOption {
	return func(m *TrainerMutation) {
		m.oldValue = func(context.Context) (*Trainer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrainerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrainerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Trainer entities.
func (m *TrainerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrainerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrainerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trainer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TrainerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TrainerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Trainer entity.
// If the Trainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TrainerMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *TrainerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TrainerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Trainer entity.
// If the Trainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TrainerMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *TrainerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *TrainerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Trainer entity.
// If the Trainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *TrainerMutation) ResetPhone() {
	m.phone = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *TrainerMutation) AddUserIDs(ids ...string) {
	if m.user == nil {
		m.user = make(map[string]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *TrainerMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TrainerMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *TrainerMutation) RemoveUserIDs(ids ...string) {
	if m.removeduser == nil {
		m.removeduser = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *TrainerMutation) RemovedUserIDs() (ids []string) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *TrainerMutation) UserIDs() (ids []string) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TrainerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddPlaceIDs adds the "place" edge to the Place entity by ids.
func (m *TrainerMutation) AddPlaceIDs(ids ...string) {
	if m.place == nil {
		m.place = make(map[string]struct{})
	}
	for i := range ids {
		m.place[ids[i]] = struct{}{}
	}
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *TrainerMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *TrainerMutation) PlaceCleared() bool {
	return m.clearedplace
}

// RemovePlaceIDs removes the "place" edge to the Place entity by IDs.
func (m *TrainerMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplace == nil {
		m.removedplace = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.place, ids[i])
		m.removedplace[ids[i]] = struct{}{}
	}
}

// RemovedPlace returns the removed IDs of the "place" edge to the Place entity.
func (m *TrainerMutation) RemovedPlaceIDs() (ids []string) {
	for id := range m.removedplace {
		ids = append(ids, id)
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
func (m *TrainerMutation) PlaceIDs() (ids []string) {
	for id := range m.place {
		ids = append(ids, id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *TrainerMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
	m.removedplace = nil
}

// Where appends a list predicates to the TrainerMutation builder.
func (m *TrainerMutation) Where(ps ...predicate.Trainer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrainerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrainerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trainer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrainerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrainerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trainer).
func (m *TrainerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrainerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, trainer.FieldName)
	}
	if m.email != nil {
		fields = append(fields, trainer.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, trainer.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrainerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trainer.FieldName:
		return m.Name()
	case trainer.FieldEmail:
		return m.Email()
	case trainer.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrainerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trainer.FieldName:
		return m.OldName(ctx)
	case trainer.FieldEmail:
		return m.OldEmail(ctx)
	case trainer.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Trainer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trainer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case trainer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case trainer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Trainer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrainerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrainerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Trainer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrainerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrainerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrainerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Trainer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrainerMutation) ResetField(name string) error {
	switch name {
	case trainer.FieldName:
		m.ResetName()
		return nil
	case trainer.FieldEmail:
		m.ResetEmail()
		return nil
	case trainer.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Trainer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrainerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, trainer.EdgeUser)
	}
	if m.place != nil {
		edges = append(edges, trainer.EdgePlace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrainerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trainer.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case trainer.EdgePlace:
		ids := make([]ent.Value, 0, len(m.place))
		for id := range m.place {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrainerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, trainer.EdgeUser)
	}
	if m.removedplace != nil {
		edges = append(edges, trainer.EdgePlace)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrainerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trainer.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case trainer.EdgePlace:
		ids := make([]ent.Value, 0, len(m.removedplace))
		for id := range m.removedplace {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrainerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, trainer.EdgeUser)
	}
	if m.clearedplace {
		edges = append(edges, trainer.EdgePlace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrainerMutation) EdgeCleared(name string) bool {
	switch name {
	case trainer.EdgeUser:
		return m.cleareduser
	case trainer.EdgePlace:
		return m.clearedplace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrainerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Trainer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrainerMutation) ResetEdge(name string) error {
	switch name {
	case trainer.EdgeUser:
		m.ResetUser()
		return nil
	case trainer.EdgePlace:
		m.ResetPlace()
		return nil
	}
	return fmt.Errorf("unknown Trainer edge %s", name)
}

// TransactionHistoryMutation represents an operation that mutates the TransactionHistory nodes in the graph.
type TransactionHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	transaction_type       *transactionhistory.TransactionType
	quantity               *int
	addquantity            *int
	date                   *time.Time
	clearedFields          map[string]struct{}
	place_inventory        *string
	clearedplace_inventory bool
	user                   *string
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*TransactionHistory, error)
	predicates             []predicate.TransactionHistory
}

var _ ent.Mutation = (*TransactionHistoryMutation)(nil)

// transactionhistoryOption allows management of the mutation configuration using functional options.
type transactionhistoryOption func(*TransactionHistoryMutation)

// newTransactionHistoryMutation creates new mutation for the TransactionHistory entity.
func newTransactionHistoryMutation(c config, op Op, opts ...transactionhistoryOption) *TransactionHistoryMutation {
	m := &TransactionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionHistoryID sets the ID field of the mutation.
func withTransactionHistoryID(id string) transactionhistoryOption {
	return func(m *TransactionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionHistory
		)
		m.oldValue = func(ctx context.Context) (*TransactionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionHistory sets the old TransactionHistory of the mutation.
func withTransactionHistory(node *TransactionHistory) transactionhistoryOption {
	return func(m *TransactionHistoryMutation) {
		m.oldValue = func(context.Context) (*TransactionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTransactionType sets the "transaction_type" field.
func (m *TransactionHistoryMutation) SetTransactionType(tt transactionhistory.TransactionType) {
	m.transaction_type = &tt
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *TransactionHistoryMutation) TransactionType() (r transactionhistory.TransactionType, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the TransactionHistory entity.
// If the TransactionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionHistoryMutation) OldTransactionType(ctx context.Context) (v transactionhistory.TransactionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *TransactionHistoryMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetQuantity sets the "quantity" field.
func (m *TransactionHistoryMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *TransactionHistoryMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the TransactionHistory entity.
// If the TransactionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionHistoryMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *TransactionHistoryMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *TransactionHistoryMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *TransactionHistoryMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetDate sets the "date" field.
func (m *TransactionHistoryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *TransactionHistoryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the TransactionHistory entity.
// If the TransactionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionHistoryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *TransactionHistoryMutation) ResetDate() {
	m.date = nil
}

// SetPlaceInventoryID sets the "place_inventory" edge to the PlaceInventory entity by id.
func (m *TransactionHistoryMutation) SetPlaceInventoryID(id string) {
	m.place_inventory = &id
}

// ClearPlaceInventory clears the "place_inventory" edge to the PlaceInventory entity.
func (m *TransactionHistoryMutation) ClearPlaceInventory() {
	m.clearedplace_inventory = true
}

// PlaceInventoryCleared reports if the "place_inventory" edge to the PlaceInventory entity was cleared.
func (m *TransactionHistoryMutation) PlaceInventoryCleared() bool {
	return m.clearedplace_inventory
}

// PlaceInventoryID returns the "place_inventory" edge ID in the mutation.
func (m *TransactionHistoryMutation) PlaceInventoryID() (id string, exists bool) {
	if m.place_inventory != nil {
		return *m.place_inventory, true
	}
	return
}

// PlaceInventoryIDs returns the "place_inventory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceInventoryID instead. It exists only for internal usage by the builders.
func (m *TransactionHistoryMutation) PlaceInventoryIDs() (ids []string) {
	if id := m.place_inventory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlaceInventory resets all changes to the "place_inventory" edge.
func (m *TransactionHistoryMutation) ResetPlaceInventory() {
	m.place_inventory = nil
	m.clearedplace_inventory = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TransactionHistoryMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TransactionHistoryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TransactionHistoryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TransactionHistoryMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TransactionHistoryMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TransactionHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TransactionHistoryMutation builder.
func (m *TransactionHistoryMutation) Where(ps ...predicate.TransactionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionHistory).
func (m *TransactionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.transaction_type != nil {
		fields = append(fields, transactionhistory.FieldTransactionType)
	}
	if m.quantity != nil {
		fields = append(fields, transactionhistory.FieldQuantity)
	}
	if m.date != nil {
		fields = append(fields, transactionhistory.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionhistory.FieldTransactionType:
		return m.TransactionType()
	case transactionhistory.FieldQuantity:
		return m.Quantity()
	case transactionhistory.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionhistory.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case transactionhistory.FieldQuantity:
		return m.OldQuantity(ctx)
	case transactionhistory.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionhistory.FieldTransactionType:
		v, ok := value.(transactionhistory.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case transactionhistory.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case transactionhistory.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, transactionhistory.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionhistory.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionhistory.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransactionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionHistoryMutation) ResetField(name string) error {
	switch name {
	case transactionhistory.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case transactionhistory.FieldQuantity:
		m.ResetQuantity()
		return nil
	case transactionhistory.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown TransactionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.place_inventory != nil {
		edges = append(edges, transactionhistory.EdgePlaceInventory)
	}
	if m.user != nil {
		edges = append(edges, transactionhistory.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionhistory.EdgePlaceInventory:
		if id := m.place_inventory; id != nil {
			return []ent.Value{*id}
		}
	case transactionhistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplace_inventory {
		edges = append(edges, transactionhistory.EdgePlaceInventory)
	}
	if m.cleareduser {
		edges = append(edges, transactionhistory.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionhistory.EdgePlaceInventory:
		return m.clearedplace_inventory
	case transactionhistory.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionHistoryMutation) ClearEdge(name string) error {
	switch name {
	case transactionhistory.EdgePlaceInventory:
		m.ClearPlaceInventory()
		return nil
	case transactionhistory.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TransactionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionHistoryMutation) ResetEdge(name string) error {
	switch name {
	case transactionhistory.EdgePlaceInventory:
		m.ResetPlaceInventory()
		return nil
	case transactionhistory.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TransactionHistory edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	auth0_id                     *string
	name                         *string
	picture                      *string
	cover_image                  *string
	username                     *string
	website                      *string
	location                     *string
	map_coordinates              *map[string]interface{}
	longitude                    *string
	latitude                     *string
	bio                          *string
	auth0_data                   **management.User
	app_settings                 *map[string]interface{}
	user_settings                *map[string]interface{}
	search_text                  *string
	relevance_score              *float64
	addrelevance_score           *float64
	follower_count               *int
	addfollower_count            *int
	following_count              *int
	addfollowing_count           *int
	role                         *user.Role
	permissions                  *[]string
	appendpermissions            []string
	is_premium                   *bool
	clearedFields                map[string]struct{}
	userBusinesses               map[string]struct{}
	removeduserBusinesses        map[string]struct{}
	cleareduserBusinesses        bool
	comments                     map[string]struct{}
	removedcomments              map[string]struct{}
	clearedcomments              bool
	likes                        map[string]struct{}
	removedlikes                 map[string]struct{}
	clearedlikes                 bool
	posts                        map[string]struct{}
	removedposts                 map[string]struct{}
	clearedposts                 bool
	followedUsers                map[string]struct{}
	removedfollowedUsers         map[string]struct{}
	clearedfollowedUsers         bool
	followerUsers                map[string]struct{}
	removedfollowerUsers         map[string]struct{}
	clearedfollowerUsers         bool
	followedBusinesses           map[string]struct{}
	removedfollowedBusinesses    map[string]struct{}
	clearedfollowedBusinesses    bool
	followerBusinesses           map[string]struct{}
	removedfollowerBusinesses    map[string]struct{}
	clearedfollowerBusinesses    bool
	reviews                      map[string]struct{}
	removedreviews               map[string]struct{}
	clearedreviews               bool
	bookings                     map[string]struct{}
	removedbookings              map[string]struct{}
	clearedbookings              bool
	reservations                 map[string]struct{}
	removedreservations          map[string]struct{}
	clearedreservations          bool
	helps                        map[string]struct{}
	removedhelps                 map[string]struct{}
	clearedhelps                 bool
	categories                   map[string]struct{}
	removedcategories            map[string]struct{}
	clearedcategories            bool
	places                       map[string]struct{}
	removedplaces                map[string]struct{}
	clearedplaces                bool
	categoryAssignments          map[string]struct{}
	removedcategoryAssignments   map[string]struct{}
	clearedcategoryAssignments   bool
	ownedEvents                  *string
	clearedownedEvents           bool
	userFollowEvents             map[string]struct{}
	removeduserFollowEvents      map[string]struct{}
	cleareduserFollowEvents      bool
	followedPlaces               map[string]struct{}
	removedfollowedPlaces        map[string]struct{}
	clearedfollowedPlaces        bool
	likedPlaces                  map[string]struct{}
	removedlikedPlaces           map[string]struct{}
	clearedlikedPlaces           bool
	ratings                      map[string]struct{}
	removedratings               map[string]struct{}
	clearedratings               bool
	transaction_histories        map[string]struct{}
	removedtransaction_histories map[string]struct{}
	clearedtransaction_histories bool
	reservation_blocks           map[string]struct{}
	removedreservation_blocks    map[string]struct{}
	clearedreservation_blocks    bool
	notifications                map[string]struct{}
	removednotifications         map[string]struct{}
	clearednotifications         bool
	wallet                       *string
	clearedwallet                bool
	orders                       map[string]struct{}
	removedorders                map[string]struct{}
	clearedorders                bool
	tables_created               map[string]struct{}
	removedtables_created        map[string]struct{}
	clearedtables_created        bool
	tables_updated               map[string]struct{}
	removedtables_updated        map[string]struct{}
	clearedtables_updated        bool
	tables_deleted               map[string]struct{}
	removedtables_deleted        map[string]struct{}
	clearedtables_deleted        bool
	tables_reserved              map[string]struct{}
	removedtables_reserved       map[string]struct{}
	clearedtables_reserved       bool
	tables_waited                map[string]struct{}
	removedtables_waited         map[string]struct{}
	clearedtables_waited         bool
	staffs                       map[string]struct{}
	removedstaffs                map[string]struct{}
	clearedstaffs                bool
	created_menus                map[string]struct{}
	removedcreated_menus         map[string]struct{}
	clearedcreated_menus         bool
	updated_menus                map[string]struct{}
	removedupdated_menus         map[string]struct{}
	clearedupdated_menus         bool
	plans                        map[string]struct{}
	removedplans                 map[string]struct{}
	clearedplans                 bool
	subscriptions                map[string]struct{}
	removedsubscriptions         map[string]struct{}
	clearedsubscriptions         bool
	trainers                     map[string]struct{}
	removedtrainers              map[string]struct{}
	clearedtrainers              bool
	memberOf                     map[string]struct{}
	removedmemberOf              map[string]struct{}
	clearedmemberOf              bool
	customer                     map[string]struct{}
	removedcustomer              map[string]struct{}
	clearedcustomer              bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuth0ID sets the "auth0_id" field.
func (m *UserMutation) SetAuth0ID(s string) {
	m.auth0_id = &s
}

// Auth0ID returns the value of the "auth0_id" field in the mutation.
func (m *UserMutation) Auth0ID() (r string, exists bool) {
	v := m.auth0_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuth0ID returns the old "auth0_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuth0ID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuth0ID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuth0ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuth0ID: %w", err)
	}
	return oldValue.Auth0ID, nil
}

// ResetAuth0ID resets all changes to the "auth0_id" field.
func (m *UserMutation) ResetAuth0ID() {
	m.auth0_id = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetPicture sets the "picture" field.
func (m *UserMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *UserMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *UserMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[user.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *UserMutation) PictureCleared() bool {
	_, ok := m.clearedFields[user.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *UserMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, user.FieldPicture)
}

// SetCoverImage sets the "cover_image" field.
func (m *UserMutation) SetCoverImage(s string) {
	m.cover_image = &s
}

// CoverImage returns the value of the "cover_image" field in the mutation.
func (m *UserMutation) CoverImage() (r string, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "cover_image" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ClearCoverImage clears the value of the "cover_image" field.
func (m *UserMutation) ClearCoverImage() {
	m.cover_image = nil
	m.clearedFields[user.FieldCoverImage] = struct{}{}
}

// CoverImageCleared returns if the "cover_image" field was cleared in this mutation.
func (m *UserMutation) CoverImageCleared() bool {
	_, ok := m.clearedFields[user.FieldCoverImage]
	return ok
}

// ResetCoverImage resets all changes to the "cover_image" field.
func (m *UserMutation) ResetCoverImage() {
	m.cover_image = nil
	delete(m.clearedFields, user.FieldCoverImage)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetWebsite sets the "website" field.
func (m *UserMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *UserMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *UserMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[user.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *UserMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[user.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *UserMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, user.FieldWebsite)
}

// SetLocation sets the "location" field.
func (m *UserMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UserMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[user.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UserMutation) LocationCleared() bool {
	_, ok := m.clearedFields[user.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UserMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, user.FieldLocation)
}

// SetMapCoordinates sets the "map_coordinates" field.
func (m *UserMutation) SetMapCoordinates(value map[string]interface{}) {
	m.map_coordinates = &value
}

// MapCoordinates returns the value of the "map_coordinates" field in the mutation.
func (m *UserMutation) MapCoordinates() (r map[string]interface{}, exists bool) {
	v := m.map_coordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldMapCoordinates returns the old "map_coordinates" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMapCoordinates(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapCoordinates: %w", err)
	}
	return oldValue.MapCoordinates, nil
}

// ClearMapCoordinates clears the value of the "map_coordinates" field.
func (m *UserMutation) ClearMapCoordinates() {
	m.map_coordinates = nil
	m.clearedFields[user.FieldMapCoordinates] = struct{}{}
}

// MapCoordinatesCleared returns if the "map_coordinates" field was cleared in this mutation.
func (m *UserMutation) MapCoordinatesCleared() bool {
	_, ok := m.clearedFields[user.FieldMapCoordinates]
	return ok
}

// ResetMapCoordinates resets all changes to the "map_coordinates" field.
func (m *UserMutation) ResetMapCoordinates() {
	m.map_coordinates = nil
	delete(m.clearedFields, user.FieldMapCoordinates)
}

// SetLongitude sets the "longitude" field.
func (m *UserMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *UserMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *UserMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[user.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *UserMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[user.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *UserMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, user.FieldLongitude)
}

// SetLatitude sets the "latitude" field.
func (m *UserMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *UserMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *UserMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[user.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *UserMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[user.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *UserMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, user.FieldLatitude)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetAuth0Data sets the "auth0_data" field.
func (m *UserMutation) SetAuth0Data(value *management.User) {
	m.auth0_data = &value
}

// Auth0Data returns the value of the "auth0_data" field in the mutation.
func (m *UserMutation) Auth0Data() (r *management.User, exists bool) {
	v := m.auth0_data
	if v == nil {
		return
	}
	return *v, true
}

// OldAuth0Data returns the old "auth0_data" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuth0Data(ctx context.Context) (v *management.User, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuth0Data is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuth0Data requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuth0Data: %w", err)
	}
	return oldValue.Auth0Data, nil
}

// ClearAuth0Data clears the value of the "auth0_data" field.
func (m *UserMutation) ClearAuth0Data() {
	m.auth0_data = nil
	m.clearedFields[user.FieldAuth0Data] = struct{}{}
}

// Auth0DataCleared returns if the "auth0_data" field was cleared in this mutation.
func (m *UserMutation) Auth0DataCleared() bool {
	_, ok := m.clearedFields[user.FieldAuth0Data]
	return ok
}

// ResetAuth0Data resets all changes to the "auth0_data" field.
func (m *UserMutation) ResetAuth0Data() {
	m.auth0_data = nil
	delete(m.clearedFields, user.FieldAuth0Data)
}

// SetAppSettings sets the "app_settings" field.
func (m *UserMutation) SetAppSettings(value map[string]interface{}) {
	m.app_settings = &value
}

// AppSettings returns the value of the "app_settings" field in the mutation.
func (m *UserMutation) AppSettings() (r map[string]interface{}, exists bool) {
	v := m.app_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSettings returns the old "app_settings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAppSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSettings: %w", err)
	}
	return oldValue.AppSettings, nil
}

// ClearAppSettings clears the value of the "app_settings" field.
func (m *UserMutation) ClearAppSettings() {
	m.app_settings = nil
	m.clearedFields[user.FieldAppSettings] = struct{}{}
}

// AppSettingsCleared returns if the "app_settings" field was cleared in this mutation.
func (m *UserMutation) AppSettingsCleared() bool {
	_, ok := m.clearedFields[user.FieldAppSettings]
	return ok
}

// ResetAppSettings resets all changes to the "app_settings" field.
func (m *UserMutation) ResetAppSettings() {
	m.app_settings = nil
	delete(m.clearedFields, user.FieldAppSettings)
}

// SetUserSettings sets the "user_settings" field.
func (m *UserMutation) SetUserSettings(value map[string]interface{}) {
	m.user_settings = &value
}

// UserSettings returns the value of the "user_settings" field in the mutation.
func (m *UserMutation) UserSettings() (r map[string]interface{}, exists bool) {
	v := m.user_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSettings returns the old "user_settings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSettings: %w", err)
	}
	return oldValue.UserSettings, nil
}

// ClearUserSettings clears the value of the "user_settings" field.
func (m *UserMutation) ClearUserSettings() {
	m.user_settings = nil
	m.clearedFields[user.FieldUserSettings] = struct{}{}
}

// UserSettingsCleared returns if the "user_settings" field was cleared in this mutation.
func (m *UserMutation) UserSettingsCleared() bool {
	_, ok := m.clearedFields[user.FieldUserSettings]
	return ok
}

// ResetUserSettings resets all changes to the "user_settings" field.
func (m *UserMutation) ResetUserSettings() {
	m.user_settings = nil
	delete(m.clearedFields, user.FieldUserSettings)
}

// SetSearchText sets the "search_text" field.
func (m *UserMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *UserMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *UserMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[user.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *UserMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[user.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *UserMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, user.FieldSearchText)
}

// SetRelevanceScore sets the "relevance_score" field.
func (m *UserMutation) SetRelevanceScore(f float64) {
	m.relevance_score = &f
	m.addrelevance_score = nil
}

// RelevanceScore returns the value of the "relevance_score" field in the mutation.
func (m *UserMutation) RelevanceScore() (r float64, exists bool) {
	v := m.relevance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "relevance_score" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRelevanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds f to the "relevance_score" field.
func (m *UserMutation) AddRelevanceScore(f float64) {
	if m.addrelevance_score != nil {
		*m.addrelevance_score += f
	} else {
		m.addrelevance_score = &f
	}
}

// AddedRelevanceScore returns the value that was added to the "relevance_score" field in this mutation.
func (m *UserMutation) AddedRelevanceScore() (r float64, exists bool) {
	v := m.addrelevance_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelevanceScore clears the value of the "relevance_score" field.
func (m *UserMutation) ClearRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	m.clearedFields[user.FieldRelevanceScore] = struct{}{}
}

// RelevanceScoreCleared returns if the "relevance_score" field was cleared in this mutation.
func (m *UserMutation) RelevanceScoreCleared() bool {
	_, ok := m.clearedFields[user.FieldRelevanceScore]
	return ok
}

// ResetRelevanceScore resets all changes to the "relevance_score" field.
func (m *UserMutation) ResetRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	delete(m.clearedFields, user.FieldRelevanceScore)
}

// SetFollowerCount sets the "follower_count" field.
func (m *UserMutation) SetFollowerCount(i int) {
	m.follower_count = &i
	m.addfollower_count = nil
}

// FollowerCount returns the value of the "follower_count" field in the mutation.
func (m *UserMutation) FollowerCount() (r int, exists bool) {
	v := m.follower_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerCount returns the old "follower_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerCount: %w", err)
	}
	return oldValue.FollowerCount, nil
}

// AddFollowerCount adds i to the "follower_count" field.
func (m *UserMutation) AddFollowerCount(i int) {
	if m.addfollower_count != nil {
		*m.addfollower_count += i
	} else {
		m.addfollower_count = &i
	}
}

// AddedFollowerCount returns the value that was added to the "follower_count" field in this mutation.
func (m *UserMutation) AddedFollowerCount() (r int, exists bool) {
	v := m.addfollower_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowerCount resets all changes to the "follower_count" field.
func (m *UserMutation) ResetFollowerCount() {
	m.follower_count = nil
	m.addfollower_count = nil
}

// SetFollowingCount sets the "following_count" field.
func (m *UserMutation) SetFollowingCount(i int) {
	m.following_count = &i
	m.addfollowing_count = nil
}

// FollowingCount returns the value of the "following_count" field in the mutation.
func (m *UserMutation) FollowingCount() (r int, exists bool) {
	v := m.following_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingCount returns the old "following_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingCount: %w", err)
	}
	return oldValue.FollowingCount, nil
}

// AddFollowingCount adds i to the "following_count" field.
func (m *UserMutation) AddFollowingCount(i int) {
	if m.addfollowing_count != nil {
		*m.addfollowing_count += i
	} else {
		m.addfollowing_count = &i
	}
}

// AddedFollowingCount returns the value that was added to the "following_count" field in this mutation.
func (m *UserMutation) AddedFollowingCount() (r int, exists bool) {
	v := m.addfollowing_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowingCount resets all changes to the "following_count" field.
func (m *UserMutation) ResetFollowingCount() {
	m.following_count = nil
	m.addfollowing_count = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetPermissions sets the "permissions" field.
func (m *UserMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *UserMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *UserMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ClearPermissions clears the value of the "permissions" field.
func (m *UserMutation) ClearPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	m.clearedFields[user.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *UserMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[user.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	delete(m.clearedFields, user.FieldPermissions)
}

// SetIsPremium sets the "is_premium" field.
func (m *UserMutation) SetIsPremium(b bool) {
	m.is_premium = &b
}

// IsPremium returns the value of the "is_premium" field in the mutation.
func (m *UserMutation) IsPremium() (r bool, exists bool) {
	v := m.is_premium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old "is_premium" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium resets all changes to the "is_premium" field.
func (m *UserMutation) ResetIsPremium() {
	m.is_premium = nil
}

// AddUserBusinessIDs adds the "userBusinesses" edge to the UserBusiness entity by ids.
func (m *UserMutation) AddUserBusinessIDs(ids ...string) {
	if m.userBusinesses == nil {
		m.userBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.userBusinesses[ids[i]] = struct{}{}
	}
}

// ClearUserBusinesses clears the "userBusinesses" edge to the UserBusiness entity.
func (m *UserMutation) ClearUserBusinesses() {
	m.cleareduserBusinesses = true
}

// UserBusinessesCleared reports if the "userBusinesses" edge to the UserBusiness entity was cleared.
func (m *UserMutation) UserBusinessesCleared() bool {
	return m.cleareduserBusinesses
}

// RemoveUserBusinessIDs removes the "userBusinesses" edge to the UserBusiness entity by IDs.
func (m *UserMutation) RemoveUserBusinessIDs(ids ...string) {
	if m.removeduserBusinesses == nil {
		m.removeduserBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.userBusinesses, ids[i])
		m.removeduserBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedUserBusinesses returns the removed IDs of the "userBusinesses" edge to the UserBusiness entity.
func (m *UserMutation) RemovedUserBusinessesIDs() (ids []string) {
	for id := range m.removeduserBusinesses {
		ids = append(ids, id)
	}
	return
}

// UserBusinessesIDs returns the "userBusinesses" edge IDs in the mutation.
func (m *UserMutation) UserBusinessesIDs() (ids []string) {
	for id := range m.userBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetUserBusinesses resets all changes to the "userBusinesses" edge.
func (m *UserMutation) ResetUserBusinesses() {
	m.userBusinesses = nil
	m.cleareduserBusinesses = false
	m.removeduserBusinesses = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikeIDs adds the "likes" edge to the Like entity by ids.
func (m *UserMutation) AddLikeIDs(ids ...string) {
	if m.likes == nil {
		m.likes = make(map[string]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the Like entity.
func (m *UserMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the Like entity was cleared.
func (m *UserMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the Like entity by IDs.
func (m *UserMutation) RemoveLikeIDs(ids ...string) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the Like entity.
func (m *UserMutation) RemovedLikesIDs() (ids []string) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *UserMutation) LikesIDs() (ids []string) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *UserMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddFollowedUserIDs adds the "followedUsers" edge to the UserFollowUser entity by ids.
func (m *UserMutation) AddFollowedUserIDs(ids ...string) {
	if m.followedUsers == nil {
		m.followedUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followedUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowedUsers clears the "followedUsers" edge to the UserFollowUser entity.
func (m *UserMutation) ClearFollowedUsers() {
	m.clearedfollowedUsers = true
}

// FollowedUsersCleared reports if the "followedUsers" edge to the UserFollowUser entity was cleared.
func (m *UserMutation) FollowedUsersCleared() bool {
	return m.clearedfollowedUsers
}

// RemoveFollowedUserIDs removes the "followedUsers" edge to the UserFollowUser entity by IDs.
func (m *UserMutation) RemoveFollowedUserIDs(ids ...string) {
	if m.removedfollowedUsers == nil {
		m.removedfollowedUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedUsers, ids[i])
		m.removedfollowedUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowedUsers returns the removed IDs of the "followedUsers" edge to the UserFollowUser entity.
func (m *UserMutation) RemovedFollowedUsersIDs() (ids []string) {
	for id := range m.removedfollowedUsers {
		ids = append(ids, id)
	}
	return
}

// FollowedUsersIDs returns the "followedUsers" edge IDs in the mutation.
func (m *UserMutation) FollowedUsersIDs() (ids []string) {
	for id := range m.followedUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedUsers resets all changes to the "followedUsers" edge.
func (m *UserMutation) ResetFollowedUsers() {
	m.followedUsers = nil
	m.clearedfollowedUsers = false
	m.removedfollowedUsers = nil
}

// AddFollowerUserIDs adds the "followerUsers" edge to the UserFollowUser entity by ids.
func (m *UserMutation) AddFollowerUserIDs(ids ...string) {
	if m.followerUsers == nil {
		m.followerUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followerUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowerUsers clears the "followerUsers" edge to the UserFollowUser entity.
func (m *UserMutation) ClearFollowerUsers() {
	m.clearedfollowerUsers = true
}

// FollowerUsersCleared reports if the "followerUsers" edge to the UserFollowUser entity was cleared.
func (m *UserMutation) FollowerUsersCleared() bool {
	return m.clearedfollowerUsers
}

// RemoveFollowerUserIDs removes the "followerUsers" edge to the UserFollowUser entity by IDs.
func (m *UserMutation) RemoveFollowerUserIDs(ids ...string) {
	if m.removedfollowerUsers == nil {
		m.removedfollowerUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerUsers, ids[i])
		m.removedfollowerUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowerUsers returns the removed IDs of the "followerUsers" edge to the UserFollowUser entity.
func (m *UserMutation) RemovedFollowerUsersIDs() (ids []string) {
	for id := range m.removedfollowerUsers {
		ids = append(ids, id)
	}
	return
}

// FollowerUsersIDs returns the "followerUsers" edge IDs in the mutation.
func (m *UserMutation) FollowerUsersIDs() (ids []string) {
	for id := range m.followerUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerUsers resets all changes to the "followerUsers" edge.
func (m *UserMutation) ResetFollowerUsers() {
	m.followerUsers = nil
	m.clearedfollowerUsers = false
	m.removedfollowerUsers = nil
}

// AddFollowedBusinessIDs adds the "followedBusinesses" edge to the UserFollowBusiness entity by ids.
func (m *UserMutation) AddFollowedBusinessIDs(ids ...string) {
	if m.followedBusinesses == nil {
		m.followedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followedBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowedBusinesses clears the "followedBusinesses" edge to the UserFollowBusiness entity.
func (m *UserMutation) ClearFollowedBusinesses() {
	m.clearedfollowedBusinesses = true
}

// FollowedBusinessesCleared reports if the "followedBusinesses" edge to the UserFollowBusiness entity was cleared.
func (m *UserMutation) FollowedBusinessesCleared() bool {
	return m.clearedfollowedBusinesses
}

// RemoveFollowedBusinessIDs removes the "followedBusinesses" edge to the UserFollowBusiness entity by IDs.
func (m *UserMutation) RemoveFollowedBusinessIDs(ids ...string) {
	if m.removedfollowedBusinesses == nil {
		m.removedfollowedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedBusinesses, ids[i])
		m.removedfollowedBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBusinesses returns the removed IDs of the "followedBusinesses" edge to the UserFollowBusiness entity.
func (m *UserMutation) RemovedFollowedBusinessesIDs() (ids []string) {
	for id := range m.removedfollowedBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowedBusinessesIDs returns the "followedBusinesses" edge IDs in the mutation.
func (m *UserMutation) FollowedBusinessesIDs() (ids []string) {
	for id := range m.followedBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBusinesses resets all changes to the "followedBusinesses" edge.
func (m *UserMutation) ResetFollowedBusinesses() {
	m.followedBusinesses = nil
	m.clearedfollowedBusinesses = false
	m.removedfollowedBusinesses = nil
}

// AddFollowerBusinessIDs adds the "followerBusinesses" edge to the BusinessFollowUser entity by ids.
func (m *UserMutation) AddFollowerBusinessIDs(ids ...string) {
	if m.followerBusinesses == nil {
		m.followerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followerBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowerBusinesses clears the "followerBusinesses" edge to the BusinessFollowUser entity.
func (m *UserMutation) ClearFollowerBusinesses() {
	m.clearedfollowerBusinesses = true
}

// FollowerBusinessesCleared reports if the "followerBusinesses" edge to the BusinessFollowUser entity was cleared.
func (m *UserMutation) FollowerBusinessesCleared() bool {
	return m.clearedfollowerBusinesses
}

// RemoveFollowerBusinessIDs removes the "followerBusinesses" edge to the BusinessFollowUser entity by IDs.
func (m *UserMutation) RemoveFollowerBusinessIDs(ids ...string) {
	if m.removedfollowerBusinesses == nil {
		m.removedfollowerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerBusinesses, ids[i])
		m.removedfollowerBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowerBusinesses returns the removed IDs of the "followerBusinesses" edge to the BusinessFollowUser entity.
func (m *UserMutation) RemovedFollowerBusinessesIDs() (ids []string) {
	for id := range m.removedfollowerBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowerBusinessesIDs returns the "followerBusinesses" edge IDs in the mutation.
func (m *UserMutation) FollowerBusinessesIDs() (ids []string) {
	for id := range m.followerBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerBusinesses resets all changes to the "followerBusinesses" edge.
func (m *UserMutation) ResetFollowerBusinesses() {
	m.followerBusinesses = nil
	m.clearedfollowerBusinesses = false
	m.removedfollowerBusinesses = nil
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *UserMutation) AddReviewIDs(ids ...string) {
	if m.reviews == nil {
		m.reviews = make(map[string]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *UserMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *UserMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *UserMutation) RemoveReviewIDs(ids ...string) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *UserMutation) RemovedReviewsIDs() (ids []string) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *UserMutation) ReviewsIDs() (ids []string) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *UserMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *UserMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *UserMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *UserMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *UserMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *UserMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *UserMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *UserMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddReservationIDs adds the "reservations" edge to the Reservation entity by ids.
func (m *UserMutation) AddReservationIDs(ids ...string) {
	if m.reservations == nil {
		m.reservations = make(map[string]struct{})
	}
	for i := range ids {
		m.reservations[ids[i]] = struct{}{}
	}
}

// ClearReservations clears the "reservations" edge to the Reservation entity.
func (m *UserMutation) ClearReservations() {
	m.clearedreservations = true
}

// ReservationsCleared reports if the "reservations" edge to the Reservation entity was cleared.
func (m *UserMutation) ReservationsCleared() bool {
	return m.clearedreservations
}

// RemoveReservationIDs removes the "reservations" edge to the Reservation entity by IDs.
func (m *UserMutation) RemoveReservationIDs(ids ...string) {
	if m.removedreservations == nil {
		m.removedreservations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reservations, ids[i])
		m.removedreservations[ids[i]] = struct{}{}
	}
}

// RemovedReservations returns the removed IDs of the "reservations" edge to the Reservation entity.
func (m *UserMutation) RemovedReservationsIDs() (ids []string) {
	for id := range m.removedreservations {
		ids = append(ids, id)
	}
	return
}

// ReservationsIDs returns the "reservations" edge IDs in the mutation.
func (m *UserMutation) ReservationsIDs() (ids []string) {
	for id := range m.reservations {
		ids = append(ids, id)
	}
	return
}

// ResetReservations resets all changes to the "reservations" edge.
func (m *UserMutation) ResetReservations() {
	m.reservations = nil
	m.clearedreservations = false
	m.removedreservations = nil
}

// AddHelpIDs adds the "helps" edge to the Help entity by ids.
func (m *UserMutation) AddHelpIDs(ids ...string) {
	if m.helps == nil {
		m.helps = make(map[string]struct{})
	}
	for i := range ids {
		m.helps[ids[i]] = struct{}{}
	}
}

// ClearHelps clears the "helps" edge to the Help entity.
func (m *UserMutation) ClearHelps() {
	m.clearedhelps = true
}

// HelpsCleared reports if the "helps" edge to the Help entity was cleared.
func (m *UserMutation) HelpsCleared() bool {
	return m.clearedhelps
}

// RemoveHelpIDs removes the "helps" edge to the Help entity by IDs.
func (m *UserMutation) RemoveHelpIDs(ids ...string) {
	if m.removedhelps == nil {
		m.removedhelps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.helps, ids[i])
		m.removedhelps[ids[i]] = struct{}{}
	}
}

// RemovedHelps returns the removed IDs of the "helps" edge to the Help entity.
func (m *UserMutation) RemovedHelpsIDs() (ids []string) {
	for id := range m.removedhelps {
		ids = append(ids, id)
	}
	return
}

// HelpsIDs returns the "helps" edge IDs in the mutation.
func (m *UserMutation) HelpsIDs() (ids []string) {
	for id := range m.helps {
		ids = append(ids, id)
	}
	return
}

// ResetHelps resets all changes to the "helps" edge.
func (m *UserMutation) ResetHelps() {
	m.helps = nil
	m.clearedhelps = false
	m.removedhelps = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *UserMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *UserMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *UserMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *UserMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *UserMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *UserMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *UserMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *UserMutation) AddPlaceIDs(ids ...string) {
	if m.places == nil {
		m.places = make(map[string]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *UserMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *UserMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *UserMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *UserMutation) RemovedPlacesIDs() (ids []string) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *UserMutation) PlacesIDs() (ids []string) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *UserMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *UserMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *UserMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *UserMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *UserMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *UserMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *UserMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *UserMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// SetOwnedEventsID sets the "ownedEvents" edge to the Event entity by id.
func (m *UserMutation) SetOwnedEventsID(id string) {
	m.ownedEvents = &id
}

// ClearOwnedEvents clears the "ownedEvents" edge to the Event entity.
func (m *UserMutation) ClearOwnedEvents() {
	m.clearedownedEvents = true
}

// OwnedEventsCleared reports if the "ownedEvents" edge to the Event entity was cleared.
func (m *UserMutation) OwnedEventsCleared() bool {
	return m.clearedownedEvents
}

// OwnedEventsID returns the "ownedEvents" edge ID in the mutation.
func (m *UserMutation) OwnedEventsID() (id string, exists bool) {
	if m.ownedEvents != nil {
		return *m.ownedEvents, true
	}
	return
}

// OwnedEventsIDs returns the "ownedEvents" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnedEventsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OwnedEventsIDs() (ids []string) {
	if id := m.ownedEvents; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnedEvents resets all changes to the "ownedEvents" edge.
func (m *UserMutation) ResetOwnedEvents() {
	m.ownedEvents = nil
	m.clearedownedEvents = false
}

// AddUserFollowEventIDs adds the "userFollowEvents" edge to the UserFollowEvent entity by ids.
func (m *UserMutation) AddUserFollowEventIDs(ids ...string) {
	if m.userFollowEvents == nil {
		m.userFollowEvents = make(map[string]struct{})
	}
	for i := range ids {
		m.userFollowEvents[ids[i]] = struct{}{}
	}
}

// ClearUserFollowEvents clears the "userFollowEvents" edge to the UserFollowEvent entity.
func (m *UserMutation) ClearUserFollowEvents() {
	m.cleareduserFollowEvents = true
}

// UserFollowEventsCleared reports if the "userFollowEvents" edge to the UserFollowEvent entity was cleared.
func (m *UserMutation) UserFollowEventsCleared() bool {
	return m.cleareduserFollowEvents
}

// RemoveUserFollowEventIDs removes the "userFollowEvents" edge to the UserFollowEvent entity by IDs.
func (m *UserMutation) RemoveUserFollowEventIDs(ids ...string) {
	if m.removeduserFollowEvents == nil {
		m.removeduserFollowEvents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.userFollowEvents, ids[i])
		m.removeduserFollowEvents[ids[i]] = struct{}{}
	}
}

// RemovedUserFollowEvents returns the removed IDs of the "userFollowEvents" edge to the UserFollowEvent entity.
func (m *UserMutation) RemovedUserFollowEventsIDs() (ids []string) {
	for id := range m.removeduserFollowEvents {
		ids = append(ids, id)
	}
	return
}

// UserFollowEventsIDs returns the "userFollowEvents" edge IDs in the mutation.
func (m *UserMutation) UserFollowEventsIDs() (ids []string) {
	for id := range m.userFollowEvents {
		ids = append(ids, id)
	}
	return
}

// ResetUserFollowEvents resets all changes to the "userFollowEvents" edge.
func (m *UserMutation) ResetUserFollowEvents() {
	m.userFollowEvents = nil
	m.cleareduserFollowEvents = false
	m.removeduserFollowEvents = nil
}

// AddFollowedPlaceIDs adds the "followedPlaces" edge to the UserFollowPlace entity by ids.
func (m *UserMutation) AddFollowedPlaceIDs(ids ...string) {
	if m.followedPlaces == nil {
		m.followedPlaces = make(map[string]struct{})
	}
	for i := range ids {
		m.followedPlaces[ids[i]] = struct{}{}
	}
}

// ClearFollowedPlaces clears the "followedPlaces" edge to the UserFollowPlace entity.
func (m *UserMutation) ClearFollowedPlaces() {
	m.clearedfollowedPlaces = true
}

// FollowedPlacesCleared reports if the "followedPlaces" edge to the UserFollowPlace entity was cleared.
func (m *UserMutation) FollowedPlacesCleared() bool {
	return m.clearedfollowedPlaces
}

// RemoveFollowedPlaceIDs removes the "followedPlaces" edge to the UserFollowPlace entity by IDs.
func (m *UserMutation) RemoveFollowedPlaceIDs(ids ...string) {
	if m.removedfollowedPlaces == nil {
		m.removedfollowedPlaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedPlaces, ids[i])
		m.removedfollowedPlaces[ids[i]] = struct{}{}
	}
}

// RemovedFollowedPlaces returns the removed IDs of the "followedPlaces" edge to the UserFollowPlace entity.
func (m *UserMutation) RemovedFollowedPlacesIDs() (ids []string) {
	for id := range m.removedfollowedPlaces {
		ids = append(ids, id)
	}
	return
}

// FollowedPlacesIDs returns the "followedPlaces" edge IDs in the mutation.
func (m *UserMutation) FollowedPlacesIDs() (ids []string) {
	for id := range m.followedPlaces {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedPlaces resets all changes to the "followedPlaces" edge.
func (m *UserMutation) ResetFollowedPlaces() {
	m.followedPlaces = nil
	m.clearedfollowedPlaces = false
	m.removedfollowedPlaces = nil
}

// AddLikedPlaceIDs adds the "likedPlaces" edge to the UserLikePlace entity by ids.
func (m *UserMutation) AddLikedPlaceIDs(ids ...string) {
	if m.likedPlaces == nil {
		m.likedPlaces = make(map[string]struct{})
	}
	for i := range ids {
		m.likedPlaces[ids[i]] = struct{}{}
	}
}

// ClearLikedPlaces clears the "likedPlaces" edge to the UserLikePlace entity.
func (m *UserMutation) ClearLikedPlaces() {
	m.clearedlikedPlaces = true
}

// LikedPlacesCleared reports if the "likedPlaces" edge to the UserLikePlace entity was cleared.
func (m *UserMutation) LikedPlacesCleared() bool {
	return m.clearedlikedPlaces
}

// RemoveLikedPlaceIDs removes the "likedPlaces" edge to the UserLikePlace entity by IDs.
func (m *UserMutation) RemoveLikedPlaceIDs(ids ...string) {
	if m.removedlikedPlaces == nil {
		m.removedlikedPlaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likedPlaces, ids[i])
		m.removedlikedPlaces[ids[i]] = struct{}{}
	}
}

// RemovedLikedPlaces returns the removed IDs of the "likedPlaces" edge to the UserLikePlace entity.
func (m *UserMutation) RemovedLikedPlacesIDs() (ids []string) {
	for id := range m.removedlikedPlaces {
		ids = append(ids, id)
	}
	return
}

// LikedPlacesIDs returns the "likedPlaces" edge IDs in the mutation.
func (m *UserMutation) LikedPlacesIDs() (ids []string) {
	for id := range m.likedPlaces {
		ids = append(ids, id)
	}
	return
}

// ResetLikedPlaces resets all changes to the "likedPlaces" edge.
func (m *UserMutation) ResetLikedPlaces() {
	m.likedPlaces = nil
	m.clearedlikedPlaces = false
	m.removedlikedPlaces = nil
}

// AddRatingIDs adds the "ratings" edge to the Rating entity by ids.
func (m *UserMutation) AddRatingIDs(ids ...string) {
	if m.ratings == nil {
		m.ratings = make(map[string]struct{})
	}
	for i := range ids {
		m.ratings[ids[i]] = struct{}{}
	}
}

// ClearRatings clears the "ratings" edge to the Rating entity.
func (m *UserMutation) ClearRatings() {
	m.clearedratings = true
}

// RatingsCleared reports if the "ratings" edge to the Rating entity was cleared.
func (m *UserMutation) RatingsCleared() bool {
	return m.clearedratings
}

// RemoveRatingIDs removes the "ratings" edge to the Rating entity by IDs.
func (m *UserMutation) RemoveRatingIDs(ids ...string) {
	if m.removedratings == nil {
		m.removedratings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratings, ids[i])
		m.removedratings[ids[i]] = struct{}{}
	}
}

// RemovedRatings returns the removed IDs of the "ratings" edge to the Rating entity.
func (m *UserMutation) RemovedRatingsIDs() (ids []string) {
	for id := range m.removedratings {
		ids = append(ids, id)
	}
	return
}

// RatingsIDs returns the "ratings" edge IDs in the mutation.
func (m *UserMutation) RatingsIDs() (ids []string) {
	for id := range m.ratings {
		ids = append(ids, id)
	}
	return
}

// ResetRatings resets all changes to the "ratings" edge.
func (m *UserMutation) ResetRatings() {
	m.ratings = nil
	m.clearedratings = false
	m.removedratings = nil
}

// AddTransactionHistoryIDs adds the "transaction_histories" edge to the TransactionHistory entity by ids.
func (m *UserMutation) AddTransactionHistoryIDs(ids ...string) {
	if m.transaction_histories == nil {
		m.transaction_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.transaction_histories[ids[i]] = struct{}{}
	}
}

// ClearTransactionHistories clears the "transaction_histories" edge to the TransactionHistory entity.
func (m *UserMutation) ClearTransactionHistories() {
	m.clearedtransaction_histories = true
}

// TransactionHistoriesCleared reports if the "transaction_histories" edge to the TransactionHistory entity was cleared.
func (m *UserMutation) TransactionHistoriesCleared() bool {
	return m.clearedtransaction_histories
}

// RemoveTransactionHistoryIDs removes the "transaction_histories" edge to the TransactionHistory entity by IDs.
func (m *UserMutation) RemoveTransactionHistoryIDs(ids ...string) {
	if m.removedtransaction_histories == nil {
		m.removedtransaction_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transaction_histories, ids[i])
		m.removedtransaction_histories[ids[i]] = struct{}{}
	}
}

// RemovedTransactionHistories returns the removed IDs of the "transaction_histories" edge to the TransactionHistory entity.
func (m *UserMutation) RemovedTransactionHistoriesIDs() (ids []string) {
	for id := range m.removedtransaction_histories {
		ids = append(ids, id)
	}
	return
}

// TransactionHistoriesIDs returns the "transaction_histories" edge IDs in the mutation.
func (m *UserMutation) TransactionHistoriesIDs() (ids []string) {
	for id := range m.transaction_histories {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionHistories resets all changes to the "transaction_histories" edge.
func (m *UserMutation) ResetTransactionHistories() {
	m.transaction_histories = nil
	m.clearedtransaction_histories = false
	m.removedtransaction_histories = nil
}

// AddReservationBlockIDs adds the "reservation_blocks" edge to the ReservationBlock entity by ids.
func (m *UserMutation) AddReservationBlockIDs(ids ...string) {
	if m.reservation_blocks == nil {
		m.reservation_blocks = make(map[string]struct{})
	}
	for i := range ids {
		m.reservation_blocks[ids[i]] = struct{}{}
	}
}

// ClearReservationBlocks clears the "reservation_blocks" edge to the ReservationBlock entity.
func (m *UserMutation) ClearReservationBlocks() {
	m.clearedreservation_blocks = true
}

// ReservationBlocksCleared reports if the "reservation_blocks" edge to the ReservationBlock entity was cleared.
func (m *UserMutation) ReservationBlocksCleared() bool {
	return m.clearedreservation_blocks
}

// RemoveReservationBlockIDs removes the "reservation_blocks" edge to the ReservationBlock entity by IDs.
func (m *UserMutation) RemoveReservationBlockIDs(ids ...string) {
	if m.removedreservation_blocks == nil {
		m.removedreservation_blocks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reservation_blocks, ids[i])
		m.removedreservation_blocks[ids[i]] = struct{}{}
	}
}

// RemovedReservationBlocks returns the removed IDs of the "reservation_blocks" edge to the ReservationBlock entity.
func (m *UserMutation) RemovedReservationBlocksIDs() (ids []string) {
	for id := range m.removedreservation_blocks {
		ids = append(ids, id)
	}
	return
}

// ReservationBlocksIDs returns the "reservation_blocks" edge IDs in the mutation.
func (m *UserMutation) ReservationBlocksIDs() (ids []string) {
	for id := range m.reservation_blocks {
		ids = append(ids, id)
	}
	return
}

// ResetReservationBlocks resets all changes to the "reservation_blocks" edge.
func (m *UserMutation) ResetReservationBlocks() {
	m.reservation_blocks = nil
	m.clearedreservation_blocks = false
	m.removedreservation_blocks = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *UserMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *UserMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *UserMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *UserMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *UserMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *UserMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *UserMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// SetWalletID sets the "wallet" edge to the AccountWallet entity by id.
func (m *UserMutation) SetWalletID(id string) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the AccountWallet entity.
func (m *UserMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the AccountWallet entity was cleared.
func (m *UserMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *UserMutation) WalletID() (id string, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *UserMutation) WalletIDs() (ids []string) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *UserMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *UserMutation) AddOrderIDs(ids ...string) {
	if m.orders == nil {
		m.orders = make(map[string]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *UserMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *UserMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveOrderIDs(ids ...string) {
	if m.removedorders == nil {
		m.removedorders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *UserMutation) RemovedOrdersIDs() (ids []string) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *UserMutation) OrdersIDs() (ids []string) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *UserMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddTablesCreatedIDs adds the "tables_created" edge to the PlaceTable entity by ids.
func (m *UserMutation) AddTablesCreatedIDs(ids ...string) {
	if m.tables_created == nil {
		m.tables_created = make(map[string]struct{})
	}
	for i := range ids {
		m.tables_created[ids[i]] = struct{}{}
	}
}

// ClearTablesCreated clears the "tables_created" edge to the PlaceTable entity.
func (m *UserMutation) ClearTablesCreated() {
	m.clearedtables_created = true
}

// TablesCreatedCleared reports if the "tables_created" edge to the PlaceTable entity was cleared.
func (m *UserMutation) TablesCreatedCleared() bool {
	return m.clearedtables_created
}

// RemoveTablesCreatedIDs removes the "tables_created" edge to the PlaceTable entity by IDs.
func (m *UserMutation) RemoveTablesCreatedIDs(ids ...string) {
	if m.removedtables_created == nil {
		m.removedtables_created = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tables_created, ids[i])
		m.removedtables_created[ids[i]] = struct{}{}
	}
}

// RemovedTablesCreated returns the removed IDs of the "tables_created" edge to the PlaceTable entity.
func (m *UserMutation) RemovedTablesCreatedIDs() (ids []string) {
	for id := range m.removedtables_created {
		ids = append(ids, id)
	}
	return
}

// TablesCreatedIDs returns the "tables_created" edge IDs in the mutation.
func (m *UserMutation) TablesCreatedIDs() (ids []string) {
	for id := range m.tables_created {
		ids = append(ids, id)
	}
	return
}

// ResetTablesCreated resets all changes to the "tables_created" edge.
func (m *UserMutation) ResetTablesCreated() {
	m.tables_created = nil
	m.clearedtables_created = false
	m.removedtables_created = nil
}

// AddTablesUpdatedIDs adds the "tables_updated" edge to the PlaceTable entity by ids.
func (m *UserMutation) AddTablesUpdatedIDs(ids ...string) {
	if m.tables_updated == nil {
		m.tables_updated = make(map[string]struct{})
	}
	for i := range ids {
		m.tables_updated[ids[i]] = struct{}{}
	}
}

// ClearTablesUpdated clears the "tables_updated" edge to the PlaceTable entity.
func (m *UserMutation) ClearTablesUpdated() {
	m.clearedtables_updated = true
}

// TablesUpdatedCleared reports if the "tables_updated" edge to the PlaceTable entity was cleared.
func (m *UserMutation) TablesUpdatedCleared() bool {
	return m.clearedtables_updated
}

// RemoveTablesUpdatedIDs removes the "tables_updated" edge to the PlaceTable entity by IDs.
func (m *UserMutation) RemoveTablesUpdatedIDs(ids ...string) {
	if m.removedtables_updated == nil {
		m.removedtables_updated = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tables_updated, ids[i])
		m.removedtables_updated[ids[i]] = struct{}{}
	}
}

// RemovedTablesUpdated returns the removed IDs of the "tables_updated" edge to the PlaceTable entity.
func (m *UserMutation) RemovedTablesUpdatedIDs() (ids []string) {
	for id := range m.removedtables_updated {
		ids = append(ids, id)
	}
	return
}

// TablesUpdatedIDs returns the "tables_updated" edge IDs in the mutation.
func (m *UserMutation) TablesUpdatedIDs() (ids []string) {
	for id := range m.tables_updated {
		ids = append(ids, id)
	}
	return
}

// ResetTablesUpdated resets all changes to the "tables_updated" edge.
func (m *UserMutation) ResetTablesUpdated() {
	m.tables_updated = nil
	m.clearedtables_updated = false
	m.removedtables_updated = nil
}

// AddTablesDeletedIDs adds the "tables_deleted" edge to the PlaceTable entity by ids.
func (m *UserMutation) AddTablesDeletedIDs(ids ...string) {
	if m.tables_deleted == nil {
		m.tables_deleted = make(map[string]struct{})
	}
	for i := range ids {
		m.tables_deleted[ids[i]] = struct{}{}
	}
}

// ClearTablesDeleted clears the "tables_deleted" edge to the PlaceTable entity.
func (m *UserMutation) ClearTablesDeleted() {
	m.clearedtables_deleted = true
}

// TablesDeletedCleared reports if the "tables_deleted" edge to the PlaceTable entity was cleared.
func (m *UserMutation) TablesDeletedCleared() bool {
	return m.clearedtables_deleted
}

// RemoveTablesDeletedIDs removes the "tables_deleted" edge to the PlaceTable entity by IDs.
func (m *UserMutation) RemoveTablesDeletedIDs(ids ...string) {
	if m.removedtables_deleted == nil {
		m.removedtables_deleted = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tables_deleted, ids[i])
		m.removedtables_deleted[ids[i]] = struct{}{}
	}
}

// RemovedTablesDeleted returns the removed IDs of the "tables_deleted" edge to the PlaceTable entity.
func (m *UserMutation) RemovedTablesDeletedIDs() (ids []string) {
	for id := range m.removedtables_deleted {
		ids = append(ids, id)
	}
	return
}

// TablesDeletedIDs returns the "tables_deleted" edge IDs in the mutation.
func (m *UserMutation) TablesDeletedIDs() (ids []string) {
	for id := range m.tables_deleted {
		ids = append(ids, id)
	}
	return
}

// ResetTablesDeleted resets all changes to the "tables_deleted" edge.
func (m *UserMutation) ResetTablesDeleted() {
	m.tables_deleted = nil
	m.clearedtables_deleted = false
	m.removedtables_deleted = nil
}

// AddTablesReservedIDs adds the "tables_reserved" edge to the PlaceTable entity by ids.
func (m *UserMutation) AddTablesReservedIDs(ids ...string) {
	if m.tables_reserved == nil {
		m.tables_reserved = make(map[string]struct{})
	}
	for i := range ids {
		m.tables_reserved[ids[i]] = struct{}{}
	}
}

// ClearTablesReserved clears the "tables_reserved" edge to the PlaceTable entity.
func (m *UserMutation) ClearTablesReserved() {
	m.clearedtables_reserved = true
}

// TablesReservedCleared reports if the "tables_reserved" edge to the PlaceTable entity was cleared.
func (m *UserMutation) TablesReservedCleared() bool {
	return m.clearedtables_reserved
}

// RemoveTablesReservedIDs removes the "tables_reserved" edge to the PlaceTable entity by IDs.
func (m *UserMutation) RemoveTablesReservedIDs(ids ...string) {
	if m.removedtables_reserved == nil {
		m.removedtables_reserved = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tables_reserved, ids[i])
		m.removedtables_reserved[ids[i]] = struct{}{}
	}
}

// RemovedTablesReserved returns the removed IDs of the "tables_reserved" edge to the PlaceTable entity.
func (m *UserMutation) RemovedTablesReservedIDs() (ids []string) {
	for id := range m.removedtables_reserved {
		ids = append(ids, id)
	}
	return
}

// TablesReservedIDs returns the "tables_reserved" edge IDs in the mutation.
func (m *UserMutation) TablesReservedIDs() (ids []string) {
	for id := range m.tables_reserved {
		ids = append(ids, id)
	}
	return
}

// ResetTablesReserved resets all changes to the "tables_reserved" edge.
func (m *UserMutation) ResetTablesReserved() {
	m.tables_reserved = nil
	m.clearedtables_reserved = false
	m.removedtables_reserved = nil
}

// AddTablesWaitedIDs adds the "tables_waited" edge to the PlaceTable entity by ids.
func (m *UserMutation) AddTablesWaitedIDs(ids ...string) {
	if m.tables_waited == nil {
		m.tables_waited = make(map[string]struct{})
	}
	for i := range ids {
		m.tables_waited[ids[i]] = struct{}{}
	}
}

// ClearTablesWaited clears the "tables_waited" edge to the PlaceTable entity.
func (m *UserMutation) ClearTablesWaited() {
	m.clearedtables_waited = true
}

// TablesWaitedCleared reports if the "tables_waited" edge to the PlaceTable entity was cleared.
func (m *UserMutation) TablesWaitedCleared() bool {
	return m.clearedtables_waited
}

// RemoveTablesWaitedIDs removes the "tables_waited" edge to the PlaceTable entity by IDs.
func (m *UserMutation) RemoveTablesWaitedIDs(ids ...string) {
	if m.removedtables_waited == nil {
		m.removedtables_waited = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tables_waited, ids[i])
		m.removedtables_waited[ids[i]] = struct{}{}
	}
}

// RemovedTablesWaited returns the removed IDs of the "tables_waited" edge to the PlaceTable entity.
func (m *UserMutation) RemovedTablesWaitedIDs() (ids []string) {
	for id := range m.removedtables_waited {
		ids = append(ids, id)
	}
	return
}

// TablesWaitedIDs returns the "tables_waited" edge IDs in the mutation.
func (m *UserMutation) TablesWaitedIDs() (ids []string) {
	for id := range m.tables_waited {
		ids = append(ids, id)
	}
	return
}

// ResetTablesWaited resets all changes to the "tables_waited" edge.
func (m *UserMutation) ResetTablesWaited() {
	m.tables_waited = nil
	m.clearedtables_waited = false
	m.removedtables_waited = nil
}

// AddStaffIDs adds the "staffs" edge to the Staff entity by ids.
func (m *UserMutation) AddStaffIDs(ids ...string) {
	if m.staffs == nil {
		m.staffs = make(map[string]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the Staff entity.
func (m *UserMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the Staff entity was cleared.
func (m *UserMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the Staff entity by IDs.
func (m *UserMutation) RemoveStaffIDs(ids ...string) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the Staff entity.
func (m *UserMutation) RemovedStaffsIDs() (ids []string) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *UserMutation) StaffsIDs() (ids []string) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *UserMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// AddCreatedMenuIDs adds the "created_menus" edge to the Menu entity by ids.
func (m *UserMutation) AddCreatedMenuIDs(ids ...string) {
	if m.created_menus == nil {
		m.created_menus = make(map[string]struct{})
	}
	for i := range ids {
		m.created_menus[ids[i]] = struct{}{}
	}
}

// ClearCreatedMenus clears the "created_menus" edge to the Menu entity.
func (m *UserMutation) ClearCreatedMenus() {
	m.clearedcreated_menus = true
}

// CreatedMenusCleared reports if the "created_menus" edge to the Menu entity was cleared.
func (m *UserMutation) CreatedMenusCleared() bool {
	return m.clearedcreated_menus
}

// RemoveCreatedMenuIDs removes the "created_menus" edge to the Menu entity by IDs.
func (m *UserMutation) RemoveCreatedMenuIDs(ids ...string) {
	if m.removedcreated_menus == nil {
		m.removedcreated_menus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_menus, ids[i])
		m.removedcreated_menus[ids[i]] = struct{}{}
	}
}

// RemovedCreatedMenus returns the removed IDs of the "created_menus" edge to the Menu entity.
func (m *UserMutation) RemovedCreatedMenusIDs() (ids []string) {
	for id := range m.removedcreated_menus {
		ids = append(ids, id)
	}
	return
}

// CreatedMenusIDs returns the "created_menus" edge IDs in the mutation.
func (m *UserMutation) CreatedMenusIDs() (ids []string) {
	for id := range m.created_menus {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedMenus resets all changes to the "created_menus" edge.
func (m *UserMutation) ResetCreatedMenus() {
	m.created_menus = nil
	m.clearedcreated_menus = false
	m.removedcreated_menus = nil
}

// AddUpdatedMenuIDs adds the "updated_menus" edge to the Menu entity by ids.
func (m *UserMutation) AddUpdatedMenuIDs(ids ...string) {
	if m.updated_menus == nil {
		m.updated_menus = make(map[string]struct{})
	}
	for i := range ids {
		m.updated_menus[ids[i]] = struct{}{}
	}
}

// ClearUpdatedMenus clears the "updated_menus" edge to the Menu entity.
func (m *UserMutation) ClearUpdatedMenus() {
	m.clearedupdated_menus = true
}

// UpdatedMenusCleared reports if the "updated_menus" edge to the Menu entity was cleared.
func (m *UserMutation) UpdatedMenusCleared() bool {
	return m.clearedupdated_menus
}

// RemoveUpdatedMenuIDs removes the "updated_menus" edge to the Menu entity by IDs.
func (m *UserMutation) RemoveUpdatedMenuIDs(ids ...string) {
	if m.removedupdated_menus == nil {
		m.removedupdated_menus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.updated_menus, ids[i])
		m.removedupdated_menus[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedMenus returns the removed IDs of the "updated_menus" edge to the Menu entity.
func (m *UserMutation) RemovedUpdatedMenusIDs() (ids []string) {
	for id := range m.removedupdated_menus {
		ids = append(ids, id)
	}
	return
}

// UpdatedMenusIDs returns the "updated_menus" edge IDs in the mutation.
func (m *UserMutation) UpdatedMenusIDs() (ids []string) {
	for id := range m.updated_menus {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedMenus resets all changes to the "updated_menus" edge.
func (m *UserMutation) ResetUpdatedMenus() {
	m.updated_menus = nil
	m.clearedupdated_menus = false
	m.removedupdated_menus = nil
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *UserMutation) AddPlanIDs(ids ...string) {
	if m.plans == nil {
		m.plans = make(map[string]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *UserMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *UserMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *UserMutation) RemovePlanIDs(ids ...string) {
	if m.removedplans == nil {
		m.removedplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *UserMutation) RemovedPlansIDs() (ids []string) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *UserMutation) PlansIDs() (ids []string) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *UserMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddTrainerIDs adds the "trainers" edge to the Trainer entity by ids.
func (m *UserMutation) AddTrainerIDs(ids ...string) {
	if m.trainers == nil {
		m.trainers = make(map[string]struct{})
	}
	for i := range ids {
		m.trainers[ids[i]] = struct{}{}
	}
}

// ClearTrainers clears the "trainers" edge to the Trainer entity.
func (m *UserMutation) ClearTrainers() {
	m.clearedtrainers = true
}

// TrainersCleared reports if the "trainers" edge to the Trainer entity was cleared.
func (m *UserMutation) TrainersCleared() bool {
	return m.clearedtrainers
}

// RemoveTrainerIDs removes the "trainers" edge to the Trainer entity by IDs.
func (m *UserMutation) RemoveTrainerIDs(ids ...string) {
	if m.removedtrainers == nil {
		m.removedtrainers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.trainers, ids[i])
		m.removedtrainers[ids[i]] = struct{}{}
	}
}

// RemovedTrainers returns the removed IDs of the "trainers" edge to the Trainer entity.
func (m *UserMutation) RemovedTrainersIDs() (ids []string) {
	for id := range m.removedtrainers {
		ids = append(ids, id)
	}
	return
}

// TrainersIDs returns the "trainers" edge IDs in the mutation.
func (m *UserMutation) TrainersIDs() (ids []string) {
	for id := range m.trainers {
		ids = append(ids, id)
	}
	return
}

// ResetTrainers resets all changes to the "trainers" edge.
func (m *UserMutation) ResetTrainers() {
	m.trainers = nil
	m.clearedtrainers = false
	m.removedtrainers = nil
}

// AddMemberOfIDs adds the "memberOf" edge to the Place entity by ids.
func (m *UserMutation) AddMemberOfIDs(ids ...string) {
	if m.memberOf == nil {
		m.memberOf = make(map[string]struct{})
	}
	for i := range ids {
		m.memberOf[ids[i]] = struct{}{}
	}
}

// ClearMemberOf clears the "memberOf" edge to the Place entity.
func (m *UserMutation) ClearMemberOf() {
	m.clearedmemberOf = true
}

// MemberOfCleared reports if the "memberOf" edge to the Place entity was cleared.
func (m *UserMutation) MemberOfCleared() bool {
	return m.clearedmemberOf
}

// RemoveMemberOfIDs removes the "memberOf" edge to the Place entity by IDs.
func (m *UserMutation) RemoveMemberOfIDs(ids ...string) {
	if m.removedmemberOf == nil {
		m.removedmemberOf = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.memberOf, ids[i])
		m.removedmemberOf[ids[i]] = struct{}{}
	}
}

// RemovedMemberOf returns the removed IDs of the "memberOf" edge to the Place entity.
func (m *UserMutation) RemovedMemberOfIDs() (ids []string) {
	for id := range m.removedmemberOf {
		ids = append(ids, id)
	}
	return
}

// MemberOfIDs returns the "memberOf" edge IDs in the mutation.
func (m *UserMutation) MemberOfIDs() (ids []string) {
	for id := range m.memberOf {
		ids = append(ids, id)
	}
	return
}

// ResetMemberOf resets all changes to the "memberOf" edge.
func (m *UserMutation) ResetMemberOf() {
	m.memberOf = nil
	m.clearedmemberOf = false
	m.removedmemberOf = nil
}

// AddCustomerIDs adds the "customer" edge to the Place entity by ids.
func (m *UserMutation) AddCustomerIDs(ids ...string) {
	if m.customer == nil {
		m.customer = make(map[string]struct{})
	}
	for i := range ids {
		m.customer[ids[i]] = struct{}{}
	}
}

// ClearCustomer clears the "customer" edge to the Place entity.
func (m *UserMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Place entity was cleared.
func (m *UserMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// RemoveCustomerIDs removes the "customer" edge to the Place entity by IDs.
func (m *UserMutation) RemoveCustomerIDs(ids ...string) {
	if m.removedcustomer == nil {
		m.removedcustomer = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.customer, ids[i])
		m.removedcustomer[ids[i]] = struct{}{}
	}
}

// RemovedCustomer returns the removed IDs of the "customer" edge to the Place entity.
func (m *UserMutation) RemovedCustomerIDs() (ids []string) {
	for id := range m.removedcustomer {
		ids = append(ids, id)
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
func (m *UserMutation) CustomerIDs() (ids []string) {
	for id := range m.customer {
		ids = append(ids, id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *UserMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
	m.removedcustomer = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.auth0_id != nil {
		fields = append(fields, user.FieldAuth0ID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.picture != nil {
		fields = append(fields, user.FieldPicture)
	}
	if m.cover_image != nil {
		fields = append(fields, user.FieldCoverImage)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.website != nil {
		fields = append(fields, user.FieldWebsite)
	}
	if m.location != nil {
		fields = append(fields, user.FieldLocation)
	}
	if m.map_coordinates != nil {
		fields = append(fields, user.FieldMapCoordinates)
	}
	if m.longitude != nil {
		fields = append(fields, user.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, user.FieldLatitude)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.auth0_data != nil {
		fields = append(fields, user.FieldAuth0Data)
	}
	if m.app_settings != nil {
		fields = append(fields, user.FieldAppSettings)
	}
	if m.user_settings != nil {
		fields = append(fields, user.FieldUserSettings)
	}
	if m.search_text != nil {
		fields = append(fields, user.FieldSearchText)
	}
	if m.relevance_score != nil {
		fields = append(fields, user.FieldRelevanceScore)
	}
	if m.follower_count != nil {
		fields = append(fields, user.FieldFollowerCount)
	}
	if m.following_count != nil {
		fields = append(fields, user.FieldFollowingCount)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.permissions != nil {
		fields = append(fields, user.FieldPermissions)
	}
	if m.is_premium != nil {
		fields = append(fields, user.FieldIsPremium)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAuth0ID:
		return m.Auth0ID()
	case user.FieldName:
		return m.Name()
	case user.FieldPicture:
		return m.Picture()
	case user.FieldCoverImage:
		return m.CoverImage()
	case user.FieldUsername:
		return m.Username()
	case user.FieldWebsite:
		return m.Website()
	case user.FieldLocation:
		return m.Location()
	case user.FieldMapCoordinates:
		return m.MapCoordinates()
	case user.FieldLongitude:
		return m.Longitude()
	case user.FieldLatitude:
		return m.Latitude()
	case user.FieldBio:
		return m.Bio()
	case user.FieldAuth0Data:
		return m.Auth0Data()
	case user.FieldAppSettings:
		return m.AppSettings()
	case user.FieldUserSettings:
		return m.UserSettings()
	case user.FieldSearchText:
		return m.SearchText()
	case user.FieldRelevanceScore:
		return m.RelevanceScore()
	case user.FieldFollowerCount:
		return m.FollowerCount()
	case user.FieldFollowingCount:
		return m.FollowingCount()
	case user.FieldRole:
		return m.Role()
	case user.FieldPermissions:
		return m.Permissions()
	case user.FieldIsPremium:
		return m.IsPremium()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAuth0ID:
		return m.OldAuth0ID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPicture:
		return m.OldPicture(ctx)
	case user.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldWebsite:
		return m.OldWebsite(ctx)
	case user.FieldLocation:
		return m.OldLocation(ctx)
	case user.FieldMapCoordinates:
		return m.OldMapCoordinates(ctx)
	case user.FieldLongitude:
		return m.OldLongitude(ctx)
	case user.FieldLatitude:
		return m.OldLatitude(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldAuth0Data:
		return m.OldAuth0Data(ctx)
	case user.FieldAppSettings:
		return m.OldAppSettings(ctx)
	case user.FieldUserSettings:
		return m.OldUserSettings(ctx)
	case user.FieldSearchText:
		return m.OldSearchText(ctx)
	case user.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	case user.FieldFollowerCount:
		return m.OldFollowerCount(ctx)
	case user.FieldFollowingCount:
		return m.OldFollowingCount(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldPermissions:
		return m.OldPermissions(ctx)
	case user.FieldIsPremium:
		return m.OldIsPremium(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAuth0ID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuth0ID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case user.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case user.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case user.FieldMapCoordinates:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapCoordinates(v)
		return nil
	case user.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case user.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldAuth0Data:
		v, ok := value.(*management.User)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuth0Data(v)
		return nil
	case user.FieldAppSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSettings(v)
		return nil
	case user.FieldUserSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSettings(v)
		return nil
	case user.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	case user.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	case user.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerCount(v)
		return nil
	case user.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingCount(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case user.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrelevance_score != nil {
		fields = append(fields, user.FieldRelevanceScore)
	}
	if m.addfollower_count != nil {
		fields = append(fields, user.FieldFollowerCount)
	}
	if m.addfollowing_count != nil {
		fields = append(fields, user.FieldFollowingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	case user.FieldFollowerCount:
		return m.AddedFollowerCount()
	case user.FieldFollowingCount:
		return m.AddedFollowingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	case user.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowerCount(v)
		return nil
	case user.FieldFollowingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingCount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldPicture) {
		fields = append(fields, user.FieldPicture)
	}
	if m.FieldCleared(user.FieldCoverImage) {
		fields = append(fields, user.FieldCoverImage)
	}
	if m.FieldCleared(user.FieldWebsite) {
		fields = append(fields, user.FieldWebsite)
	}
	if m.FieldCleared(user.FieldLocation) {
		fields = append(fields, user.FieldLocation)
	}
	if m.FieldCleared(user.FieldMapCoordinates) {
		fields = append(fields, user.FieldMapCoordinates)
	}
	if m.FieldCleared(user.FieldLongitude) {
		fields = append(fields, user.FieldLongitude)
	}
	if m.FieldCleared(user.FieldLatitude) {
		fields = append(fields, user.FieldLatitude)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldAuth0Data) {
		fields = append(fields, user.FieldAuth0Data)
	}
	if m.FieldCleared(user.FieldAppSettings) {
		fields = append(fields, user.FieldAppSettings)
	}
	if m.FieldCleared(user.FieldUserSettings) {
		fields = append(fields, user.FieldUserSettings)
	}
	if m.FieldCleared(user.FieldSearchText) {
		fields = append(fields, user.FieldSearchText)
	}
	if m.FieldCleared(user.FieldRelevanceScore) {
		fields = append(fields, user.FieldRelevanceScore)
	}
	if m.FieldCleared(user.FieldPermissions) {
		fields = append(fields, user.FieldPermissions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldPicture:
		m.ClearPicture()
		return nil
	case user.FieldCoverImage:
		m.ClearCoverImage()
		return nil
	case user.FieldWebsite:
		m.ClearWebsite()
		return nil
	case user.FieldLocation:
		m.ClearLocation()
		return nil
	case user.FieldMapCoordinates:
		m.ClearMapCoordinates()
		return nil
	case user.FieldLongitude:
		m.ClearLongitude()
		return nil
	case user.FieldLatitude:
		m.ClearLatitude()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldAuth0Data:
		m.ClearAuth0Data()
		return nil
	case user.FieldAppSettings:
		m.ClearAppSettings()
		return nil
	case user.FieldUserSettings:
		m.ClearUserSettings()
		return nil
	case user.FieldSearchText:
		m.ClearSearchText()
		return nil
	case user.FieldRelevanceScore:
		m.ClearRelevanceScore()
		return nil
	case user.FieldPermissions:
		m.ClearPermissions()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAuth0ID:
		m.ResetAuth0ID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPicture:
		m.ResetPicture()
		return nil
	case user.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldWebsite:
		m.ResetWebsite()
		return nil
	case user.FieldLocation:
		m.ResetLocation()
		return nil
	case user.FieldMapCoordinates:
		m.ResetMapCoordinates()
		return nil
	case user.FieldLongitude:
		m.ResetLongitude()
		return nil
	case user.FieldLatitude:
		m.ResetLatitude()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldAuth0Data:
		m.ResetAuth0Data()
		return nil
	case user.FieldAppSettings:
		m.ResetAppSettings()
		return nil
	case user.FieldUserSettings:
		m.ResetUserSettings()
		return nil
	case user.FieldSearchText:
		m.ResetSearchText()
		return nil
	case user.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	case user.FieldFollowerCount:
		m.ResetFollowerCount()
		return nil
	case user.FieldFollowingCount:
		m.ResetFollowingCount()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldPermissions:
		m.ResetPermissions()
		return nil
	case user.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 38)
	if m.userBusinesses != nil {
		edges = append(edges, user.EdgeUserBusinesses)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.likes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.followedUsers != nil {
		edges = append(edges, user.EdgeFollowedUsers)
	}
	if m.followerUsers != nil {
		edges = append(edges, user.EdgeFollowerUsers)
	}
	if m.followedBusinesses != nil {
		edges = append(edges, user.EdgeFollowedBusinesses)
	}
	if m.followerBusinesses != nil {
		edges = append(edges, user.EdgeFollowerBusinesses)
	}
	if m.reviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	if m.bookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	if m.reservations != nil {
		edges = append(edges, user.EdgeReservations)
	}
	if m.helps != nil {
		edges = append(edges, user.EdgeHelps)
	}
	if m.categories != nil {
		edges = append(edges, user.EdgeCategories)
	}
	if m.places != nil {
		edges = append(edges, user.EdgePlaces)
	}
	if m.categoryAssignments != nil {
		edges = append(edges, user.EdgeCategoryAssignments)
	}
	if m.ownedEvents != nil {
		edges = append(edges, user.EdgeOwnedEvents)
	}
	if m.userFollowEvents != nil {
		edges = append(edges, user.EdgeUserFollowEvents)
	}
	if m.followedPlaces != nil {
		edges = append(edges, user.EdgeFollowedPlaces)
	}
	if m.likedPlaces != nil {
		edges = append(edges, user.EdgeLikedPlaces)
	}
	if m.ratings != nil {
		edges = append(edges, user.EdgeRatings)
	}
	if m.transaction_histories != nil {
		edges = append(edges, user.EdgeTransactionHistories)
	}
	if m.reservation_blocks != nil {
		edges = append(edges, user.EdgeReservationBlocks)
	}
	if m.notifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.wallet != nil {
		edges = append(edges, user.EdgeWallet)
	}
	if m.orders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	if m.tables_created != nil {
		edges = append(edges, user.EdgeTablesCreated)
	}
	if m.tables_updated != nil {
		edges = append(edges, user.EdgeTablesUpdated)
	}
	if m.tables_deleted != nil {
		edges = append(edges, user.EdgeTablesDeleted)
	}
	if m.tables_reserved != nil {
		edges = append(edges, user.EdgeTablesReserved)
	}
	if m.tables_waited != nil {
		edges = append(edges, user.EdgeTablesWaited)
	}
	if m.staffs != nil {
		edges = append(edges, user.EdgeStaffs)
	}
	if m.created_menus != nil {
		edges = append(edges, user.EdgeCreatedMenus)
	}
	if m.updated_menus != nil {
		edges = append(edges, user.EdgeUpdatedMenus)
	}
	if m.plans != nil {
		edges = append(edges, user.EdgePlans)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.trainers != nil {
		edges = append(edges, user.EdgeTrainers)
	}
	if m.memberOf != nil {
		edges = append(edges, user.EdgeMemberOf)
	}
	if m.customer != nil {
		edges = append(edges, user.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.userBusinesses))
		for id := range m.userBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.followedUsers))
		for id := range m.followedUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.followerUsers))
		for id := range m.followerUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.followedBusinesses))
		for id := range m.followedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.followerBusinesses))
		for id := range m.followerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.reservations))
		for id := range m.reservations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHelps:
		ids := make([]ent.Value, 0, len(m.helps))
		for id := range m.helps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedEvents:
		if id := m.ownedEvents; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserFollowEvents:
		ids := make([]ent.Value, 0, len(m.userFollowEvents))
		for id := range m.userFollowEvents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedPlaces:
		ids := make([]ent.Value, 0, len(m.followedPlaces))
		for id := range m.followedPlaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedPlaces:
		ids := make([]ent.Value, 0, len(m.likedPlaces))
		for id := range m.likedPlaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.ratings))
		for id := range m.ratings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransactionHistories:
		ids := make([]ent.Value, 0, len(m.transaction_histories))
		for id := range m.transaction_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReservationBlocks:
		ids := make([]ent.Value, 0, len(m.reservation_blocks))
		for id := range m.reservation_blocks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesCreated:
		ids := make([]ent.Value, 0, len(m.tables_created))
		for id := range m.tables_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesUpdated:
		ids := make([]ent.Value, 0, len(m.tables_updated))
		for id := range m.tables_updated {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesDeleted:
		ids := make([]ent.Value, 0, len(m.tables_deleted))
		for id := range m.tables_deleted {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesReserved:
		ids := make([]ent.Value, 0, len(m.tables_reserved))
		for id := range m.tables_reserved {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesWaited:
		ids := make([]ent.Value, 0, len(m.tables_waited))
		for id := range m.tables_waited {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedMenus:
		ids := make([]ent.Value, 0, len(m.created_menus))
		for id := range m.created_menus {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedMenus:
		ids := make([]ent.Value, 0, len(m.updated_menus))
		for id := range m.updated_menus {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTrainers:
		ids := make([]ent.Value, 0, len(m.trainers))
		for id := range m.trainers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMemberOf:
		ids := make([]ent.Value, 0, len(m.memberOf))
		for id := range m.memberOf {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.customer))
		for id := range m.customer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 38)
	if m.removeduserBusinesses != nil {
		edges = append(edges, user.EdgeUserBusinesses)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedlikes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.removedfollowedUsers != nil {
		edges = append(edges, user.EdgeFollowedUsers)
	}
	if m.removedfollowerUsers != nil {
		edges = append(edges, user.EdgeFollowerUsers)
	}
	if m.removedfollowedBusinesses != nil {
		edges = append(edges, user.EdgeFollowedBusinesses)
	}
	if m.removedfollowerBusinesses != nil {
		edges = append(edges, user.EdgeFollowerBusinesses)
	}
	if m.removedreviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	if m.removedbookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	if m.removedreservations != nil {
		edges = append(edges, user.EdgeReservations)
	}
	if m.removedhelps != nil {
		edges = append(edges, user.EdgeHelps)
	}
	if m.removedcategories != nil {
		edges = append(edges, user.EdgeCategories)
	}
	if m.removedplaces != nil {
		edges = append(edges, user.EdgePlaces)
	}
	if m.removedcategoryAssignments != nil {
		edges = append(edges, user.EdgeCategoryAssignments)
	}
	if m.removeduserFollowEvents != nil {
		edges = append(edges, user.EdgeUserFollowEvents)
	}
	if m.removedfollowedPlaces != nil {
		edges = append(edges, user.EdgeFollowedPlaces)
	}
	if m.removedlikedPlaces != nil {
		edges = append(edges, user.EdgeLikedPlaces)
	}
	if m.removedratings != nil {
		edges = append(edges, user.EdgeRatings)
	}
	if m.removedtransaction_histories != nil {
		edges = append(edges, user.EdgeTransactionHistories)
	}
	if m.removedreservation_blocks != nil {
		edges = append(edges, user.EdgeReservationBlocks)
	}
	if m.removednotifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.removedorders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	if m.removedtables_created != nil {
		edges = append(edges, user.EdgeTablesCreated)
	}
	if m.removedtables_updated != nil {
		edges = append(edges, user.EdgeTablesUpdated)
	}
	if m.removedtables_deleted != nil {
		edges = append(edges, user.EdgeTablesDeleted)
	}
	if m.removedtables_reserved != nil {
		edges = append(edges, user.EdgeTablesReserved)
	}
	if m.removedtables_waited != nil {
		edges = append(edges, user.EdgeTablesWaited)
	}
	if m.removedstaffs != nil {
		edges = append(edges, user.EdgeStaffs)
	}
	if m.removedcreated_menus != nil {
		edges = append(edges, user.EdgeCreatedMenus)
	}
	if m.removedupdated_menus != nil {
		edges = append(edges, user.EdgeUpdatedMenus)
	}
	if m.removedplans != nil {
		edges = append(edges, user.EdgePlans)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedtrainers != nil {
		edges = append(edges, user.EdgeTrainers)
	}
	if m.removedmemberOf != nil {
		edges = append(edges, user.EdgeMemberOf)
	}
	if m.removedcustomer != nil {
		edges = append(edges, user.EdgeCustomer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.removeduserBusinesses))
		for id := range m.removeduserBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowedUsers))
		for id := range m.removedfollowedUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowerUsers))
		for id := range m.removedfollowerUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowedBusinesses))
		for id := range m.removedfollowedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowerBusinesses))
		for id := range m.removedfollowerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.removedreservations))
		for id := range m.removedreservations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHelps:
		ids := make([]ent.Value, 0, len(m.removedhelps))
		for id := range m.removedhelps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserFollowEvents:
		ids := make([]ent.Value, 0, len(m.removeduserFollowEvents))
		for id := range m.removeduserFollowEvents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedPlaces:
		ids := make([]ent.Value, 0, len(m.removedfollowedPlaces))
		for id := range m.removedfollowedPlaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedPlaces:
		ids := make([]ent.Value, 0, len(m.removedlikedPlaces))
		for id := range m.removedlikedPlaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.removedratings))
		for id := range m.removedratings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransactionHistories:
		ids := make([]ent.Value, 0, len(m.removedtransaction_histories))
		for id := range m.removedtransaction_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReservationBlocks:
		ids := make([]ent.Value, 0, len(m.removedreservation_blocks))
		for id := range m.removedreservation_blocks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesCreated:
		ids := make([]ent.Value, 0, len(m.removedtables_created))
		for id := range m.removedtables_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesUpdated:
		ids := make([]ent.Value, 0, len(m.removedtables_updated))
		for id := range m.removedtables_updated {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesDeleted:
		ids := make([]ent.Value, 0, len(m.removedtables_deleted))
		for id := range m.removedtables_deleted {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesReserved:
		ids := make([]ent.Value, 0, len(m.removedtables_reserved))
		for id := range m.removedtables_reserved {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTablesWaited:
		ids := make([]ent.Value, 0, len(m.removedtables_waited))
		for id := range m.removedtables_waited {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedMenus:
		ids := make([]ent.Value, 0, len(m.removedcreated_menus))
		for id := range m.removedcreated_menus {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedMenus:
		ids := make([]ent.Value, 0, len(m.removedupdated_menus))
		for id := range m.removedupdated_menus {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTrainers:
		ids := make([]ent.Value, 0, len(m.removedtrainers))
		for id := range m.removedtrainers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMemberOf:
		ids := make([]ent.Value, 0, len(m.removedmemberOf))
		for id := range m.removedmemberOf {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.removedcustomer))
		for id := range m.removedcustomer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 38)
	if m.cleareduserBusinesses {
		edges = append(edges, user.EdgeUserBusinesses)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedlikes {
		edges = append(edges, user.EdgeLikes)
	}
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	if m.clearedfollowedUsers {
		edges = append(edges, user.EdgeFollowedUsers)
	}
	if m.clearedfollowerUsers {
		edges = append(edges, user.EdgeFollowerUsers)
	}
	if m.clearedfollowedBusinesses {
		edges = append(edges, user.EdgeFollowedBusinesses)
	}
	if m.clearedfollowerBusinesses {
		edges = append(edges, user.EdgeFollowerBusinesses)
	}
	if m.clearedreviews {
		edges = append(edges, user.EdgeReviews)
	}
	if m.clearedbookings {
		edges = append(edges, user.EdgeBookings)
	}
	if m.clearedreservations {
		edges = append(edges, user.EdgeReservations)
	}
	if m.clearedhelps {
		edges = append(edges, user.EdgeHelps)
	}
	if m.clearedcategories {
		edges = append(edges, user.EdgeCategories)
	}
	if m.clearedplaces {
		edges = append(edges, user.EdgePlaces)
	}
	if m.clearedcategoryAssignments {
		edges = append(edges, user.EdgeCategoryAssignments)
	}
	if m.clearedownedEvents {
		edges = append(edges, user.EdgeOwnedEvents)
	}
	if m.cleareduserFollowEvents {
		edges = append(edges, user.EdgeUserFollowEvents)
	}
	if m.clearedfollowedPlaces {
		edges = append(edges, user.EdgeFollowedPlaces)
	}
	if m.clearedlikedPlaces {
		edges = append(edges, user.EdgeLikedPlaces)
	}
	if m.clearedratings {
		edges = append(edges, user.EdgeRatings)
	}
	if m.clearedtransaction_histories {
		edges = append(edges, user.EdgeTransactionHistories)
	}
	if m.clearedreservation_blocks {
		edges = append(edges, user.EdgeReservationBlocks)
	}
	if m.clearednotifications {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.clearedwallet {
		edges = append(edges, user.EdgeWallet)
	}
	if m.clearedorders {
		edges = append(edges, user.EdgeOrders)
	}
	if m.clearedtables_created {
		edges = append(edges, user.EdgeTablesCreated)
	}
	if m.clearedtables_updated {
		edges = append(edges, user.EdgeTablesUpdated)
	}
	if m.clearedtables_deleted {
		edges = append(edges, user.EdgeTablesDeleted)
	}
	if m.clearedtables_reserved {
		edges = append(edges, user.EdgeTablesReserved)
	}
	if m.clearedtables_waited {
		edges = append(edges, user.EdgeTablesWaited)
	}
	if m.clearedstaffs {
		edges = append(edges, user.EdgeStaffs)
	}
	if m.clearedcreated_menus {
		edges = append(edges, user.EdgeCreatedMenus)
	}
	if m.clearedupdated_menus {
		edges = append(edges, user.EdgeUpdatedMenus)
	}
	if m.clearedplans {
		edges = append(edges, user.EdgePlans)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedtrainers {
		edges = append(edges, user.EdgeTrainers)
	}
	if m.clearedmemberOf {
		edges = append(edges, user.EdgeMemberOf)
	}
	if m.clearedcustomer {
		edges = append(edges, user.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserBusinesses:
		return m.cleareduserBusinesses
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeLikes:
		return m.clearedlikes
	case user.EdgePosts:
		return m.clearedposts
	case user.EdgeFollowedUsers:
		return m.clearedfollowedUsers
	case user.EdgeFollowerUsers:
		return m.clearedfollowerUsers
	case user.EdgeFollowedBusinesses:
		return m.clearedfollowedBusinesses
	case user.EdgeFollowerBusinesses:
		return m.clearedfollowerBusinesses
	case user.EdgeReviews:
		return m.clearedreviews
	case user.EdgeBookings:
		return m.clearedbookings
	case user.EdgeReservations:
		return m.clearedreservations
	case user.EdgeHelps:
		return m.clearedhelps
	case user.EdgeCategories:
		return m.clearedcategories
	case user.EdgePlaces:
		return m.clearedplaces
	case user.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	case user.EdgeOwnedEvents:
		return m.clearedownedEvents
	case user.EdgeUserFollowEvents:
		return m.cleareduserFollowEvents
	case user.EdgeFollowedPlaces:
		return m.clearedfollowedPlaces
	case user.EdgeLikedPlaces:
		return m.clearedlikedPlaces
	case user.EdgeRatings:
		return m.clearedratings
	case user.EdgeTransactionHistories:
		return m.clearedtransaction_histories
	case user.EdgeReservationBlocks:
		return m.clearedreservation_blocks
	case user.EdgeNotifications:
		return m.clearednotifications
	case user.EdgeWallet:
		return m.clearedwallet
	case user.EdgeOrders:
		return m.clearedorders
	case user.EdgeTablesCreated:
		return m.clearedtables_created
	case user.EdgeTablesUpdated:
		return m.clearedtables_updated
	case user.EdgeTablesDeleted:
		return m.clearedtables_deleted
	case user.EdgeTablesReserved:
		return m.clearedtables_reserved
	case user.EdgeTablesWaited:
		return m.clearedtables_waited
	case user.EdgeStaffs:
		return m.clearedstaffs
	case user.EdgeCreatedMenus:
		return m.clearedcreated_menus
	case user.EdgeUpdatedMenus:
		return m.clearedupdated_menus
	case user.EdgePlans:
		return m.clearedplans
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeTrainers:
		return m.clearedtrainers
	case user.EdgeMemberOf:
		return m.clearedmemberOf
	case user.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeOwnedEvents:
		m.ClearOwnedEvents()
		return nil
	case user.EdgeWallet:
		m.ClearWallet()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserBusinesses:
		m.ResetUserBusinesses()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeLikes:
		m.ResetLikes()
		return nil
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	case user.EdgeFollowedUsers:
		m.ResetFollowedUsers()
		return nil
	case user.EdgeFollowerUsers:
		m.ResetFollowerUsers()
		return nil
	case user.EdgeFollowedBusinesses:
		m.ResetFollowedBusinesses()
		return nil
	case user.EdgeFollowerBusinesses:
		m.ResetFollowerBusinesses()
		return nil
	case user.EdgeReviews:
		m.ResetReviews()
		return nil
	case user.EdgeBookings:
		m.ResetBookings()
		return nil
	case user.EdgeReservations:
		m.ResetReservations()
		return nil
	case user.EdgeHelps:
		m.ResetHelps()
		return nil
	case user.EdgeCategories:
		m.ResetCategories()
		return nil
	case user.EdgePlaces:
		m.ResetPlaces()
		return nil
	case user.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	case user.EdgeOwnedEvents:
		m.ResetOwnedEvents()
		return nil
	case user.EdgeUserFollowEvents:
		m.ResetUserFollowEvents()
		return nil
	case user.EdgeFollowedPlaces:
		m.ResetFollowedPlaces()
		return nil
	case user.EdgeLikedPlaces:
		m.ResetLikedPlaces()
		return nil
	case user.EdgeRatings:
		m.ResetRatings()
		return nil
	case user.EdgeTransactionHistories:
		m.ResetTransactionHistories()
		return nil
	case user.EdgeReservationBlocks:
		m.ResetReservationBlocks()
		return nil
	case user.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case user.EdgeWallet:
		m.ResetWallet()
		return nil
	case user.EdgeOrders:
		m.ResetOrders()
		return nil
	case user.EdgeTablesCreated:
		m.ResetTablesCreated()
		return nil
	case user.EdgeTablesUpdated:
		m.ResetTablesUpdated()
		return nil
	case user.EdgeTablesDeleted:
		m.ResetTablesDeleted()
		return nil
	case user.EdgeTablesReserved:
		m.ResetTablesReserved()
		return nil
	case user.EdgeTablesWaited:
		m.ResetTablesWaited()
		return nil
	case user.EdgeStaffs:
		m.ResetStaffs()
		return nil
	case user.EdgeCreatedMenus:
		m.ResetCreatedMenus()
		return nil
	case user.EdgeUpdatedMenus:
		m.ResetUpdatedMenus()
		return nil
	case user.EdgePlans:
		m.ResetPlans()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeTrainers:
		m.ResetTrainers()
		return nil
	case user.EdgeMemberOf:
		m.ResetMemberOf()
		return nil
	case user.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBusinessMutation represents an operation that mutates the UserBusiness nodes in the graph.
type UserBusinessMutation struct {
	config
	op              Op
	typ             string
	id              *string
	role            *string
	permissions     *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	done            bool
	oldValue        func(context.Context) (*UserBusiness, error)
	predicates      []predicate.UserBusiness
}

var _ ent.Mutation = (*UserBusinessMutation)(nil)

// userbusinessOption allows management of the mutation configuration using functional options.
type userbusinessOption func(*UserBusinessMutation)

// newUserBusinessMutation creates new mutation for the UserBusiness entity.
func newUserBusinessMutation(c config, op Op, opts ...userbusinessOption) *UserBusinessMutation {
	m := &UserBusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBusinessID sets the ID field of the mutation.
func withUserBusinessID(id string) userbusinessOption {
	return func(m *UserBusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBusiness
		)
		m.oldValue = func(ctx context.Context) (*UserBusiness, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBusiness.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBusiness sets the old UserBusiness of the mutation.
func withUserBusiness(node *UserBusiness) userbusinessOption {
	return func(m *UserBusinessMutation) {
		m.oldValue = func(context.Context) (*UserBusiness, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBusiness entities.
func (m *UserBusinessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBusiness.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *UserBusinessMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserBusinessMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserBusiness entity.
// If the UserBusiness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBusinessMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserBusinessMutation) ResetRole() {
	m.role = nil
}

// SetPermissions sets the "permissions" field.
func (m *UserBusinessMutation) SetPermissions(s string) {
	m.permissions = &s
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserBusinessMutation) Permissions() (r string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the UserBusiness entity.
// If the UserBusiness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBusinessMutation) OldPermissions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ClearPermissions clears the value of the "permissions" field.
func (m *UserBusinessMutation) ClearPermissions() {
	m.permissions = nil
	m.clearedFields[userbusiness.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *UserBusinessMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[userbusiness.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserBusinessMutation) ResetPermissions() {
	m.permissions = nil
	delete(m.clearedFields, userbusiness.FieldPermissions)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserBusinessMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBusinessMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBusinessMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserBusinessMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBusinessMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBusinessMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *UserBusinessMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *UserBusinessMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *UserBusinessMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *UserBusinessMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *UserBusinessMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *UserBusinessMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the UserBusinessMutation builder.
func (m *UserBusinessMutation) Where(ps ...predicate.UserBusiness) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBusiness, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBusiness).
func (m *UserBusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBusinessMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, userbusiness.FieldRole)
	}
	if m.permissions != nil {
		fields = append(fields, userbusiness.FieldPermissions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbusiness.FieldRole:
		return m.Role()
	case userbusiness.FieldPermissions:
		return m.Permissions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbusiness.FieldRole:
		return m.OldRole(ctx)
	case userbusiness.FieldPermissions:
		return m.OldPermissions(ctx)
	}
	return nil, fmt.Errorf("unknown UserBusiness field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbusiness.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case userbusiness.FieldPermissions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	}
	return fmt.Errorf("unknown UserBusiness field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBusiness numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userbusiness.FieldPermissions) {
		fields = append(fields, userbusiness.FieldPermissions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBusinessMutation) ClearField(name string) error {
	switch name {
	case userbusiness.FieldPermissions:
		m.ClearPermissions()
		return nil
	}
	return fmt.Errorf("unknown UserBusiness nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBusinessMutation) ResetField(name string) error {
	switch name {
	case userbusiness.FieldRole:
		m.ResetRole()
		return nil
	case userbusiness.FieldPermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown UserBusiness field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userbusiness.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, userbusiness.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userbusiness.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userbusiness.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userbusiness.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, userbusiness.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case userbusiness.EdgeUser:
		return m.cleareduser
	case userbusiness.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBusinessMutation) ClearEdge(name string) error {
	switch name {
	case userbusiness.EdgeUser:
		m.ClearUser()
		return nil
	case userbusiness.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserBusiness unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBusinessMutation) ResetEdge(name string) error {
	switch name {
	case userbusiness.EdgeUser:
		m.ResetUser()
		return nil
	case userbusiness.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserBusiness edge %s", name)
}

// UserFollowBusinessMutation represents an operation that mutates the UserFollowBusiness nodes in the graph.
type UserFollowBusinessMutation struct {
	config
	op              Op
	typ             string
	id              *string
	_CreatedAt      *time.Time
	_UpdatedAt      *time.Time
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	done            bool
	oldValue        func(context.Context) (*UserFollowBusiness, error)
	predicates      []predicate.UserFollowBusiness
}

var _ ent.Mutation = (*UserFollowBusinessMutation)(nil)

// userfollowbusinessOption allows management of the mutation configuration using functional options.
type userfollowbusinessOption func(*UserFollowBusinessMutation)

// newUserFollowBusinessMutation creates new mutation for the UserFollowBusiness entity.
func newUserFollowBusinessMutation(c config, op Op, opts ...userfollowbusinessOption) *UserFollowBusinessMutation {
	m := &UserFollowBusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowBusinessID sets the ID field of the mutation.
func withUserFollowBusinessID(id string) userfollowbusinessOption {
	return func(m *UserFollowBusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowBusiness
		)
		m.oldValue = func(ctx context.Context) (*UserFollowBusiness, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowBusiness.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowBusiness sets the old UserFollowBusiness of the mutation.
func withUserFollowBusiness(node *UserFollowBusiness) userfollowbusinessOption {
	return func(m *UserFollowBusinessMutation) {
		m.oldValue = func(context.Context) (*UserFollowBusiness, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowBusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowBusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFollowBusiness entities.
func (m *UserFollowBusinessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowBusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowBusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowBusiness.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *UserFollowBusinessMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *UserFollowBusinessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the UserFollowBusiness entity.
// If the UserFollowBusiness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowBusinessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *UserFollowBusinessMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *UserFollowBusinessMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *UserFollowBusinessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the UserFollowBusiness entity.
// If the UserFollowBusiness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowBusinessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *UserFollowBusinessMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserFollowBusinessMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFollowBusinessMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFollowBusinessMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserFollowBusinessMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFollowBusinessMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFollowBusinessMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *UserFollowBusinessMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *UserFollowBusinessMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *UserFollowBusinessMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *UserFollowBusinessMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *UserFollowBusinessMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *UserFollowBusinessMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the UserFollowBusinessMutation builder.
func (m *UserFollowBusinessMutation) Where(ps ...predicate.UserFollowBusiness) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowBusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowBusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowBusiness, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowBusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowBusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowBusiness).
func (m *UserFollowBusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowBusinessMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreatedAt != nil {
		fields = append(fields, userfollowbusiness.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, userfollowbusiness.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowBusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfollowbusiness.FieldCreatedAt:
		return m.CreatedAt()
	case userfollowbusiness.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowBusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfollowbusiness.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfollowbusiness.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserFollowBusiness field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowBusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfollowbusiness.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfollowbusiness.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserFollowBusiness field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowBusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowBusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowBusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFollowBusiness numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowBusinessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowBusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowBusinessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFollowBusiness nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowBusinessMutation) ResetField(name string) error {
	switch name {
	case userfollowbusiness.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfollowbusiness.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserFollowBusiness field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowBusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userfollowbusiness.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, userfollowbusiness.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowBusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfollowbusiness.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userfollowbusiness.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowBusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowBusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowBusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userfollowbusiness.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, userfollowbusiness.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowBusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case userfollowbusiness.EdgeUser:
		return m.cleareduser
	case userfollowbusiness.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowBusinessMutation) ClearEdge(name string) error {
	switch name {
	case userfollowbusiness.EdgeUser:
		m.ClearUser()
		return nil
	case userfollowbusiness.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserFollowBusiness unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowBusinessMutation) ResetEdge(name string) error {
	switch name {
	case userfollowbusiness.EdgeUser:
		m.ResetUser()
		return nil
	case userfollowbusiness.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserFollowBusiness edge %s", name)
}

// UserFollowEventMutation represents an operation that mutates the UserFollowEvent nodes in the graph.
type UserFollowEventMutation struct {
	config
	op            Op
	typ           string
	id            *string
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	event         *string
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*UserFollowEvent, error)
	predicates    []predicate.UserFollowEvent
}

var _ ent.Mutation = (*UserFollowEventMutation)(nil)

// userfolloweventOption allows management of the mutation configuration using functional options.
type userfolloweventOption func(*UserFollowEventMutation)

// newUserFollowEventMutation creates new mutation for the UserFollowEvent entity.
func newUserFollowEventMutation(c config, op Op, opts ...userfolloweventOption) *UserFollowEventMutation {
	m := &UserFollowEventMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowEventID sets the ID field of the mutation.
func withUserFollowEventID(id string) userfolloweventOption {
	return func(m *UserFollowEventMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowEvent
		)
		m.oldValue = func(ctx context.Context) (*UserFollowEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowEvent sets the old UserFollowEvent of the mutation.
func withUserFollowEvent(node *UserFollowEvent) userfolloweventOption {
	return func(m *UserFollowEventMutation) {
		m.oldValue = func(context.Context) (*UserFollowEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFollowEvent entities.
func (m *UserFollowEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserFollowEventMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserFollowEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserFollowEvent entity.
// If the UserFollowEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserFollowEventMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserFollowEventMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserFollowEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserFollowEvent entity.
// If the UserFollowEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserFollowEventMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserFollowEventMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFollowEventMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFollowEventMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserFollowEventMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFollowEventMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFollowEventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *UserFollowEventMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *UserFollowEventMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *UserFollowEventMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *UserFollowEventMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *UserFollowEventMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *UserFollowEventMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the UserFollowEventMutation builder.
func (m *UserFollowEventMutation) Where(ps ...predicate.UserFollowEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowEvent).
func (m *UserFollowEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowEventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.createdAt != nil {
		fields = append(fields, userfollowevent.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, userfollowevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfollowevent.FieldCreatedAt:
		return m.CreatedAt()
	case userfollowevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfollowevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfollowevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserFollowEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfollowevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfollowevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserFollowEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFollowEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFollowEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowEventMutation) ResetField(name string) error {
	switch name {
	case userfollowevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfollowevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserFollowEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userfollowevent.EdgeUser)
	}
	if m.event != nil {
		edges = append(edges, userfollowevent.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfollowevent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userfollowevent.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userfollowevent.EdgeUser)
	}
	if m.clearedevent {
		edges = append(edges, userfollowevent.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowEventMutation) EdgeCleared(name string) bool {
	switch name {
	case userfollowevent.EdgeUser:
		return m.cleareduser
	case userfollowevent.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowEventMutation) ClearEdge(name string) error {
	switch name {
	case userfollowevent.EdgeUser:
		m.ClearUser()
		return nil
	case userfollowevent.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown UserFollowEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowEventMutation) ResetEdge(name string) error {
	switch name {
	case userfollowevent.EdgeUser:
		m.ResetUser()
		return nil
	case userfollowevent.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown UserFollowEvent edge %s", name)
}

// UserFollowPlaceMutation represents an operation that mutates the UserFollowPlace nodes in the graph.
type UserFollowPlaceMutation struct {
	config
	op            Op
	typ           string
	id            *string
	_CreatedAt    *time.Time
	_UpdatedAt    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	place         *string
	clearedplace  bool
	done          bool
	oldValue      func(context.Context) (*UserFollowPlace, error)
	predicates    []predicate.UserFollowPlace
}

var _ ent.Mutation = (*UserFollowPlaceMutation)(nil)

// userfollowplaceOption allows management of the mutation configuration using functional options.
type userfollowplaceOption func(*UserFollowPlaceMutation)

// newUserFollowPlaceMutation creates new mutation for the UserFollowPlace entity.
func newUserFollowPlaceMutation(c config, op Op, opts ...userfollowplaceOption) *UserFollowPlaceMutation {
	m := &UserFollowPlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowPlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowPlaceID sets the ID field of the mutation.
func withUserFollowPlaceID(id string) userfollowplaceOption {
	return func(m *UserFollowPlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowPlace
		)
		m.oldValue = func(ctx context.Context) (*UserFollowPlace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowPlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowPlace sets the old UserFollowPlace of the mutation.
func withUserFollowPlace(node *UserFollowPlace) userfollowplaceOption {
	return func(m *UserFollowPlaceMutation) {
		m.oldValue = func(context.Context) (*UserFollowPlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowPlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowPlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFollowPlace entities.
func (m *UserFollowPlaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowPlaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowPlaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowPlace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *UserFollowPlaceMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *UserFollowPlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the UserFollowPlace entity.
// If the UserFollowPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowPlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *UserFollowPlaceMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *UserFollowPlaceMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *UserFollowPlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the UserFollowPlace entity.
// If the UserFollowPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowPlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *UserFollowPlaceMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserFollowPlaceMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFollowPlaceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFollowPlaceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserFollowPlaceMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFollowPlaceMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFollowPlaceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *UserFollowPlaceMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *UserFollowPlaceMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *UserFollowPlaceMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *UserFollowPlaceMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *UserFollowPlaceMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *UserFollowPlaceMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// Where appends a list predicates to the UserFollowPlaceMutation builder.
func (m *UserFollowPlaceMutation) Where(ps ...predicate.UserFollowPlace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowPlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowPlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowPlace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowPlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowPlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowPlace).
func (m *UserFollowPlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowPlaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreatedAt != nil {
		fields = append(fields, userfollowplace.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, userfollowplace.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowPlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfollowplace.FieldCreatedAt:
		return m.CreatedAt()
	case userfollowplace.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowPlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfollowplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfollowplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserFollowPlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowPlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfollowplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfollowplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserFollowPlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowPlaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowPlaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowPlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFollowPlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowPlaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowPlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowPlaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFollowPlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowPlaceMutation) ResetField(name string) error {
	switch name {
	case userfollowplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfollowplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserFollowPlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowPlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userfollowplace.EdgeUser)
	}
	if m.place != nil {
		edges = append(edges, userfollowplace.EdgePlace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowPlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfollowplace.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userfollowplace.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowPlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowPlaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowPlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userfollowplace.EdgeUser)
	}
	if m.clearedplace {
		edges = append(edges, userfollowplace.EdgePlace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowPlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case userfollowplace.EdgeUser:
		return m.cleareduser
	case userfollowplace.EdgePlace:
		return m.clearedplace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowPlaceMutation) ClearEdge(name string) error {
	switch name {
	case userfollowplace.EdgeUser:
		m.ClearUser()
		return nil
	case userfollowplace.EdgePlace:
		m.ClearPlace()
		return nil
	}
	return fmt.Errorf("unknown UserFollowPlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowPlaceMutation) ResetEdge(name string) error {
	switch name {
	case userfollowplace.EdgeUser:
		m.ResetUser()
		return nil
	case userfollowplace.EdgePlace:
		m.ResetPlace()
		return nil
	}
	return fmt.Errorf("unknown UserFollowPlace edge %s", name)
}

// UserFollowUserMutation represents an operation that mutates the UserFollowUser nodes in the graph.
type UserFollowUserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	_CreatedAt      *time.Time
	_UpdatedAt      *time.Time
	clearedFields   map[string]struct{}
	follower        *string
	clearedfollower bool
	followed        *string
	clearedfollowed bool
	done            bool
	oldValue        func(context.Context) (*UserFollowUser, error)
	predicates      []predicate.UserFollowUser
}

var _ ent.Mutation = (*UserFollowUserMutation)(nil)

// userfollowuserOption allows management of the mutation configuration using functional options.
type userfollowuserOption func(*UserFollowUserMutation)

// newUserFollowUserMutation creates new mutation for the UserFollowUser entity.
func newUserFollowUserMutation(c config, op Op, opts ...userfollowuserOption) *UserFollowUserMutation {
	m := &UserFollowUserMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowUserID sets the ID field of the mutation.
func withUserFollowUserID(id string) userfollowuserOption {
	return func(m *UserFollowUserMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowUser
		)
		m.oldValue = func(ctx context.Context) (*UserFollowUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowUser sets the old UserFollowUser of the mutation.
func withUserFollowUser(node *UserFollowUser) userfollowuserOption {
	return func(m *UserFollowUserMutation) {
		m.oldValue = func(context.Context) (*UserFollowUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFollowUser entities.
func (m *UserFollowUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *UserFollowUserMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *UserFollowUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the UserFollowUser entity.
// If the UserFollowUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *UserFollowUserMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *UserFollowUserMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *UserFollowUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the UserFollowUser entity.
// If the UserFollowUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *UserFollowUserMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetFollowerID sets the "follower" edge to the User entity by id.
func (m *UserFollowUserMutation) SetFollowerID(id string) {
	m.follower = &id
}

// ClearFollower clears the "follower" edge to the User entity.
func (m *UserFollowUserMutation) ClearFollower() {
	m.clearedfollower = true
}

// FollowerCleared reports if the "follower" edge to the User entity was cleared.
func (m *UserFollowUserMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// FollowerID returns the "follower" edge ID in the mutation.
func (m *UserFollowUserMutation) FollowerID() (id string, exists bool) {
	if m.follower != nil {
		return *m.follower, true
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *UserFollowUserMutation) FollowerIDs() (ids []string) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *UserFollowUserMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFollowedID sets the "followed" edge to the User entity by id.
func (m *UserFollowUserMutation) SetFollowedID(id string) {
	m.followed = &id
}

// ClearFollowed clears the "followed" edge to the User entity.
func (m *UserFollowUserMutation) ClearFollowed() {
	m.clearedfollowed = true
}

// FollowedCleared reports if the "followed" edge to the User entity was cleared.
func (m *UserFollowUserMutation) FollowedCleared() bool {
	return m.clearedfollowed
}

// FollowedID returns the "followed" edge ID in the mutation.
func (m *UserFollowUserMutation) FollowedID() (id string, exists bool) {
	if m.followed != nil {
		return *m.followed, true
	}
	return
}

// FollowedIDs returns the "followed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowedID instead. It exists only for internal usage by the builders.
func (m *UserFollowUserMutation) FollowedIDs() (ids []string) {
	if id := m.followed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowed resets all changes to the "followed" edge.
func (m *UserFollowUserMutation) ResetFollowed() {
	m.followed = nil
	m.clearedfollowed = false
}

// Where appends a list predicates to the UserFollowUserMutation builder.
func (m *UserFollowUserMutation) Where(ps ...predicate.UserFollowUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowUser).
func (m *UserFollowUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowUserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreatedAt != nil {
		fields = append(fields, userfollowuser.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, userfollowuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfollowuser.FieldCreatedAt:
		return m.CreatedAt()
	case userfollowuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfollowuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfollowuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserFollowUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfollowuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfollowuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserFollowUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFollowUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFollowUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowUserMutation) ResetField(name string) error {
	switch name {
	case userfollowuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfollowuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserFollowUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, userfollowuser.EdgeFollower)
	}
	if m.followed != nil {
		edges = append(edges, userfollowuser.EdgeFollowed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfollowuser.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case userfollowuser.EdgeFollowed:
		if id := m.followed; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, userfollowuser.EdgeFollower)
	}
	if m.clearedfollowed {
		edges = append(edges, userfollowuser.EdgeFollowed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowUserMutation) EdgeCleared(name string) bool {
	switch name {
	case userfollowuser.EdgeFollower:
		return m.clearedfollower
	case userfollowuser.EdgeFollowed:
		return m.clearedfollowed
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowUserMutation) ClearEdge(name string) error {
	switch name {
	case userfollowuser.EdgeFollower:
		m.ClearFollower()
		return nil
	case userfollowuser.EdgeFollowed:
		m.ClearFollowed()
		return nil
	}
	return fmt.Errorf("unknown UserFollowUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowUserMutation) ResetEdge(name string) error {
	switch name {
	case userfollowuser.EdgeFollower:
		m.ResetFollower()
		return nil
	case userfollowuser.EdgeFollowed:
		m.ResetFollowed()
		return nil
	}
	return fmt.Errorf("unknown UserFollowUser edge %s", name)
}

// UserLikePlaceMutation represents an operation that mutates the UserLikePlace nodes in the graph.
type UserLikePlaceMutation struct {
	config
	op            Op
	typ           string
	id            *string
	_CreatedAt    *time.Time
	_UpdatedAt    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	place         *string
	clearedplace  bool
	done          bool
	oldValue      func(context.Context) (*UserLikePlace, error)
	predicates    []predicate.UserLikePlace
}

var _ ent.Mutation = (*UserLikePlaceMutation)(nil)

// userlikeplaceOption allows management of the mutation configuration using functional options.
type userlikeplaceOption func(*UserLikePlaceMutation)

// newUserLikePlaceMutation creates new mutation for the UserLikePlace entity.
func newUserLikePlaceMutation(c config, op Op, opts ...userlikeplaceOption) *UserLikePlaceMutation {
	m := &UserLikePlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLikePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLikePlaceID sets the ID field of the mutation.
func withUserLikePlaceID(id string) userlikeplaceOption {
	return func(m *UserLikePlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLikePlace
		)
		m.oldValue = func(ctx context.Context) (*UserLikePlace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLikePlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLikePlace sets the old UserLikePlace of the mutation.
func withUserLikePlace(node *UserLikePlace) userlikeplaceOption {
	return func(m *UserLikePlaceMutation) {
		m.oldValue = func(context.Context) (*UserLikePlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLikePlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLikePlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLikePlace entities.
func (m *UserLikePlaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLikePlaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLikePlaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLikePlace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *UserLikePlaceMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *UserLikePlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the UserLikePlace entity.
// If the UserLikePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLikePlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *UserLikePlaceMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *UserLikePlaceMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *UserLikePlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the UserLikePlace entity.
// If the UserLikePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLikePlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *UserLikePlaceMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserLikePlaceMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLikePlaceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLikePlaceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserLikePlaceMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserLikePlaceMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLikePlaceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *UserLikePlaceMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *UserLikePlaceMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *UserLikePlaceMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *UserLikePlaceMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *UserLikePlaceMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *UserLikePlaceMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// Where appends a list predicates to the UserLikePlaceMutation builder.
func (m *UserLikePlaceMutation) Where(ps ...predicate.UserLikePlace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLikePlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLikePlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLikePlace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLikePlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLikePlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLikePlace).
func (m *UserLikePlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLikePlaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreatedAt != nil {
		fields = append(fields, userlikeplace.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, userlikeplace.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLikePlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlikeplace.FieldCreatedAt:
		return m.CreatedAt()
	case userlikeplace.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLikePlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlikeplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userlikeplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserLikePlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLikePlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlikeplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userlikeplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserLikePlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLikePlaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLikePlaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLikePlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLikePlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLikePlaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLikePlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLikePlaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserLikePlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLikePlaceMutation) ResetField(name string) error {
	switch name {
	case userlikeplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userlikeplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserLikePlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLikePlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userlikeplace.EdgeUser)
	}
	if m.place != nil {
		edges = append(edges, userlikeplace.EdgePlace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLikePlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userlikeplace.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userlikeplace.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLikePlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLikePlaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLikePlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userlikeplace.EdgeUser)
	}
	if m.clearedplace {
		edges = append(edges, userlikeplace.EdgePlace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLikePlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case userlikeplace.EdgeUser:
		return m.cleareduser
	case userlikeplace.EdgePlace:
		return m.clearedplace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLikePlaceMutation) ClearEdge(name string) error {
	switch name {
	case userlikeplace.EdgeUser:
		m.ClearUser()
		return nil
	case userlikeplace.EdgePlace:
		m.ClearPlace()
		return nil
	}
	return fmt.Errorf("unknown UserLikePlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLikePlaceMutation) ResetEdge(name string) error {
	switch name {
	case userlikeplace.EdgeUser:
		m.ResetUser()
		return nil
	case userlikeplace.EdgePlace:
		m.ResetPlace()
		return nil
	}
	return fmt.Errorf("unknown UserLikePlace edge %s", name)
}

// WebsiteMutation represents an operation that mutates the Website nodes in the graph.
type WebsiteMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *string
	domainName                           *string
	heading_text                         *string
	business_logo                        *string
	business_name                        *string
	banner_section_background_image      *string
	banner_section_background_color      *string
	banner_section_text                  *string
	three_items_section_heading_text     *string
	three_items_section_details_text     *string
	three_items_section_item_one_text    *string
	three_items_section_item_two_text    *string
	three_items_section_item_three_text  *string
	banner_two_section_background_image  *string
	banner_two_section_background_color  *string
	banner_two_left_section_heading_text *string
	banner_two_left_section_details_text *string
	banner_two_left_section_button_text  *string
	banner_two_left_section_button_link  *string
	banner_two_right_side_image          *string
	achievements_section                 *map[string]interface{}
	_Inventory_section_heading_text      *string
	creationDate                         *time.Time
	lastUpdated                          *time.Time
	title                                *string
	description                          *string
	keywords                             *string
	language                             *string
	logo                                 *string
	favicon                              *string
	facebook                             *string
	twitter                              *string
	instagram                            *string
	youtube                              *string
	linkedin                             *string
	pinterest                            *string
	mapCoordinates                       *map[string]interface{}
	longitude                            *string
	latitude                             *string
	address                              *string
	city                                 *string
	state                                *string
	country                              *string
	zipCode                              *string
	phoneNumber                          *string
	email                                *string
	metaTags                             *map[string]interface{}
	clearedFields                        map[string]struct{}
	business                             *string
	clearedbusiness                      bool
	customBlocks                         map[string]struct{}
	removedcustomBlocks                  map[string]struct{}
	clearedcustomBlocks                  bool
	assets                               map[string]struct{}
	removedassets                        map[string]struct{}
	clearedassets                        bool
	done                                 bool
	oldValue                             func(context.Context) (*Website, error)
	predicates                           []predicate.Website
}

var _ ent.Mutation = (*WebsiteMutation)(nil)

// websiteOption allows management of the mutation configuration using functional options.
type websiteOption func(*WebsiteMutation)

// newWebsiteMutation creates new mutation for the Website entity.
func newWebsiteMutation(c config, op Op, opts ...websiteOption) *WebsiteMutation {
	m := &WebsiteMutation{
		config:        c,
		op:            op,
		typ:           TypeWebsite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebsiteID sets the ID field of the mutation.
func withWebsiteID(id string) websiteOption {
	return func(m *WebsiteMutation) {
		var (
			err   error
			once  sync.Once
			value *Website
		)
		m.oldValue = func(ctx context.Context) (*Website, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Website.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebsite sets the old Website of the mutation.
func withWebsite(node *Website) websiteOption {
	return func(m *WebsiteMutation) {
		m.oldValue = func(context.Context) (*Website, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebsiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebsiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Website entities.
func (m *WebsiteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebsiteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebsiteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Website.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDomainName sets the "domainName" field.
func (m *WebsiteMutation) SetDomainName(s string) {
	m.domainName = &s
}

// DomainName returns the value of the "domainName" field in the mutation.
func (m *WebsiteMutation) DomainName() (r string, exists bool) {
	v := m.domainName
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainName returns the old "domainName" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldDomainName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainName: %w", err)
	}
	return oldValue.DomainName, nil
}

// ResetDomainName resets all changes to the "domainName" field.
func (m *WebsiteMutation) ResetDomainName() {
	m.domainName = nil
}

// SetHeadingText sets the "heading_text" field.
func (m *WebsiteMutation) SetHeadingText(s string) {
	m.heading_text = &s
}

// HeadingText returns the value of the "heading_text" field in the mutation.
func (m *WebsiteMutation) HeadingText() (r string, exists bool) {
	v := m.heading_text
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadingText returns the old "heading_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldHeadingText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeadingText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeadingText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadingText: %w", err)
	}
	return oldValue.HeadingText, nil
}

// ClearHeadingText clears the value of the "heading_text" field.
func (m *WebsiteMutation) ClearHeadingText() {
	m.heading_text = nil
	m.clearedFields[website.FieldHeadingText] = struct{}{}
}

// HeadingTextCleared returns if the "heading_text" field was cleared in this mutation.
func (m *WebsiteMutation) HeadingTextCleared() bool {
	_, ok := m.clearedFields[website.FieldHeadingText]
	return ok
}

// ResetHeadingText resets all changes to the "heading_text" field.
func (m *WebsiteMutation) ResetHeadingText() {
	m.heading_text = nil
	delete(m.clearedFields, website.FieldHeadingText)
}

// SetBusinessLogo sets the "business_logo" field.
func (m *WebsiteMutation) SetBusinessLogo(s string) {
	m.business_logo = &s
}

// BusinessLogo returns the value of the "business_logo" field in the mutation.
func (m *WebsiteMutation) BusinessLogo() (r string, exists bool) {
	v := m.business_logo
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessLogo returns the old "business_logo" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBusinessLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessLogo: %w", err)
	}
	return oldValue.BusinessLogo, nil
}

// ClearBusinessLogo clears the value of the "business_logo" field.
func (m *WebsiteMutation) ClearBusinessLogo() {
	m.business_logo = nil
	m.clearedFields[website.FieldBusinessLogo] = struct{}{}
}

// BusinessLogoCleared returns if the "business_logo" field was cleared in this mutation.
func (m *WebsiteMutation) BusinessLogoCleared() bool {
	_, ok := m.clearedFields[website.FieldBusinessLogo]
	return ok
}

// ResetBusinessLogo resets all changes to the "business_logo" field.
func (m *WebsiteMutation) ResetBusinessLogo() {
	m.business_logo = nil
	delete(m.clearedFields, website.FieldBusinessLogo)
}

// SetBusinessName sets the "business_name" field.
func (m *WebsiteMutation) SetBusinessName(s string) {
	m.business_name = &s
}

// BusinessName returns the value of the "business_name" field in the mutation.
func (m *WebsiteMutation) BusinessName() (r string, exists bool) {
	v := m.business_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessName returns the old "business_name" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBusinessName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessName: %w", err)
	}
	return oldValue.BusinessName, nil
}

// ClearBusinessName clears the value of the "business_name" field.
func (m *WebsiteMutation) ClearBusinessName() {
	m.business_name = nil
	m.clearedFields[website.FieldBusinessName] = struct{}{}
}

// BusinessNameCleared returns if the "business_name" field was cleared in this mutation.
func (m *WebsiteMutation) BusinessNameCleared() bool {
	_, ok := m.clearedFields[website.FieldBusinessName]
	return ok
}

// ResetBusinessName resets all changes to the "business_name" field.
func (m *WebsiteMutation) ResetBusinessName() {
	m.business_name = nil
	delete(m.clearedFields, website.FieldBusinessName)
}

// SetBannerSectionBackgroundImage sets the "banner_section_background_image" field.
func (m *WebsiteMutation) SetBannerSectionBackgroundImage(s string) {
	m.banner_section_background_image = &s
}

// BannerSectionBackgroundImage returns the value of the "banner_section_background_image" field in the mutation.
func (m *WebsiteMutation) BannerSectionBackgroundImage() (r string, exists bool) {
	v := m.banner_section_background_image
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerSectionBackgroundImage returns the old "banner_section_background_image" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerSectionBackgroundImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerSectionBackgroundImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerSectionBackgroundImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerSectionBackgroundImage: %w", err)
	}
	return oldValue.BannerSectionBackgroundImage, nil
}

// ClearBannerSectionBackgroundImage clears the value of the "banner_section_background_image" field.
func (m *WebsiteMutation) ClearBannerSectionBackgroundImage() {
	m.banner_section_background_image = nil
	m.clearedFields[website.FieldBannerSectionBackgroundImage] = struct{}{}
}

// BannerSectionBackgroundImageCleared returns if the "banner_section_background_image" field was cleared in this mutation.
func (m *WebsiteMutation) BannerSectionBackgroundImageCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerSectionBackgroundImage]
	return ok
}

// ResetBannerSectionBackgroundImage resets all changes to the "banner_section_background_image" field.
func (m *WebsiteMutation) ResetBannerSectionBackgroundImage() {
	m.banner_section_background_image = nil
	delete(m.clearedFields, website.FieldBannerSectionBackgroundImage)
}

// SetBannerSectionBackgroundColor sets the "banner_section_background_color" field.
func (m *WebsiteMutation) SetBannerSectionBackgroundColor(s string) {
	m.banner_section_background_color = &s
}

// BannerSectionBackgroundColor returns the value of the "banner_section_background_color" field in the mutation.
func (m *WebsiteMutation) BannerSectionBackgroundColor() (r string, exists bool) {
	v := m.banner_section_background_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerSectionBackgroundColor returns the old "banner_section_background_color" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerSectionBackgroundColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerSectionBackgroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerSectionBackgroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerSectionBackgroundColor: %w", err)
	}
	return oldValue.BannerSectionBackgroundColor, nil
}

// ClearBannerSectionBackgroundColor clears the value of the "banner_section_background_color" field.
func (m *WebsiteMutation) ClearBannerSectionBackgroundColor() {
	m.banner_section_background_color = nil
	m.clearedFields[website.FieldBannerSectionBackgroundColor] = struct{}{}
}

// BannerSectionBackgroundColorCleared returns if the "banner_section_background_color" field was cleared in this mutation.
func (m *WebsiteMutation) BannerSectionBackgroundColorCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerSectionBackgroundColor]
	return ok
}

// ResetBannerSectionBackgroundColor resets all changes to the "banner_section_background_color" field.
func (m *WebsiteMutation) ResetBannerSectionBackgroundColor() {
	m.banner_section_background_color = nil
	delete(m.clearedFields, website.FieldBannerSectionBackgroundColor)
}

// SetBannerSectionText sets the "banner_section_text" field.
func (m *WebsiteMutation) SetBannerSectionText(s string) {
	m.banner_section_text = &s
}

// BannerSectionText returns the value of the "banner_section_text" field in the mutation.
func (m *WebsiteMutation) BannerSectionText() (r string, exists bool) {
	v := m.banner_section_text
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerSectionText returns the old "banner_section_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerSectionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerSectionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerSectionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerSectionText: %w", err)
	}
	return oldValue.BannerSectionText, nil
}

// ClearBannerSectionText clears the value of the "banner_section_text" field.
func (m *WebsiteMutation) ClearBannerSectionText() {
	m.banner_section_text = nil
	m.clearedFields[website.FieldBannerSectionText] = struct{}{}
}

// BannerSectionTextCleared returns if the "banner_section_text" field was cleared in this mutation.
func (m *WebsiteMutation) BannerSectionTextCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerSectionText]
	return ok
}

// ResetBannerSectionText resets all changes to the "banner_section_text" field.
func (m *WebsiteMutation) ResetBannerSectionText() {
	m.banner_section_text = nil
	delete(m.clearedFields, website.FieldBannerSectionText)
}

// SetThreeItemsSectionHeadingText sets the "three_items_section_heading_text" field.
func (m *WebsiteMutation) SetThreeItemsSectionHeadingText(s string) {
	m.three_items_section_heading_text = &s
}

// ThreeItemsSectionHeadingText returns the value of the "three_items_section_heading_text" field in the mutation.
func (m *WebsiteMutation) ThreeItemsSectionHeadingText() (r string, exists bool) {
	v := m.three_items_section_heading_text
	if v == nil {
		return
	}
	return *v, true
}

// OldThreeItemsSectionHeadingText returns the old "three_items_section_heading_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldThreeItemsSectionHeadingText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreeItemsSectionHeadingText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreeItemsSectionHeadingText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreeItemsSectionHeadingText: %w", err)
	}
	return oldValue.ThreeItemsSectionHeadingText, nil
}

// ClearThreeItemsSectionHeadingText clears the value of the "three_items_section_heading_text" field.
func (m *WebsiteMutation) ClearThreeItemsSectionHeadingText() {
	m.three_items_section_heading_text = nil
	m.clearedFields[website.FieldThreeItemsSectionHeadingText] = struct{}{}
}

// ThreeItemsSectionHeadingTextCleared returns if the "three_items_section_heading_text" field was cleared in this mutation.
func (m *WebsiteMutation) ThreeItemsSectionHeadingTextCleared() bool {
	_, ok := m.clearedFields[website.FieldThreeItemsSectionHeadingText]
	return ok
}

// ResetThreeItemsSectionHeadingText resets all changes to the "three_items_section_heading_text" field.
func (m *WebsiteMutation) ResetThreeItemsSectionHeadingText() {
	m.three_items_section_heading_text = nil
	delete(m.clearedFields, website.FieldThreeItemsSectionHeadingText)
}

// SetThreeItemsSectionDetailsText sets the "three_items_section_details_text" field.
func (m *WebsiteMutation) SetThreeItemsSectionDetailsText(s string) {
	m.three_items_section_details_text = &s
}

// ThreeItemsSectionDetailsText returns the value of the "three_items_section_details_text" field in the mutation.
func (m *WebsiteMutation) ThreeItemsSectionDetailsText() (r string, exists bool) {
	v := m.three_items_section_details_text
	if v == nil {
		return
	}
	return *v, true
}

// OldThreeItemsSectionDetailsText returns the old "three_items_section_details_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldThreeItemsSectionDetailsText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreeItemsSectionDetailsText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreeItemsSectionDetailsText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreeItemsSectionDetailsText: %w", err)
	}
	return oldValue.ThreeItemsSectionDetailsText, nil
}

// ClearThreeItemsSectionDetailsText clears the value of the "three_items_section_details_text" field.
func (m *WebsiteMutation) ClearThreeItemsSectionDetailsText() {
	m.three_items_section_details_text = nil
	m.clearedFields[website.FieldThreeItemsSectionDetailsText] = struct{}{}
}

// ThreeItemsSectionDetailsTextCleared returns if the "three_items_section_details_text" field was cleared in this mutation.
func (m *WebsiteMutation) ThreeItemsSectionDetailsTextCleared() bool {
	_, ok := m.clearedFields[website.FieldThreeItemsSectionDetailsText]
	return ok
}

// ResetThreeItemsSectionDetailsText resets all changes to the "three_items_section_details_text" field.
func (m *WebsiteMutation) ResetThreeItemsSectionDetailsText() {
	m.three_items_section_details_text = nil
	delete(m.clearedFields, website.FieldThreeItemsSectionDetailsText)
}

// SetThreeItemsSectionItemOneText sets the "three_items_section_item_one_text" field.
func (m *WebsiteMutation) SetThreeItemsSectionItemOneText(s string) {
	m.three_items_section_item_one_text = &s
}

// ThreeItemsSectionItemOneText returns the value of the "three_items_section_item_one_text" field in the mutation.
func (m *WebsiteMutation) ThreeItemsSectionItemOneText() (r string, exists bool) {
	v := m.three_items_section_item_one_text
	if v == nil {
		return
	}
	return *v, true
}

// OldThreeItemsSectionItemOneText returns the old "three_items_section_item_one_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldThreeItemsSectionItemOneText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreeItemsSectionItemOneText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreeItemsSectionItemOneText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreeItemsSectionItemOneText: %w", err)
	}
	return oldValue.ThreeItemsSectionItemOneText, nil
}

// ClearThreeItemsSectionItemOneText clears the value of the "three_items_section_item_one_text" field.
func (m *WebsiteMutation) ClearThreeItemsSectionItemOneText() {
	m.three_items_section_item_one_text = nil
	m.clearedFields[website.FieldThreeItemsSectionItemOneText] = struct{}{}
}

// ThreeItemsSectionItemOneTextCleared returns if the "three_items_section_item_one_text" field was cleared in this mutation.
func (m *WebsiteMutation) ThreeItemsSectionItemOneTextCleared() bool {
	_, ok := m.clearedFields[website.FieldThreeItemsSectionItemOneText]
	return ok
}

// ResetThreeItemsSectionItemOneText resets all changes to the "three_items_section_item_one_text" field.
func (m *WebsiteMutation) ResetThreeItemsSectionItemOneText() {
	m.three_items_section_item_one_text = nil
	delete(m.clearedFields, website.FieldThreeItemsSectionItemOneText)
}

// SetThreeItemsSectionItemTwoText sets the "three_items_section_item_two_text" field.
func (m *WebsiteMutation) SetThreeItemsSectionItemTwoText(s string) {
	m.three_items_section_item_two_text = &s
}

// ThreeItemsSectionItemTwoText returns the value of the "three_items_section_item_two_text" field in the mutation.
func (m *WebsiteMutation) ThreeItemsSectionItemTwoText() (r string, exists bool) {
	v := m.three_items_section_item_two_text
	if v == nil {
		return
	}
	return *v, true
}

// OldThreeItemsSectionItemTwoText returns the old "three_items_section_item_two_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldThreeItemsSectionItemTwoText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreeItemsSectionItemTwoText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreeItemsSectionItemTwoText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreeItemsSectionItemTwoText: %w", err)
	}
	return oldValue.ThreeItemsSectionItemTwoText, nil
}

// ClearThreeItemsSectionItemTwoText clears the value of the "three_items_section_item_two_text" field.
func (m *WebsiteMutation) ClearThreeItemsSectionItemTwoText() {
	m.three_items_section_item_two_text = nil
	m.clearedFields[website.FieldThreeItemsSectionItemTwoText] = struct{}{}
}

// ThreeItemsSectionItemTwoTextCleared returns if the "three_items_section_item_two_text" field was cleared in this mutation.
func (m *WebsiteMutation) ThreeItemsSectionItemTwoTextCleared() bool {
	_, ok := m.clearedFields[website.FieldThreeItemsSectionItemTwoText]
	return ok
}

// ResetThreeItemsSectionItemTwoText resets all changes to the "three_items_section_item_two_text" field.
func (m *WebsiteMutation) ResetThreeItemsSectionItemTwoText() {
	m.three_items_section_item_two_text = nil
	delete(m.clearedFields, website.FieldThreeItemsSectionItemTwoText)
}

// SetThreeItemsSectionItemThreeText sets the "three_items_section_item_three_text" field.
func (m *WebsiteMutation) SetThreeItemsSectionItemThreeText(s string) {
	m.three_items_section_item_three_text = &s
}

// ThreeItemsSectionItemThreeText returns the value of the "three_items_section_item_three_text" field in the mutation.
func (m *WebsiteMutation) ThreeItemsSectionItemThreeText() (r string, exists bool) {
	v := m.three_items_section_item_three_text
	if v == nil {
		return
	}
	return *v, true
}

// OldThreeItemsSectionItemThreeText returns the old "three_items_section_item_three_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldThreeItemsSectionItemThreeText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreeItemsSectionItemThreeText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreeItemsSectionItemThreeText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreeItemsSectionItemThreeText: %w", err)
	}
	return oldValue.ThreeItemsSectionItemThreeText, nil
}

// ClearThreeItemsSectionItemThreeText clears the value of the "three_items_section_item_three_text" field.
func (m *WebsiteMutation) ClearThreeItemsSectionItemThreeText() {
	m.three_items_section_item_three_text = nil
	m.clearedFields[website.FieldThreeItemsSectionItemThreeText] = struct{}{}
}

// ThreeItemsSectionItemThreeTextCleared returns if the "three_items_section_item_three_text" field was cleared in this mutation.
func (m *WebsiteMutation) ThreeItemsSectionItemThreeTextCleared() bool {
	_, ok := m.clearedFields[website.FieldThreeItemsSectionItemThreeText]
	return ok
}

// ResetThreeItemsSectionItemThreeText resets all changes to the "three_items_section_item_three_text" field.
func (m *WebsiteMutation) ResetThreeItemsSectionItemThreeText() {
	m.three_items_section_item_three_text = nil
	delete(m.clearedFields, website.FieldThreeItemsSectionItemThreeText)
}

// SetBannerTwoSectionBackgroundImage sets the "banner_two_section_background_image" field.
func (m *WebsiteMutation) SetBannerTwoSectionBackgroundImage(s string) {
	m.banner_two_section_background_image = &s
}

// BannerTwoSectionBackgroundImage returns the value of the "banner_two_section_background_image" field in the mutation.
func (m *WebsiteMutation) BannerTwoSectionBackgroundImage() (r string, exists bool) {
	v := m.banner_two_section_background_image
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerTwoSectionBackgroundImage returns the old "banner_two_section_background_image" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerTwoSectionBackgroundImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerTwoSectionBackgroundImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerTwoSectionBackgroundImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerTwoSectionBackgroundImage: %w", err)
	}
	return oldValue.BannerTwoSectionBackgroundImage, nil
}

// ClearBannerTwoSectionBackgroundImage clears the value of the "banner_two_section_background_image" field.
func (m *WebsiteMutation) ClearBannerTwoSectionBackgroundImage() {
	m.banner_two_section_background_image = nil
	m.clearedFields[website.FieldBannerTwoSectionBackgroundImage] = struct{}{}
}

// BannerTwoSectionBackgroundImageCleared returns if the "banner_two_section_background_image" field was cleared in this mutation.
func (m *WebsiteMutation) BannerTwoSectionBackgroundImageCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerTwoSectionBackgroundImage]
	return ok
}

// ResetBannerTwoSectionBackgroundImage resets all changes to the "banner_two_section_background_image" field.
func (m *WebsiteMutation) ResetBannerTwoSectionBackgroundImage() {
	m.banner_two_section_background_image = nil
	delete(m.clearedFields, website.FieldBannerTwoSectionBackgroundImage)
}

// SetBannerTwoSectionBackgroundColor sets the "banner_two_section_background_color" field.
func (m *WebsiteMutation) SetBannerTwoSectionBackgroundColor(s string) {
	m.banner_two_section_background_color = &s
}

// BannerTwoSectionBackgroundColor returns the value of the "banner_two_section_background_color" field in the mutation.
func (m *WebsiteMutation) BannerTwoSectionBackgroundColor() (r string, exists bool) {
	v := m.banner_two_section_background_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerTwoSectionBackgroundColor returns the old "banner_two_section_background_color" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerTwoSectionBackgroundColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerTwoSectionBackgroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerTwoSectionBackgroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerTwoSectionBackgroundColor: %w", err)
	}
	return oldValue.BannerTwoSectionBackgroundColor, nil
}

// ClearBannerTwoSectionBackgroundColor clears the value of the "banner_two_section_background_color" field.
func (m *WebsiteMutation) ClearBannerTwoSectionBackgroundColor() {
	m.banner_two_section_background_color = nil
	m.clearedFields[website.FieldBannerTwoSectionBackgroundColor] = struct{}{}
}

// BannerTwoSectionBackgroundColorCleared returns if the "banner_two_section_background_color" field was cleared in this mutation.
func (m *WebsiteMutation) BannerTwoSectionBackgroundColorCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerTwoSectionBackgroundColor]
	return ok
}

// ResetBannerTwoSectionBackgroundColor resets all changes to the "banner_two_section_background_color" field.
func (m *WebsiteMutation) ResetBannerTwoSectionBackgroundColor() {
	m.banner_two_section_background_color = nil
	delete(m.clearedFields, website.FieldBannerTwoSectionBackgroundColor)
}

// SetBannerTwoLeftSectionHeadingText sets the "banner_two_left_section_heading_text" field.
func (m *WebsiteMutation) SetBannerTwoLeftSectionHeadingText(s string) {
	m.banner_two_left_section_heading_text = &s
}

// BannerTwoLeftSectionHeadingText returns the value of the "banner_two_left_section_heading_text" field in the mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionHeadingText() (r string, exists bool) {
	v := m.banner_two_left_section_heading_text
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerTwoLeftSectionHeadingText returns the old "banner_two_left_section_heading_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerTwoLeftSectionHeadingText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerTwoLeftSectionHeadingText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerTwoLeftSectionHeadingText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerTwoLeftSectionHeadingText: %w", err)
	}
	return oldValue.BannerTwoLeftSectionHeadingText, nil
}

// ClearBannerTwoLeftSectionHeadingText clears the value of the "banner_two_left_section_heading_text" field.
func (m *WebsiteMutation) ClearBannerTwoLeftSectionHeadingText() {
	m.banner_two_left_section_heading_text = nil
	m.clearedFields[website.FieldBannerTwoLeftSectionHeadingText] = struct{}{}
}

// BannerTwoLeftSectionHeadingTextCleared returns if the "banner_two_left_section_heading_text" field was cleared in this mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionHeadingTextCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerTwoLeftSectionHeadingText]
	return ok
}

// ResetBannerTwoLeftSectionHeadingText resets all changes to the "banner_two_left_section_heading_text" field.
func (m *WebsiteMutation) ResetBannerTwoLeftSectionHeadingText() {
	m.banner_two_left_section_heading_text = nil
	delete(m.clearedFields, website.FieldBannerTwoLeftSectionHeadingText)
}

// SetBannerTwoLeftSectionDetailsText sets the "banner_two_left_section_details_text" field.
func (m *WebsiteMutation) SetBannerTwoLeftSectionDetailsText(s string) {
	m.banner_two_left_section_details_text = &s
}

// BannerTwoLeftSectionDetailsText returns the value of the "banner_two_left_section_details_text" field in the mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionDetailsText() (r string, exists bool) {
	v := m.banner_two_left_section_details_text
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerTwoLeftSectionDetailsText returns the old "banner_two_left_section_details_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerTwoLeftSectionDetailsText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerTwoLeftSectionDetailsText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerTwoLeftSectionDetailsText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerTwoLeftSectionDetailsText: %w", err)
	}
	return oldValue.BannerTwoLeftSectionDetailsText, nil
}

// ClearBannerTwoLeftSectionDetailsText clears the value of the "banner_two_left_section_details_text" field.
func (m *WebsiteMutation) ClearBannerTwoLeftSectionDetailsText() {
	m.banner_two_left_section_details_text = nil
	m.clearedFields[website.FieldBannerTwoLeftSectionDetailsText] = struct{}{}
}

// BannerTwoLeftSectionDetailsTextCleared returns if the "banner_two_left_section_details_text" field was cleared in this mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionDetailsTextCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerTwoLeftSectionDetailsText]
	return ok
}

// ResetBannerTwoLeftSectionDetailsText resets all changes to the "banner_two_left_section_details_text" field.
func (m *WebsiteMutation) ResetBannerTwoLeftSectionDetailsText() {
	m.banner_two_left_section_details_text = nil
	delete(m.clearedFields, website.FieldBannerTwoLeftSectionDetailsText)
}

// SetBannerTwoLeftSectionButtonText sets the "banner_two_left_section_button_text" field.
func (m *WebsiteMutation) SetBannerTwoLeftSectionButtonText(s string) {
	m.banner_two_left_section_button_text = &s
}

// BannerTwoLeftSectionButtonText returns the value of the "banner_two_left_section_button_text" field in the mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionButtonText() (r string, exists bool) {
	v := m.banner_two_left_section_button_text
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerTwoLeftSectionButtonText returns the old "banner_two_left_section_button_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerTwoLeftSectionButtonText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerTwoLeftSectionButtonText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerTwoLeftSectionButtonText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerTwoLeftSectionButtonText: %w", err)
	}
	return oldValue.BannerTwoLeftSectionButtonText, nil
}

// ClearBannerTwoLeftSectionButtonText clears the value of the "banner_two_left_section_button_text" field.
func (m *WebsiteMutation) ClearBannerTwoLeftSectionButtonText() {
	m.banner_two_left_section_button_text = nil
	m.clearedFields[website.FieldBannerTwoLeftSectionButtonText] = struct{}{}
}

// BannerTwoLeftSectionButtonTextCleared returns if the "banner_two_left_section_button_text" field was cleared in this mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionButtonTextCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerTwoLeftSectionButtonText]
	return ok
}

// ResetBannerTwoLeftSectionButtonText resets all changes to the "banner_two_left_section_button_text" field.
func (m *WebsiteMutation) ResetBannerTwoLeftSectionButtonText() {
	m.banner_two_left_section_button_text = nil
	delete(m.clearedFields, website.FieldBannerTwoLeftSectionButtonText)
}

// SetBannerTwoLeftSectionButtonLink sets the "banner_two_left_section_button_link" field.
func (m *WebsiteMutation) SetBannerTwoLeftSectionButtonLink(s string) {
	m.banner_two_left_section_button_link = &s
}

// BannerTwoLeftSectionButtonLink returns the value of the "banner_two_left_section_button_link" field in the mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionButtonLink() (r string, exists bool) {
	v := m.banner_two_left_section_button_link
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerTwoLeftSectionButtonLink returns the old "banner_two_left_section_button_link" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerTwoLeftSectionButtonLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerTwoLeftSectionButtonLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerTwoLeftSectionButtonLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerTwoLeftSectionButtonLink: %w", err)
	}
	return oldValue.BannerTwoLeftSectionButtonLink, nil
}

// ClearBannerTwoLeftSectionButtonLink clears the value of the "banner_two_left_section_button_link" field.
func (m *WebsiteMutation) ClearBannerTwoLeftSectionButtonLink() {
	m.banner_two_left_section_button_link = nil
	m.clearedFields[website.FieldBannerTwoLeftSectionButtonLink] = struct{}{}
}

// BannerTwoLeftSectionButtonLinkCleared returns if the "banner_two_left_section_button_link" field was cleared in this mutation.
func (m *WebsiteMutation) BannerTwoLeftSectionButtonLinkCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerTwoLeftSectionButtonLink]
	return ok
}

// ResetBannerTwoLeftSectionButtonLink resets all changes to the "banner_two_left_section_button_link" field.
func (m *WebsiteMutation) ResetBannerTwoLeftSectionButtonLink() {
	m.banner_two_left_section_button_link = nil
	delete(m.clearedFields, website.FieldBannerTwoLeftSectionButtonLink)
}

// SetBannerTwoRightSideImage sets the "banner_two_right_side_image" field.
func (m *WebsiteMutation) SetBannerTwoRightSideImage(s string) {
	m.banner_two_right_side_image = &s
}

// BannerTwoRightSideImage returns the value of the "banner_two_right_side_image" field in the mutation.
func (m *WebsiteMutation) BannerTwoRightSideImage() (r string, exists bool) {
	v := m.banner_two_right_side_image
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerTwoRightSideImage returns the old "banner_two_right_side_image" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldBannerTwoRightSideImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerTwoRightSideImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerTwoRightSideImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerTwoRightSideImage: %w", err)
	}
	return oldValue.BannerTwoRightSideImage, nil
}

// ClearBannerTwoRightSideImage clears the value of the "banner_two_right_side_image" field.
func (m *WebsiteMutation) ClearBannerTwoRightSideImage() {
	m.banner_two_right_side_image = nil
	m.clearedFields[website.FieldBannerTwoRightSideImage] = struct{}{}
}

// BannerTwoRightSideImageCleared returns if the "banner_two_right_side_image" field was cleared in this mutation.
func (m *WebsiteMutation) BannerTwoRightSideImageCleared() bool {
	_, ok := m.clearedFields[website.FieldBannerTwoRightSideImage]
	return ok
}

// ResetBannerTwoRightSideImage resets all changes to the "banner_two_right_side_image" field.
func (m *WebsiteMutation) ResetBannerTwoRightSideImage() {
	m.banner_two_right_side_image = nil
	delete(m.clearedFields, website.FieldBannerTwoRightSideImage)
}

// SetAchievementsSection sets the "achievements_section" field.
func (m *WebsiteMutation) SetAchievementsSection(value map[string]interface{}) {
	m.achievements_section = &value
}

// AchievementsSection returns the value of the "achievements_section" field in the mutation.
func (m *WebsiteMutation) AchievementsSection() (r map[string]interface{}, exists bool) {
	v := m.achievements_section
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievementsSection returns the old "achievements_section" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldAchievementsSection(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievementsSection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievementsSection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievementsSection: %w", err)
	}
	return oldValue.AchievementsSection, nil
}

// ClearAchievementsSection clears the value of the "achievements_section" field.
func (m *WebsiteMutation) ClearAchievementsSection() {
	m.achievements_section = nil
	m.clearedFields[website.FieldAchievementsSection] = struct{}{}
}

// AchievementsSectionCleared returns if the "achievements_section" field was cleared in this mutation.
func (m *WebsiteMutation) AchievementsSectionCleared() bool {
	_, ok := m.clearedFields[website.FieldAchievementsSection]
	return ok
}

// ResetAchievementsSection resets all changes to the "achievements_section" field.
func (m *WebsiteMutation) ResetAchievementsSection() {
	m.achievements_section = nil
	delete(m.clearedFields, website.FieldAchievementsSection)
}

// SetInventorySectionHeadingText sets the "Inventory_section_heading_text" field.
func (m *WebsiteMutation) SetInventorySectionHeadingText(s string) {
	m._Inventory_section_heading_text = &s
}

// InventorySectionHeadingText returns the value of the "Inventory_section_heading_text" field in the mutation.
func (m *WebsiteMutation) InventorySectionHeadingText() (r string, exists bool) {
	v := m._Inventory_section_heading_text
	if v == nil {
		return
	}
	return *v, true
}

// OldInventorySectionHeadingText returns the old "Inventory_section_heading_text" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldInventorySectionHeadingText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventorySectionHeadingText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventorySectionHeadingText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventorySectionHeadingText: %w", err)
	}
	return oldValue.InventorySectionHeadingText, nil
}

// ClearInventorySectionHeadingText clears the value of the "Inventory_section_heading_text" field.
func (m *WebsiteMutation) ClearInventorySectionHeadingText() {
	m._Inventory_section_heading_text = nil
	m.clearedFields[website.FieldInventorySectionHeadingText] = struct{}{}
}

// InventorySectionHeadingTextCleared returns if the "Inventory_section_heading_text" field was cleared in this mutation.
func (m *WebsiteMutation) InventorySectionHeadingTextCleared() bool {
	_, ok := m.clearedFields[website.FieldInventorySectionHeadingText]
	return ok
}

// ResetInventorySectionHeadingText resets all changes to the "Inventory_section_heading_text" field.
func (m *WebsiteMutation) ResetInventorySectionHeadingText() {
	m._Inventory_section_heading_text = nil
	delete(m.clearedFields, website.FieldInventorySectionHeadingText)
}

// SetCreationDate sets the "creationDate" field.
func (m *WebsiteMutation) SetCreationDate(t time.Time) {
	m.creationDate = &t
}

// CreationDate returns the value of the "creationDate" field in the mutation.
func (m *WebsiteMutation) CreationDate() (r time.Time, exists bool) {
	v := m.creationDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationDate returns the old "creationDate" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldCreationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationDate: %w", err)
	}
	return oldValue.CreationDate, nil
}

// ResetCreationDate resets all changes to the "creationDate" field.
func (m *WebsiteMutation) ResetCreationDate() {
	m.creationDate = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *WebsiteMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *WebsiteMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *WebsiteMutation) ResetLastUpdated() {
	m.lastUpdated = nil
}

// SetTitle sets the "title" field.
func (m *WebsiteMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WebsiteMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *WebsiteMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[website.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *WebsiteMutation) TitleCleared() bool {
	_, ok := m.clearedFields[website.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *WebsiteMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, website.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *WebsiteMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WebsiteMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WebsiteMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[website.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WebsiteMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[website.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WebsiteMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, website.FieldDescription)
}

// SetKeywords sets the "keywords" field.
func (m *WebsiteMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *WebsiteMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ClearKeywords clears the value of the "keywords" field.
func (m *WebsiteMutation) ClearKeywords() {
	m.keywords = nil
	m.clearedFields[website.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *WebsiteMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[website.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *WebsiteMutation) ResetKeywords() {
	m.keywords = nil
	delete(m.clearedFields, website.FieldKeywords)
}

// SetLanguage sets the "language" field.
func (m *WebsiteMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *WebsiteMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *WebsiteMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[website.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *WebsiteMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[website.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *WebsiteMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, website.FieldLanguage)
}

// SetLogo sets the "logo" field.
func (m *WebsiteMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *WebsiteMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *WebsiteMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[website.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *WebsiteMutation) LogoCleared() bool {
	_, ok := m.clearedFields[website.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *WebsiteMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, website.FieldLogo)
}

// SetFavicon sets the "favicon" field.
func (m *WebsiteMutation) SetFavicon(s string) {
	m.favicon = &s
}

// Favicon returns the value of the "favicon" field in the mutation.
func (m *WebsiteMutation) Favicon() (r string, exists bool) {
	v := m.favicon
	if v == nil {
		return
	}
	return *v, true
}

// OldFavicon returns the old "favicon" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldFavicon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFavicon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFavicon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFavicon: %w", err)
	}
	return oldValue.Favicon, nil
}

// ClearFavicon clears the value of the "favicon" field.
func (m *WebsiteMutation) ClearFavicon() {
	m.favicon = nil
	m.clearedFields[website.FieldFavicon] = struct{}{}
}

// FaviconCleared returns if the "favicon" field was cleared in this mutation.
func (m *WebsiteMutation) FaviconCleared() bool {
	_, ok := m.clearedFields[website.FieldFavicon]
	return ok
}

// ResetFavicon resets all changes to the "favicon" field.
func (m *WebsiteMutation) ResetFavicon() {
	m.favicon = nil
	delete(m.clearedFields, website.FieldFavicon)
}

// SetFacebook sets the "facebook" field.
func (m *WebsiteMutation) SetFacebook(s string) {
	m.facebook = &s
}

// Facebook returns the value of the "facebook" field in the mutation.
func (m *WebsiteMutation) Facebook() (r string, exists bool) {
	v := m.facebook
	if v == nil {
		return
	}
	return *v, true
}

// OldFacebook returns the old "facebook" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldFacebook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacebook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacebook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacebook: %w", err)
	}
	return oldValue.Facebook, nil
}

// ClearFacebook clears the value of the "facebook" field.
func (m *WebsiteMutation) ClearFacebook() {
	m.facebook = nil
	m.clearedFields[website.FieldFacebook] = struct{}{}
}

// FacebookCleared returns if the "facebook" field was cleared in this mutation.
func (m *WebsiteMutation) FacebookCleared() bool {
	_, ok := m.clearedFields[website.FieldFacebook]
	return ok
}

// ResetFacebook resets all changes to the "facebook" field.
func (m *WebsiteMutation) ResetFacebook() {
	m.facebook = nil
	delete(m.clearedFields, website.FieldFacebook)
}

// SetTwitter sets the "twitter" field.
func (m *WebsiteMutation) SetTwitter(s string) {
	m.twitter = &s
}

// Twitter returns the value of the "twitter" field in the mutation.
func (m *WebsiteMutation) Twitter() (r string, exists bool) {
	v := m.twitter
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitter returns the old "twitter" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldTwitter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitter: %w", err)
	}
	return oldValue.Twitter, nil
}

// ClearTwitter clears the value of the "twitter" field.
func (m *WebsiteMutation) ClearTwitter() {
	m.twitter = nil
	m.clearedFields[website.FieldTwitter] = struct{}{}
}

// TwitterCleared returns if the "twitter" field was cleared in this mutation.
func (m *WebsiteMutation) TwitterCleared() bool {
	_, ok := m.clearedFields[website.FieldTwitter]
	return ok
}

// ResetTwitter resets all changes to the "twitter" field.
func (m *WebsiteMutation) ResetTwitter() {
	m.twitter = nil
	delete(m.clearedFields, website.FieldTwitter)
}

// SetInstagram sets the "instagram" field.
func (m *WebsiteMutation) SetInstagram(s string) {
	m.instagram = &s
}

// Instagram returns the value of the "instagram" field in the mutation.
func (m *WebsiteMutation) Instagram() (r string, exists bool) {
	v := m.instagram
	if v == nil {
		return
	}
	return *v, true
}

// OldInstagram returns the old "instagram" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldInstagram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstagram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstagram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstagram: %w", err)
	}
	return oldValue.Instagram, nil
}

// ClearInstagram clears the value of the "instagram" field.
func (m *WebsiteMutation) ClearInstagram() {
	m.instagram = nil
	m.clearedFields[website.FieldInstagram] = struct{}{}
}

// InstagramCleared returns if the "instagram" field was cleared in this mutation.
func (m *WebsiteMutation) InstagramCleared() bool {
	_, ok := m.clearedFields[website.FieldInstagram]
	return ok
}

// ResetInstagram resets all changes to the "instagram" field.
func (m *WebsiteMutation) ResetInstagram() {
	m.instagram = nil
	delete(m.clearedFields, website.FieldInstagram)
}

// SetYoutube sets the "youtube" field.
func (m *WebsiteMutation) SetYoutube(s string) {
	m.youtube = &s
}

// Youtube returns the value of the "youtube" field in the mutation.
func (m *WebsiteMutation) Youtube() (r string, exists bool) {
	v := m.youtube
	if v == nil {
		return
	}
	return *v, true
}

// OldYoutube returns the old "youtube" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldYoutube(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYoutube is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYoutube requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYoutube: %w", err)
	}
	return oldValue.Youtube, nil
}

// ClearYoutube clears the value of the "youtube" field.
func (m *WebsiteMutation) ClearYoutube() {
	m.youtube = nil
	m.clearedFields[website.FieldYoutube] = struct{}{}
}

// YoutubeCleared returns if the "youtube" field was cleared in this mutation.
func (m *WebsiteMutation) YoutubeCleared() bool {
	_, ok := m.clearedFields[website.FieldYoutube]
	return ok
}

// ResetYoutube resets all changes to the "youtube" field.
func (m *WebsiteMutation) ResetYoutube() {
	m.youtube = nil
	delete(m.clearedFields, website.FieldYoutube)
}

// SetLinkedin sets the "linkedin" field.
func (m *WebsiteMutation) SetLinkedin(s string) {
	m.linkedin = &s
}

// Linkedin returns the value of the "linkedin" field in the mutation.
func (m *WebsiteMutation) Linkedin() (r string, exists bool) {
	v := m.linkedin
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedin returns the old "linkedin" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldLinkedin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedin: %w", err)
	}
	return oldValue.Linkedin, nil
}

// ClearLinkedin clears the value of the "linkedin" field.
func (m *WebsiteMutation) ClearLinkedin() {
	m.linkedin = nil
	m.clearedFields[website.FieldLinkedin] = struct{}{}
}

// LinkedinCleared returns if the "linkedin" field was cleared in this mutation.
func (m *WebsiteMutation) LinkedinCleared() bool {
	_, ok := m.clearedFields[website.FieldLinkedin]
	return ok
}

// ResetLinkedin resets all changes to the "linkedin" field.
func (m *WebsiteMutation) ResetLinkedin() {
	m.linkedin = nil
	delete(m.clearedFields, website.FieldLinkedin)
}

// SetPinterest sets the "pinterest" field.
func (m *WebsiteMutation) SetPinterest(s string) {
	m.pinterest = &s
}

// Pinterest returns the value of the "pinterest" field in the mutation.
func (m *WebsiteMutation) Pinterest() (r string, exists bool) {
	v := m.pinterest
	if v == nil {
		return
	}
	return *v, true
}

// OldPinterest returns the old "pinterest" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldPinterest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinterest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinterest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinterest: %w", err)
	}
	return oldValue.Pinterest, nil
}

// ClearPinterest clears the value of the "pinterest" field.
func (m *WebsiteMutation) ClearPinterest() {
	m.pinterest = nil
	m.clearedFields[website.FieldPinterest] = struct{}{}
}

// PinterestCleared returns if the "pinterest" field was cleared in this mutation.
func (m *WebsiteMutation) PinterestCleared() bool {
	_, ok := m.clearedFields[website.FieldPinterest]
	return ok
}

// ResetPinterest resets all changes to the "pinterest" field.
func (m *WebsiteMutation) ResetPinterest() {
	m.pinterest = nil
	delete(m.clearedFields, website.FieldPinterest)
}

// SetMapCoordinates sets the "mapCoordinates" field.
func (m *WebsiteMutation) SetMapCoordinates(value map[string]interface{}) {
	m.mapCoordinates = &value
}

// MapCoordinates returns the value of the "mapCoordinates" field in the mutation.
func (m *WebsiteMutation) MapCoordinates() (r map[string]interface{}, exists bool) {
	v := m.mapCoordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldMapCoordinates returns the old "mapCoordinates" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldMapCoordinates(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapCoordinates: %w", err)
	}
	return oldValue.MapCoordinates, nil
}

// ClearMapCoordinates clears the value of the "mapCoordinates" field.
func (m *WebsiteMutation) ClearMapCoordinates() {
	m.mapCoordinates = nil
	m.clearedFields[website.FieldMapCoordinates] = struct{}{}
}

// MapCoordinatesCleared returns if the "mapCoordinates" field was cleared in this mutation.
func (m *WebsiteMutation) MapCoordinatesCleared() bool {
	_, ok := m.clearedFields[website.FieldMapCoordinates]
	return ok
}

// ResetMapCoordinates resets all changes to the "mapCoordinates" field.
func (m *WebsiteMutation) ResetMapCoordinates() {
	m.mapCoordinates = nil
	delete(m.clearedFields, website.FieldMapCoordinates)
}

// SetLongitude sets the "longitude" field.
func (m *WebsiteMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *WebsiteMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *WebsiteMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[website.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *WebsiteMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[website.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *WebsiteMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, website.FieldLongitude)
}

// SetLatitude sets the "latitude" field.
func (m *WebsiteMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *WebsiteMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *WebsiteMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[website.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *WebsiteMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[website.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *WebsiteMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, website.FieldLatitude)
}

// SetAddress sets the "address" field.
func (m *WebsiteMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *WebsiteMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *WebsiteMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[website.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *WebsiteMutation) AddressCleared() bool {
	_, ok := m.clearedFields[website.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *WebsiteMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, website.FieldAddress)
}

// SetCity sets the "city" field.
func (m *WebsiteMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *WebsiteMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *WebsiteMutation) ClearCity() {
	m.city = nil
	m.clearedFields[website.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *WebsiteMutation) CityCleared() bool {
	_, ok := m.clearedFields[website.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *WebsiteMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, website.FieldCity)
}

// SetState sets the "state" field.
func (m *WebsiteMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *WebsiteMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *WebsiteMutation) ClearState() {
	m.state = nil
	m.clearedFields[website.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *WebsiteMutation) StateCleared() bool {
	_, ok := m.clearedFields[website.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *WebsiteMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, website.FieldState)
}

// SetCountry sets the "country" field.
func (m *WebsiteMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *WebsiteMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *WebsiteMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[website.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *WebsiteMutation) CountryCleared() bool {
	_, ok := m.clearedFields[website.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *WebsiteMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, website.FieldCountry)
}

// SetZipCode sets the "zipCode" field.
func (m *WebsiteMutation) SetZipCode(s string) {
	m.zipCode = &s
}

// ZipCode returns the value of the "zipCode" field in the mutation.
func (m *WebsiteMutation) ZipCode() (r string, exists bool) {
	v := m.zipCode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "zipCode" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// ClearZipCode clears the value of the "zipCode" field.
func (m *WebsiteMutation) ClearZipCode() {
	m.zipCode = nil
	m.clearedFields[website.FieldZipCode] = struct{}{}
}

// ZipCodeCleared returns if the "zipCode" field was cleared in this mutation.
func (m *WebsiteMutation) ZipCodeCleared() bool {
	_, ok := m.clearedFields[website.FieldZipCode]
	return ok
}

// ResetZipCode resets all changes to the "zipCode" field.
func (m *WebsiteMutation) ResetZipCode() {
	m.zipCode = nil
	delete(m.clearedFields, website.FieldZipCode)
}

// SetPhoneNumber sets the "phoneNumber" field.
func (m *WebsiteMutation) SetPhoneNumber(s string) {
	m.phoneNumber = &s
}

// PhoneNumber returns the value of the "phoneNumber" field in the mutation.
func (m *WebsiteMutation) PhoneNumber() (r string, exists bool) {
	v := m.phoneNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phoneNumber" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phoneNumber" field.
func (m *WebsiteMutation) ClearPhoneNumber() {
	m.phoneNumber = nil
	m.clearedFields[website.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phoneNumber" field was cleared in this mutation.
func (m *WebsiteMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[website.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phoneNumber" field.
func (m *WebsiteMutation) ResetPhoneNumber() {
	m.phoneNumber = nil
	delete(m.clearedFields, website.FieldPhoneNumber)
}

// SetEmail sets the "email" field.
func (m *WebsiteMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *WebsiteMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *WebsiteMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[website.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *WebsiteMutation) EmailCleared() bool {
	_, ok := m.clearedFields[website.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *WebsiteMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, website.FieldEmail)
}

// SetMetaTags sets the "metaTags" field.
func (m *WebsiteMutation) SetMetaTags(value map[string]interface{}) {
	m.metaTags = &value
}

// MetaTags returns the value of the "metaTags" field in the mutation.
func (m *WebsiteMutation) MetaTags() (r map[string]interface{}, exists bool) {
	v := m.metaTags
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaTags returns the old "metaTags" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldMetaTags(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaTags: %w", err)
	}
	return oldValue.MetaTags, nil
}

// ClearMetaTags clears the value of the "metaTags" field.
func (m *WebsiteMutation) ClearMetaTags() {
	m.metaTags = nil
	m.clearedFields[website.FieldMetaTags] = struct{}{}
}

// MetaTagsCleared returns if the "metaTags" field was cleared in this mutation.
func (m *WebsiteMutation) MetaTagsCleared() bool {
	_, ok := m.clearedFields[website.FieldMetaTags]
	return ok
}

// ResetMetaTags resets all changes to the "metaTags" field.
func (m *WebsiteMutation) ResetMetaTags() {
	m.metaTags = nil
	delete(m.clearedFields, website.FieldMetaTags)
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *WebsiteMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *WebsiteMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *WebsiteMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *WebsiteMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *WebsiteMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *WebsiteMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// AddCustomBlockIDs adds the "customBlocks" edge to the CustomBlock entity by ids.
func (m *WebsiteMutation) AddCustomBlockIDs(ids ...string) {
	if m.customBlocks == nil {
		m.customBlocks = make(map[string]struct{})
	}
	for i := range ids {
		m.customBlocks[ids[i]] = struct{}{}
	}
}

// ClearCustomBlocks clears the "customBlocks" edge to the CustomBlock entity.
func (m *WebsiteMutation) ClearCustomBlocks() {
	m.clearedcustomBlocks = true
}

// CustomBlocksCleared reports if the "customBlocks" edge to the CustomBlock entity was cleared.
func (m *WebsiteMutation) CustomBlocksCleared() bool {
	return m.clearedcustomBlocks
}

// RemoveCustomBlockIDs removes the "customBlocks" edge to the CustomBlock entity by IDs.
func (m *WebsiteMutation) RemoveCustomBlockIDs(ids ...string) {
	if m.removedcustomBlocks == nil {
		m.removedcustomBlocks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.customBlocks, ids[i])
		m.removedcustomBlocks[ids[i]] = struct{}{}
	}
}

// RemovedCustomBlocks returns the removed IDs of the "customBlocks" edge to the CustomBlock entity.
func (m *WebsiteMutation) RemovedCustomBlocksIDs() (ids []string) {
	for id := range m.removedcustomBlocks {
		ids = append(ids, id)
	}
	return
}

// CustomBlocksIDs returns the "customBlocks" edge IDs in the mutation.
func (m *WebsiteMutation) CustomBlocksIDs() (ids []string) {
	for id := range m.customBlocks {
		ids = append(ids, id)
	}
	return
}

// ResetCustomBlocks resets all changes to the "customBlocks" edge.
func (m *WebsiteMutation) ResetCustomBlocks() {
	m.customBlocks = nil
	m.clearedcustomBlocks = false
	m.removedcustomBlocks = nil
}

// AddAssetIDs adds the "assets" edge to the Media entity by ids.
func (m *WebsiteMutation) AddAssetIDs(ids ...string) {
	if m.assets == nil {
		m.assets = make(map[string]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Media entity.
func (m *WebsiteMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Media entity was cleared.
func (m *WebsiteMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Media entity by IDs.
func (m *WebsiteMutation) RemoveAssetIDs(ids ...string) {
	if m.removedassets == nil {
		m.removedassets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Media entity.
func (m *WebsiteMutation) RemovedAssetsIDs() (ids []string) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *WebsiteMutation) AssetsIDs() (ids []string) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *WebsiteMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// Where appends a list predicates to the WebsiteMutation builder.
func (m *WebsiteMutation) Where(ps ...predicate.Website) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebsiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebsiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Website, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebsiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebsiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Website).
func (m *WebsiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebsiteMutation) Fields() []string {
	fields := make([]string, 0, 46)
	if m.domainName != nil {
		fields = append(fields, website.FieldDomainName)
	}
	if m.heading_text != nil {
		fields = append(fields, website.FieldHeadingText)
	}
	if m.business_logo != nil {
		fields = append(fields, website.FieldBusinessLogo)
	}
	if m.business_name != nil {
		fields = append(fields, website.FieldBusinessName)
	}
	if m.banner_section_background_image != nil {
		fields = append(fields, website.FieldBannerSectionBackgroundImage)
	}
	if m.banner_section_background_color != nil {
		fields = append(fields, website.FieldBannerSectionBackgroundColor)
	}
	if m.banner_section_text != nil {
		fields = append(fields, website.FieldBannerSectionText)
	}
	if m.three_items_section_heading_text != nil {
		fields = append(fields, website.FieldThreeItemsSectionHeadingText)
	}
	if m.three_items_section_details_text != nil {
		fields = append(fields, website.FieldThreeItemsSectionDetailsText)
	}
	if m.three_items_section_item_one_text != nil {
		fields = append(fields, website.FieldThreeItemsSectionItemOneText)
	}
	if m.three_items_section_item_two_text != nil {
		fields = append(fields, website.FieldThreeItemsSectionItemTwoText)
	}
	if m.three_items_section_item_three_text != nil {
		fields = append(fields, website.FieldThreeItemsSectionItemThreeText)
	}
	if m.banner_two_section_background_image != nil {
		fields = append(fields, website.FieldBannerTwoSectionBackgroundImage)
	}
	if m.banner_two_section_background_color != nil {
		fields = append(fields, website.FieldBannerTwoSectionBackgroundColor)
	}
	if m.banner_two_left_section_heading_text != nil {
		fields = append(fields, website.FieldBannerTwoLeftSectionHeadingText)
	}
	if m.banner_two_left_section_details_text != nil {
		fields = append(fields, website.FieldBannerTwoLeftSectionDetailsText)
	}
	if m.banner_two_left_section_button_text != nil {
		fields = append(fields, website.FieldBannerTwoLeftSectionButtonText)
	}
	if m.banner_two_left_section_button_link != nil {
		fields = append(fields, website.FieldBannerTwoLeftSectionButtonLink)
	}
	if m.banner_two_right_side_image != nil {
		fields = append(fields, website.FieldBannerTwoRightSideImage)
	}
	if m.achievements_section != nil {
		fields = append(fields, website.FieldAchievementsSection)
	}
	if m._Inventory_section_heading_text != nil {
		fields = append(fields, website.FieldInventorySectionHeadingText)
	}
	if m.creationDate != nil {
		fields = append(fields, website.FieldCreationDate)
	}
	if m.lastUpdated != nil {
		fields = append(fields, website.FieldLastUpdated)
	}
	if m.title != nil {
		fields = append(fields, website.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, website.FieldDescription)
	}
	if m.keywords != nil {
		fields = append(fields, website.FieldKeywords)
	}
	if m.language != nil {
		fields = append(fields, website.FieldLanguage)
	}
	if m.logo != nil {
		fields = append(fields, website.FieldLogo)
	}
	if m.favicon != nil {
		fields = append(fields, website.FieldFavicon)
	}
	if m.facebook != nil {
		fields = append(fields, website.FieldFacebook)
	}
	if m.twitter != nil {
		fields = append(fields, website.FieldTwitter)
	}
	if m.instagram != nil {
		fields = append(fields, website.FieldInstagram)
	}
	if m.youtube != nil {
		fields = append(fields, website.FieldYoutube)
	}
	if m.linkedin != nil {
		fields = append(fields, website.FieldLinkedin)
	}
	if m.pinterest != nil {
		fields = append(fields, website.FieldPinterest)
	}
	if m.mapCoordinates != nil {
		fields = append(fields, website.FieldMapCoordinates)
	}
	if m.longitude != nil {
		fields = append(fields, website.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, website.FieldLatitude)
	}
	if m.address != nil {
		fields = append(fields, website.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, website.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, website.FieldState)
	}
	if m.country != nil {
		fields = append(fields, website.FieldCountry)
	}
	if m.zipCode != nil {
		fields = append(fields, website.FieldZipCode)
	}
	if m.phoneNumber != nil {
		fields = append(fields, website.FieldPhoneNumber)
	}
	if m.email != nil {
		fields = append(fields, website.FieldEmail)
	}
	if m.metaTags != nil {
		fields = append(fields, website.FieldMetaTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebsiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case website.FieldDomainName:
		return m.DomainName()
	case website.FieldHeadingText:
		return m.HeadingText()
	case website.FieldBusinessLogo:
		return m.BusinessLogo()
	case website.FieldBusinessName:
		return m.BusinessName()
	case website.FieldBannerSectionBackgroundImage:
		return m.BannerSectionBackgroundImage()
	case website.FieldBannerSectionBackgroundColor:
		return m.BannerSectionBackgroundColor()
	case website.FieldBannerSectionText:
		return m.BannerSectionText()
	case website.FieldThreeItemsSectionHeadingText:
		return m.ThreeItemsSectionHeadingText()
	case website.FieldThreeItemsSectionDetailsText:
		return m.ThreeItemsSectionDetailsText()
	case website.FieldThreeItemsSectionItemOneText:
		return m.ThreeItemsSectionItemOneText()
	case website.FieldThreeItemsSectionItemTwoText:
		return m.ThreeItemsSectionItemTwoText()
	case website.FieldThreeItemsSectionItemThreeText:
		return m.ThreeItemsSectionItemThreeText()
	case website.FieldBannerTwoSectionBackgroundImage:
		return m.BannerTwoSectionBackgroundImage()
	case website.FieldBannerTwoSectionBackgroundColor:
		return m.BannerTwoSectionBackgroundColor()
	case website.FieldBannerTwoLeftSectionHeadingText:
		return m.BannerTwoLeftSectionHeadingText()
	case website.FieldBannerTwoLeftSectionDetailsText:
		return m.BannerTwoLeftSectionDetailsText()
	case website.FieldBannerTwoLeftSectionButtonText:
		return m.BannerTwoLeftSectionButtonText()
	case website.FieldBannerTwoLeftSectionButtonLink:
		return m.BannerTwoLeftSectionButtonLink()
	case website.FieldBannerTwoRightSideImage:
		return m.BannerTwoRightSideImage()
	case website.FieldAchievementsSection:
		return m.AchievementsSection()
	case website.FieldInventorySectionHeadingText:
		return m.InventorySectionHeadingText()
	case website.FieldCreationDate:
		return m.CreationDate()
	case website.FieldLastUpdated:
		return m.LastUpdated()
	case website.FieldTitle:
		return m.Title()
	case website.FieldDescription:
		return m.Description()
	case website.FieldKeywords:
		return m.Keywords()
	case website.FieldLanguage:
		return m.Language()
	case website.FieldLogo:
		return m.Logo()
	case website.FieldFavicon:
		return m.Favicon()
	case website.FieldFacebook:
		return m.Facebook()
	case website.FieldTwitter:
		return m.Twitter()
	case website.FieldInstagram:
		return m.Instagram()
	case website.FieldYoutube:
		return m.Youtube()
	case website.FieldLinkedin:
		return m.Linkedin()
	case website.FieldPinterest:
		return m.Pinterest()
	case website.FieldMapCoordinates:
		return m.MapCoordinates()
	case website.FieldLongitude:
		return m.Longitude()
	case website.FieldLatitude:
		return m.Latitude()
	case website.FieldAddress:
		return m.Address()
	case website.FieldCity:
		return m.City()
	case website.FieldState:
		return m.State()
	case website.FieldCountry:
		return m.Country()
	case website.FieldZipCode:
		return m.ZipCode()
	case website.FieldPhoneNumber:
		return m.PhoneNumber()
	case website.FieldEmail:
		return m.Email()
	case website.FieldMetaTags:
		return m.MetaTags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebsiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case website.FieldDomainName:
		return m.OldDomainName(ctx)
	case website.FieldHeadingText:
		return m.OldHeadingText(ctx)
	case website.FieldBusinessLogo:
		return m.OldBusinessLogo(ctx)
	case website.FieldBusinessName:
		return m.OldBusinessName(ctx)
	case website.FieldBannerSectionBackgroundImage:
		return m.OldBannerSectionBackgroundImage(ctx)
	case website.FieldBannerSectionBackgroundColor:
		return m.OldBannerSectionBackgroundColor(ctx)
	case website.FieldBannerSectionText:
		return m.OldBannerSectionText(ctx)
	case website.FieldThreeItemsSectionHeadingText:
		return m.OldThreeItemsSectionHeadingText(ctx)
	case website.FieldThreeItemsSectionDetailsText:
		return m.OldThreeItemsSectionDetailsText(ctx)
	case website.FieldThreeItemsSectionItemOneText:
		return m.OldThreeItemsSectionItemOneText(ctx)
	case website.FieldThreeItemsSectionItemTwoText:
		return m.OldThreeItemsSectionItemTwoText(ctx)
	case website.FieldThreeItemsSectionItemThreeText:
		return m.OldThreeItemsSectionItemThreeText(ctx)
	case website.FieldBannerTwoSectionBackgroundImage:
		return m.OldBannerTwoSectionBackgroundImage(ctx)
	case website.FieldBannerTwoSectionBackgroundColor:
		return m.OldBannerTwoSectionBackgroundColor(ctx)
	case website.FieldBannerTwoLeftSectionHeadingText:
		return m.OldBannerTwoLeftSectionHeadingText(ctx)
	case website.FieldBannerTwoLeftSectionDetailsText:
		return m.OldBannerTwoLeftSectionDetailsText(ctx)
	case website.FieldBannerTwoLeftSectionButtonText:
		return m.OldBannerTwoLeftSectionButtonText(ctx)
	case website.FieldBannerTwoLeftSectionButtonLink:
		return m.OldBannerTwoLeftSectionButtonLink(ctx)
	case website.FieldBannerTwoRightSideImage:
		return m.OldBannerTwoRightSideImage(ctx)
	case website.FieldAchievementsSection:
		return m.OldAchievementsSection(ctx)
	case website.FieldInventorySectionHeadingText:
		return m.OldInventorySectionHeadingText(ctx)
	case website.FieldCreationDate:
		return m.OldCreationDate(ctx)
	case website.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case website.FieldTitle:
		return m.OldTitle(ctx)
	case website.FieldDescription:
		return m.OldDescription(ctx)
	case website.FieldKeywords:
		return m.OldKeywords(ctx)
	case website.FieldLanguage:
		return m.OldLanguage(ctx)
	case website.FieldLogo:
		return m.OldLogo(ctx)
	case website.FieldFavicon:
		return m.OldFavicon(ctx)
	case website.FieldFacebook:
		return m.OldFacebook(ctx)
	case website.FieldTwitter:
		return m.OldTwitter(ctx)
	case website.FieldInstagram:
		return m.OldInstagram(ctx)
	case website.FieldYoutube:
		return m.OldYoutube(ctx)
	case website.FieldLinkedin:
		return m.OldLinkedin(ctx)
	case website.FieldPinterest:
		return m.OldPinterest(ctx)
	case website.FieldMapCoordinates:
		return m.OldMapCoordinates(ctx)
	case website.FieldLongitude:
		return m.OldLongitude(ctx)
	case website.FieldLatitude:
		return m.OldLatitude(ctx)
	case website.FieldAddress:
		return m.OldAddress(ctx)
	case website.FieldCity:
		return m.OldCity(ctx)
	case website.FieldState:
		return m.OldState(ctx)
	case website.FieldCountry:
		return m.OldCountry(ctx)
	case website.FieldZipCode:
		return m.OldZipCode(ctx)
	case website.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case website.FieldEmail:
		return m.OldEmail(ctx)
	case website.FieldMetaTags:
		return m.OldMetaTags(ctx)
	}
	return nil, fmt.Errorf("unknown Website field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebsiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case website.FieldDomainName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainName(v)
		return nil
	case website.FieldHeadingText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadingText(v)
		return nil
	case website.FieldBusinessLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessLogo(v)
		return nil
	case website.FieldBusinessName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessName(v)
		return nil
	case website.FieldBannerSectionBackgroundImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerSectionBackgroundImage(v)
		return nil
	case website.FieldBannerSectionBackgroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerSectionBackgroundColor(v)
		return nil
	case website.FieldBannerSectionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerSectionText(v)
		return nil
	case website.FieldThreeItemsSectionHeadingText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreeItemsSectionHeadingText(v)
		return nil
	case website.FieldThreeItemsSectionDetailsText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreeItemsSectionDetailsText(v)
		return nil
	case website.FieldThreeItemsSectionItemOneText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreeItemsSectionItemOneText(v)
		return nil
	case website.FieldThreeItemsSectionItemTwoText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreeItemsSectionItemTwoText(v)
		return nil
	case website.FieldThreeItemsSectionItemThreeText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreeItemsSectionItemThreeText(v)
		return nil
	case website.FieldBannerTwoSectionBackgroundImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerTwoSectionBackgroundImage(v)
		return nil
	case website.FieldBannerTwoSectionBackgroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerTwoSectionBackgroundColor(v)
		return nil
	case website.FieldBannerTwoLeftSectionHeadingText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerTwoLeftSectionHeadingText(v)
		return nil
	case website.FieldBannerTwoLeftSectionDetailsText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerTwoLeftSectionDetailsText(v)
		return nil
	case website.FieldBannerTwoLeftSectionButtonText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerTwoLeftSectionButtonText(v)
		return nil
	case website.FieldBannerTwoLeftSectionButtonLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerTwoLeftSectionButtonLink(v)
		return nil
	case website.FieldBannerTwoRightSideImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerTwoRightSideImage(v)
		return nil
	case website.FieldAchievementsSection:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievementsSection(v)
		return nil
	case website.FieldInventorySectionHeadingText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventorySectionHeadingText(v)
		return nil
	case website.FieldCreationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationDate(v)
		return nil
	case website.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case website.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case website.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case website.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case website.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case website.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case website.FieldFavicon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFavicon(v)
		return nil
	case website.FieldFacebook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacebook(v)
		return nil
	case website.FieldTwitter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitter(v)
		return nil
	case website.FieldInstagram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstagram(v)
		return nil
	case website.FieldYoutube:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYoutube(v)
		return nil
	case website.FieldLinkedin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedin(v)
		return nil
	case website.FieldPinterest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinterest(v)
		return nil
	case website.FieldMapCoordinates:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapCoordinates(v)
		return nil
	case website.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case website.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case website.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case website.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case website.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case website.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case website.FieldZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case website.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case website.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case website.FieldMetaTags:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaTags(v)
		return nil
	}
	return fmt.Errorf("unknown Website field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebsiteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebsiteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebsiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Website numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebsiteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(website.FieldHeadingText) {
		fields = append(fields, website.FieldHeadingText)
	}
	if m.FieldCleared(website.FieldBusinessLogo) {
		fields = append(fields, website.FieldBusinessLogo)
	}
	if m.FieldCleared(website.FieldBusinessName) {
		fields = append(fields, website.FieldBusinessName)
	}
	if m.FieldCleared(website.FieldBannerSectionBackgroundImage) {
		fields = append(fields, website.FieldBannerSectionBackgroundImage)
	}
	if m.FieldCleared(website.FieldBannerSectionBackgroundColor) {
		fields = append(fields, website.FieldBannerSectionBackgroundColor)
	}
	if m.FieldCleared(website.FieldBannerSectionText) {
		fields = append(fields, website.FieldBannerSectionText)
	}
	if m.FieldCleared(website.FieldThreeItemsSectionHeadingText) {
		fields = append(fields, website.FieldThreeItemsSectionHeadingText)
	}
	if m.FieldCleared(website.FieldThreeItemsSectionDetailsText) {
		fields = append(fields, website.FieldThreeItemsSectionDetailsText)
	}
	if m.FieldCleared(website.FieldThreeItemsSectionItemOneText) {
		fields = append(fields, website.FieldThreeItemsSectionItemOneText)
	}
	if m.FieldCleared(website.FieldThreeItemsSectionItemTwoText) {
		fields = append(fields, website.FieldThreeItemsSectionItemTwoText)
	}
	if m.FieldCleared(website.FieldThreeItemsSectionItemThreeText) {
		fields = append(fields, website.FieldThreeItemsSectionItemThreeText)
	}
	if m.FieldCleared(website.FieldBannerTwoSectionBackgroundImage) {
		fields = append(fields, website.FieldBannerTwoSectionBackgroundImage)
	}
	if m.FieldCleared(website.FieldBannerTwoSectionBackgroundColor) {
		fields = append(fields, website.FieldBannerTwoSectionBackgroundColor)
	}
	if m.FieldCleared(website.FieldBannerTwoLeftSectionHeadingText) {
		fields = append(fields, website.FieldBannerTwoLeftSectionHeadingText)
	}
	if m.FieldCleared(website.FieldBannerTwoLeftSectionDetailsText) {
		fields = append(fields, website.FieldBannerTwoLeftSectionDetailsText)
	}
	if m.FieldCleared(website.FieldBannerTwoLeftSectionButtonText) {
		fields = append(fields, website.FieldBannerTwoLeftSectionButtonText)
	}
	if m.FieldCleared(website.FieldBannerTwoLeftSectionButtonLink) {
		fields = append(fields, website.FieldBannerTwoLeftSectionButtonLink)
	}
	if m.FieldCleared(website.FieldBannerTwoRightSideImage) {
		fields = append(fields, website.FieldBannerTwoRightSideImage)
	}
	if m.FieldCleared(website.FieldAchievementsSection) {
		fields = append(fields, website.FieldAchievementsSection)
	}
	if m.FieldCleared(website.FieldInventorySectionHeadingText) {
		fields = append(fields, website.FieldInventorySectionHeadingText)
	}
	if m.FieldCleared(website.FieldTitle) {
		fields = append(fields, website.FieldTitle)
	}
	if m.FieldCleared(website.FieldDescription) {
		fields = append(fields, website.FieldDescription)
	}
	if m.FieldCleared(website.FieldKeywords) {
		fields = append(fields, website.FieldKeywords)
	}
	if m.FieldCleared(website.FieldLanguage) {
		fields = append(fields, website.FieldLanguage)
	}
	if m.FieldCleared(website.FieldLogo) {
		fields = append(fields, website.FieldLogo)
	}
	if m.FieldCleared(website.FieldFavicon) {
		fields = append(fields, website.FieldFavicon)
	}
	if m.FieldCleared(website.FieldFacebook) {
		fields = append(fields, website.FieldFacebook)
	}
	if m.FieldCleared(website.FieldTwitter) {
		fields = append(fields, website.FieldTwitter)
	}
	if m.FieldCleared(website.FieldInstagram) {
		fields = append(fields, website.FieldInstagram)
	}
	if m.FieldCleared(website.FieldYoutube) {
		fields = append(fields, website.FieldYoutube)
	}
	if m.FieldCleared(website.FieldLinkedin) {
		fields = append(fields, website.FieldLinkedin)
	}
	if m.FieldCleared(website.FieldPinterest) {
		fields = append(fields, website.FieldPinterest)
	}
	if m.FieldCleared(website.FieldMapCoordinates) {
		fields = append(fields, website.FieldMapCoordinates)
	}
	if m.FieldCleared(website.FieldLongitude) {
		fields = append(fields, website.FieldLongitude)
	}
	if m.FieldCleared(website.FieldLatitude) {
		fields = append(fields, website.FieldLatitude)
	}
	if m.FieldCleared(website.FieldAddress) {
		fields = append(fields, website.FieldAddress)
	}
	if m.FieldCleared(website.FieldCity) {
		fields = append(fields, website.FieldCity)
	}
	if m.FieldCleared(website.FieldState) {
		fields = append(fields, website.FieldState)
	}
	if m.FieldCleared(website.FieldCountry) {
		fields = append(fields, website.FieldCountry)
	}
	if m.FieldCleared(website.FieldZipCode) {
		fields = append(fields, website.FieldZipCode)
	}
	if m.FieldCleared(website.FieldPhoneNumber) {
		fields = append(fields, website.FieldPhoneNumber)
	}
	if m.FieldCleared(website.FieldEmail) {
		fields = append(fields, website.FieldEmail)
	}
	if m.FieldCleared(website.FieldMetaTags) {
		fields = append(fields, website.FieldMetaTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebsiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebsiteMutation) ClearField(name string) error {
	switch name {
	case website.FieldHeadingText:
		m.ClearHeadingText()
		return nil
	case website.FieldBusinessLogo:
		m.ClearBusinessLogo()
		return nil
	case website.FieldBusinessName:
		m.ClearBusinessName()
		return nil
	case website.FieldBannerSectionBackgroundImage:
		m.ClearBannerSectionBackgroundImage()
		return nil
	case website.FieldBannerSectionBackgroundColor:
		m.ClearBannerSectionBackgroundColor()
		return nil
	case website.FieldBannerSectionText:
		m.ClearBannerSectionText()
		return nil
	case website.FieldThreeItemsSectionHeadingText:
		m.ClearThreeItemsSectionHeadingText()
		return nil
	case website.FieldThreeItemsSectionDetailsText:
		m.ClearThreeItemsSectionDetailsText()
		return nil
	case website.FieldThreeItemsSectionItemOneText:
		m.ClearThreeItemsSectionItemOneText()
		return nil
	case website.FieldThreeItemsSectionItemTwoText:
		m.ClearThreeItemsSectionItemTwoText()
		return nil
	case website.FieldThreeItemsSectionItemThreeText:
		m.ClearThreeItemsSectionItemThreeText()
		return nil
	case website.FieldBannerTwoSectionBackgroundImage:
		m.ClearBannerTwoSectionBackgroundImage()
		return nil
	case website.FieldBannerTwoSectionBackgroundColor:
		m.ClearBannerTwoSectionBackgroundColor()
		return nil
	case website.FieldBannerTwoLeftSectionHeadingText:
		m.ClearBannerTwoLeftSectionHeadingText()
		return nil
	case website.FieldBannerTwoLeftSectionDetailsText:
		m.ClearBannerTwoLeftSectionDetailsText()
		return nil
	case website.FieldBannerTwoLeftSectionButtonText:
		m.ClearBannerTwoLeftSectionButtonText()
		return nil
	case website.FieldBannerTwoLeftSectionButtonLink:
		m.ClearBannerTwoLeftSectionButtonLink()
		return nil
	case website.FieldBannerTwoRightSideImage:
		m.ClearBannerTwoRightSideImage()
		return nil
	case website.FieldAchievementsSection:
		m.ClearAchievementsSection()
		return nil
	case website.FieldInventorySectionHeadingText:
		m.ClearInventorySectionHeadingText()
		return nil
	case website.FieldTitle:
		m.ClearTitle()
		return nil
	case website.FieldDescription:
		m.ClearDescription()
		return nil
	case website.FieldKeywords:
		m.ClearKeywords()
		return nil
	case website.FieldLanguage:
		m.ClearLanguage()
		return nil
	case website.FieldLogo:
		m.ClearLogo()
		return nil
	case website.FieldFavicon:
		m.ClearFavicon()
		return nil
	case website.FieldFacebook:
		m.ClearFacebook()
		return nil
	case website.FieldTwitter:
		m.ClearTwitter()
		return nil
	case website.FieldInstagram:
		m.ClearInstagram()
		return nil
	case website.FieldYoutube:
		m.ClearYoutube()
		return nil
	case website.FieldLinkedin:
		m.ClearLinkedin()
		return nil
	case website.FieldPinterest:
		m.ClearPinterest()
		return nil
	case website.FieldMapCoordinates:
		m.ClearMapCoordinates()
		return nil
	case website.FieldLongitude:
		m.ClearLongitude()
		return nil
	case website.FieldLatitude:
		m.ClearLatitude()
		return nil
	case website.FieldAddress:
		m.ClearAddress()
		return nil
	case website.FieldCity:
		m.ClearCity()
		return nil
	case website.FieldState:
		m.ClearState()
		return nil
	case website.FieldCountry:
		m.ClearCountry()
		return nil
	case website.FieldZipCode:
		m.ClearZipCode()
		return nil
	case website.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case website.FieldEmail:
		m.ClearEmail()
		return nil
	case website.FieldMetaTags:
		m.ClearMetaTags()
		return nil
	}
	return fmt.Errorf("unknown Website nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebsiteMutation) ResetField(name string) error {
	switch name {
	case website.FieldDomainName:
		m.ResetDomainName()
		return nil
	case website.FieldHeadingText:
		m.ResetHeadingText()
		return nil
	case website.FieldBusinessLogo:
		m.ResetBusinessLogo()
		return nil
	case website.FieldBusinessName:
		m.ResetBusinessName()
		return nil
	case website.FieldBannerSectionBackgroundImage:
		m.ResetBannerSectionBackgroundImage()
		return nil
	case website.FieldBannerSectionBackgroundColor:
		m.ResetBannerSectionBackgroundColor()
		return nil
	case website.FieldBannerSectionText:
		m.ResetBannerSectionText()
		return nil
	case website.FieldThreeItemsSectionHeadingText:
		m.ResetThreeItemsSectionHeadingText()
		return nil
	case website.FieldThreeItemsSectionDetailsText:
		m.ResetThreeItemsSectionDetailsText()
		return nil
	case website.FieldThreeItemsSectionItemOneText:
		m.ResetThreeItemsSectionItemOneText()
		return nil
	case website.FieldThreeItemsSectionItemTwoText:
		m.ResetThreeItemsSectionItemTwoText()
		return nil
	case website.FieldThreeItemsSectionItemThreeText:
		m.ResetThreeItemsSectionItemThreeText()
		return nil
	case website.FieldBannerTwoSectionBackgroundImage:
		m.ResetBannerTwoSectionBackgroundImage()
		return nil
	case website.FieldBannerTwoSectionBackgroundColor:
		m.ResetBannerTwoSectionBackgroundColor()
		return nil
	case website.FieldBannerTwoLeftSectionHeadingText:
		m.ResetBannerTwoLeftSectionHeadingText()
		return nil
	case website.FieldBannerTwoLeftSectionDetailsText:
		m.ResetBannerTwoLeftSectionDetailsText()
		return nil
	case website.FieldBannerTwoLeftSectionButtonText:
		m.ResetBannerTwoLeftSectionButtonText()
		return nil
	case website.FieldBannerTwoLeftSectionButtonLink:
		m.ResetBannerTwoLeftSectionButtonLink()
		return nil
	case website.FieldBannerTwoRightSideImage:
		m.ResetBannerTwoRightSideImage()
		return nil
	case website.FieldAchievementsSection:
		m.ResetAchievementsSection()
		return nil
	case website.FieldInventorySectionHeadingText:
		m.ResetInventorySectionHeadingText()
		return nil
	case website.FieldCreationDate:
		m.ResetCreationDate()
		return nil
	case website.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case website.FieldTitle:
		m.ResetTitle()
		return nil
	case website.FieldDescription:
		m.ResetDescription()
		return nil
	case website.FieldKeywords:
		m.ResetKeywords()
		return nil
	case website.FieldLanguage:
		m.ResetLanguage()
		return nil
	case website.FieldLogo:
		m.ResetLogo()
		return nil
	case website.FieldFavicon:
		m.ResetFavicon()
		return nil
	case website.FieldFacebook:
		m.ResetFacebook()
		return nil
	case website.FieldTwitter:
		m.ResetTwitter()
		return nil
	case website.FieldInstagram:
		m.ResetInstagram()
		return nil
	case website.FieldYoutube:
		m.ResetYoutube()
		return nil
	case website.FieldLinkedin:
		m.ResetLinkedin()
		return nil
	case website.FieldPinterest:
		m.ResetPinterest()
		return nil
	case website.FieldMapCoordinates:
		m.ResetMapCoordinates()
		return nil
	case website.FieldLongitude:
		m.ResetLongitude()
		return nil
	case website.FieldLatitude:
		m.ResetLatitude()
		return nil
	case website.FieldAddress:
		m.ResetAddress()
		return nil
	case website.FieldCity:
		m.ResetCity()
		return nil
	case website.FieldState:
		m.ResetState()
		return nil
	case website.FieldCountry:
		m.ResetCountry()
		return nil
	case website.FieldZipCode:
		m.ResetZipCode()
		return nil
	case website.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case website.FieldEmail:
		m.ResetEmail()
		return nil
	case website.FieldMetaTags:
		m.ResetMetaTags()
		return nil
	}
	return fmt.Errorf("unknown Website field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebsiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business != nil {
		edges = append(edges, website.EdgeBusiness)
	}
	if m.customBlocks != nil {
		edges = append(edges, website.EdgeCustomBlocks)
	}
	if m.assets != nil {
		edges = append(edges, website.EdgeAssets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebsiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case website.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case website.EdgeCustomBlocks:
		ids := make([]ent.Value, 0, len(m.customBlocks))
		for id := range m.customBlocks {
			ids = append(ids, id)
		}
		return ids
	case website.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebsiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcustomBlocks != nil {
		edges = append(edges, website.EdgeCustomBlocks)
	}
	if m.removedassets != nil {
		edges = append(edges, website.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebsiteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case website.EdgeCustomBlocks:
		ids := make([]ent.Value, 0, len(m.removedcustomBlocks))
		for id := range m.removedcustomBlocks {
			ids = append(ids, id)
		}
		return ids
	case website.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebsiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness {
		edges = append(edges, website.EdgeBusiness)
	}
	if m.clearedcustomBlocks {
		edges = append(edges, website.EdgeCustomBlocks)
	}
	if m.clearedassets {
		edges = append(edges, website.EdgeAssets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebsiteMutation) EdgeCleared(name string) bool {
	switch name {
	case website.EdgeBusiness:
		return m.clearedbusiness
	case website.EdgeCustomBlocks:
		return m.clearedcustomBlocks
	case website.EdgeAssets:
		return m.clearedassets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebsiteMutation) ClearEdge(name string) error {
	switch name {
	case website.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown Website unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebsiteMutation) ResetEdge(name string) error {
	switch name {
	case website.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case website.EdgeCustomBlocks:
		m.ResetCustomBlocks()
		return nil
	case website.EdgeAssets:
		m.ResetAssets()
		return nil
	}
	return fmt.Errorf("unknown Website edge %s", name)
}
